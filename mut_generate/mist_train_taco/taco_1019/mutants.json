{
  "task_id": "taco_1019",
  "entry_point": "restore_operations",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op -= [(2, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op -= [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] - 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] - 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] * 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] * 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 1\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = -1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = -1\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 1\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[0][2]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][2]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[0][0]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][0]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[0][0]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][0]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[0][-1]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][-1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op -= [(1, x + 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op -= [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] + 2",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 2\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] + 0",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 0\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] + 0",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 0\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][0] + -1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + -1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(2, len(pic) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(2, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(0, len(pic) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(0, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(0, len(pic) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(0, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(-1, len(pic) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(-1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) + 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) + 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) * 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) * 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h -= pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h -= pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[1][1]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[1][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[-1][1]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[-1][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevpic = sortpics[0][1]",
      "mutated_line": "prevpic = sortpics[1][1]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[1][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, pic) in sortpics[1:]:",
      "mutated_line": "for (i, pic) in sortpics[2:]:",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[2:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, pic) in sortpics[1:]:",
      "mutated_line": "for (i, pic) in sortpics[0:]:",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[0:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, pic) in sortpics[1:]:",
      "mutated_line": "for (i, pic) in sortpics[0:]:",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[0:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (i, pic) in sortpics[1:]:",
      "mutated_line": "for (i, pic) in sortpics[-1:]:",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[-1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][1] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][1] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][-1] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][-1] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[0][1] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][1] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) - 2):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 2):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) - 0):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 0):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) - 0):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 0):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(1, len(pic) - 1):",
      "mutated_line": "for i in range(1, len(pic) - -1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - -1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(2, len(pic[i]) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(2, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(0, len(pic[i]) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(0, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(0, len(pic[i]) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(0, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(-1, len(pic[i]) - 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(-1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) + 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) + 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) * 1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) * 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] or pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] or pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if pic1[i][j] != pic2[i][j]:",
      "mutated_line": "if pic1[i][j] == pic2[i][j]:",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] == pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "diff += [(i, j)]",
      "mutated_line": "diff -= [(i, j)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff -= [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))",
      "mutated_line": "sortpics = sorted(pics, key=lambda p: +countHoles(p[1]))",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: +countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(3, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(3, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(1, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(1, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(0, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(0, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(1, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(1, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(-2, i + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(-2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i - 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i - 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i * 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i * 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[1][0] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[1][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[-1][0] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[-1][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "initial_picture_index = sortpics[0][0] + 1",
      "mutated_line": "initial_picture_index = sortpics[1][0] + 1",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[1][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) - 2):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 2):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) - 0):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 0):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) - 0):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 0):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(pic[i]) - 1):",
      "mutated_line": "for j in range(1, len(pic[i]) - -1):",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - -1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] != pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] != pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] == pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] == pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(2, x + 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(2, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(0, x + 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(0, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(0, x + 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(0, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(-1, x + 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(-1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x - 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x - 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x * 1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x * 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y - 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y - 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y * 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y * 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i + 2)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 2)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i + 0)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 0)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i + 0)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 0)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "op += [(2, i + 1)]",
      "mutated_line": "op += [(2, i + -1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + -1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 2, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 2, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 0, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 0, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 0, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 0, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + -1, y + 1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + -1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y + 2)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 2)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y + 0)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 0)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y + 0)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 0)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "op += [(1, x + 1, y + 1)]",
      "mutated_line": "op += [(1, x + 1, y + -1)]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + -1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j + 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j + 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j * 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j * 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j - 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j - 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j * 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j * 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))",
      "mutated_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[2]))",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[2]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))",
      "mutated_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[0]))",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[0]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))",
      "mutated_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[0]))",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[0]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))",
      "mutated_line": "sortpics = sorted(pics, key=lambda p: -countHoles(p[-1]))",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[-1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i - 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i - 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i * 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i * 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i + 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i + 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i * 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i * 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 2] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 2] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 0] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 0] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 0] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 0] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - -1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - -1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 2] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 2] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 0] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 0] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 0] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 0] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + -1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + -1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i - 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i - 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i * 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i * 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 2][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 2][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 0][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 0][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 0][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 0][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + -1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + -1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 2][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 2][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 0][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 0][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 0][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 0][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - -1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - -1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 2][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 2][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 0][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 0][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 0][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 0][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + 1][j] != pic[i][j]",
      "mutated_line": "h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + -1][j] != pic[i][j]",
      "code": "def restore_operations(n, m, k, pictures):\n\n    def countHoles(pic):\n        h = 0\n        for i in range(1, len(pic) - 1):\n            for j in range(1, len(pic[i]) - 1):\n                h += pic[i + 1][j] == pic[i - 1][j] == pic[i][j - 1] == pic[i][j + 1] and pic[i + -1][j] != pic[i][j]\n        return h\n\n    def findDiff(pic1, pic2):\n        diff = []\n        for i in range(len(pic1)):\n            for j in range(len(pic1[i])):\n                if pic1[i][j] != pic2[i][j]:\n                    diff += [(i, j)]\n        return diff\n    pics = [(i, pic) for (i, pic) in enumerate(pictures)]\n    sortpics = sorted(pics, key=lambda p: -countHoles(p[1]))\n    prevpic = sortpics[0][1]\n    op = []\n    for (i, pic) in sortpics[1:]:\n        diff = findDiff(prevpic, pic)\n        for (x, y) in diff:\n            op += [(1, x + 1, y + 1)]\n        op += [(2, i + 1)]\n        prevpic = pic\n    initial_picture_index = sortpics[0][0] + 1\n    num_operations = len(op)\n    operations = op\n    return (initial_picture_index, num_operations, operations)"
    }
  ]
}