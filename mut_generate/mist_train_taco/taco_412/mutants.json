{
  "task_id": "taco_412",
  "entry_point": "calculate_benford_probability",
  "mutant_count": 211,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) - 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) - 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) * 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) * 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k != 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a != 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a != 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) + num_ones(0, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) + num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) * num_ones(0, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) * num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] == -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need >= far + 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need >= far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need <= far + 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need <= far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need != far + 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need != far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if need == 0:",
      "mutated_line": "if need != 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need != 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if far == 0:",
      "mutated_line": "if far != 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far != 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) - (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) - (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) * ((1 - L[far]) * dp(far - 1, need))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) * ((1 - L[far]) * dp(far - 1, need))\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) + 2",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 2\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) + 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 0\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) + 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 0\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 100) + -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + -1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 1:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == -1:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 1:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "atLeast = 0",
      "mutated_line": "atLeast = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 1\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "atLeast = 0",
      "mutated_line": "atLeast = -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = -1\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "atLeast = 0",
      "mutated_line": "atLeast = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 1\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 1, atLeast), 11)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 11)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 1, atLeast), 9)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 9)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 1, atLeast), 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 0)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 1, atLeast), 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 1)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 1, atLeast), -10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), -10)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 1:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == -1:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 1:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if b == 0:",
      "mutated_line": "if b != 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b != 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 1\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = -1\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 1\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans -= 10 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans -= 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if b[0] == '1':",
      "mutated_line": "if b[0] != '1':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] != '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans -= x + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans -= x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans -= 10 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans -= 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] != +1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != +1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far - 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far - 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far * 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far * 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 1\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return -1\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 1\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if need == 0:",
      "mutated_line": "if need == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 1:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if need == 0:",
      "mutated_line": "if need == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == -1:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if need == 0:",
      "mutated_line": "if need == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 1:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 2\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 0\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 0\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return -1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if far == 0:",
      "mutated_line": "if far == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 1:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if far == 0:",
      "mutated_line": "if far == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == -1:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if far == 0:",
      "mutated_line": "if far == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 1:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] / dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] / dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] + dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] + dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] ** dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] ** dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) / dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) / dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far] + dp(far - 1, need))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far] + dp(far - 1, need))\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) ** dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) ** dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) * (Ri - Li + 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) * (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) // (Ri - Li + 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) // (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) * 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) * 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) // 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) // 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] / (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] / (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] + (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] + (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] ** (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] ** (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n + 1, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n + 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n * 1, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n * 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 1:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if b == 0:",
      "mutated_line": "if b == -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == -1:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 1:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 1\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return -1\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 1\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(2, len(b)):",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(2, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(0, len(b)):",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(0, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(0, len(b)):",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(0, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(-1, len(b)):",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(-1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 * (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 * (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 + (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 + (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b[0] == '1':",
      "mutated_line": "if b[0] == '':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == '':",
      "mutated_line": "if x != '':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x != '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x - 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x - 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x * 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x * 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 * (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 * (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 + (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 + (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(1, b) - num_ones(0, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(1, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(-1, b) - num_ones(0, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(-1, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(1, b) - num_ones(0, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(1, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(1, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(1, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(-1, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(-1, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(1, a - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(1, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a + 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a + 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a * 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a * 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] != -2:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -2:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] != -0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -0:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] != -0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -0:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if DP[far][need] != -1:",
      "mutated_line": "if DP[far][need] != --1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != --1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far + 2:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 2:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far + 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 0:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far + 0:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 0:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if need > far + 1:",
      "mutated_line": "if need > far + -1:",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + -1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return L[0]",
      "mutated_line": "return L[1]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[1]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return L[0]",
      "mutated_line": "return L[-1]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[-1]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return L[0]",
      "mutated_line": "return L[1]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[1]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 + L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 + L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + 1 * L[far] * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + 1 * L[far] * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri - Li - 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li - 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / ((Ri - Li) * 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / ((Ri - Li) * 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k + 1) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k + 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int(n * k * 1 / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int(n * k * 1 / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 101) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 101) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 99) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 99) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 0) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 0) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / 1) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 1) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 1) / -100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / -100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast - 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast - 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast * 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast * 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 2, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 2, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 0, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 0, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - 0, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 0, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return round(dp(n - 1, atLeast), 10)",
      "mutated_line": "return round(dp(n - -1, atLeast), 10)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - -1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 11 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 11 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 9 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 9 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 0 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 0 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 1 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 1 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += -10 ** (i - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += -10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i + 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i + 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i * 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i * 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b[0] == '1':",
      "mutated_line": "if b[1] == '1':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[1] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b[0] == '1':",
      "mutated_line": "if b[-1] == '1':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[-1] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b[0] == '1':",
      "mutated_line": "if b[1] == '1':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[1] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x == '':",
      "mutated_line": "if x == 'MUTATED':",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == 'MUTATED':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 1\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = -1\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 1\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x + 2",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 2\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x + 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 0\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x + 0",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 0\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += x + 1",
      "mutated_line": "ans += x + -1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + -1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 11 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 11 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 9 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 9 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 0 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 0 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 1 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 1 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += -10 ** (len(b) - 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += -10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) + 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) + 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) * 1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) * 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a - 2)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 2)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 0)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 0)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return num_ones(0, b) - num_ones(0, a - 1)",
      "mutated_line": "return num_ones(0, b) - num_ones(0, a - -1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - -1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far + 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far + 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far * 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far * 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need + 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need + 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need * 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need * 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (2 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (2 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (0 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (0 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (0 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (0 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (-1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (-1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far + 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far + 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far * 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far * 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri + Li + 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri + Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri * Li + 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri * Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 2))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 2))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 0))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 0))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 0))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 0))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L.append(num_ones(Li, Ri) / (Ri - Li + 1))",
      "mutated_line": "L.append(num_ones(Li, Ri) / (Ri - Li + -1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + -1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n / k - 1) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n / k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n + k - 1) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n + k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n ** k - 1) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n ** k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 2) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 2) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 0) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 0) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - 0) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 0) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "atLeast = int((n * k - 1) / 100) + 1",
      "mutated_line": "atLeast = int((n * k - -1) / 100) + 1",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - -1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([+1] * (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([+1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast + 6))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 6))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast + 4))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 4))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast + 0))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 0))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast + 1))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 1))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-1] * (atLeast + -5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + -5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i - 2)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 2)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 0)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 0)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans += 10 ** (i - 1)",
      "mutated_line": "ans += 10 ** (i - -1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - -1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x = b[1:]",
      "mutated_line": "x = b[2:]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[2:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x = b[1:]",
      "mutated_line": "x = b[0:]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[0:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x = b[1:]",
      "mutated_line": "x = b[0:]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[0:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "x = b[1:]",
      "mutated_line": "x = b[-1:]",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[-1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) - 2)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 2)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 0)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) - 0)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 0)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans += 10 ** (len(b) - 1)",
      "mutated_line": "ans += 10 ** (len(b) - -1)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - -1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 2, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 2, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 0, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 0, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 0, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 0, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - -1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - -1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 2) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 2) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 0) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 0) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 0) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 0) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - -1) + (1 - L[far]) * dp(far - 1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - -1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 2, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 2, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 0, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 0, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 0, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 0, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)",
      "mutated_line": "ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - -1, need)",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - -1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-2] * (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-2] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-0] * (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-0] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([-0] * (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([-0] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "DP.append([-1] * (atLeast + 5))",
      "mutated_line": "DP.append([--1] * (atLeast + 5))",
      "code": "def calculate_benford_probability(n, intervals, k):\n\n    def num_ones(a, b):\n        if a == 0:\n            if b == 0:\n                return 0\n            ans = 0\n            b = str(b)\n            for i in range(1, len(b)):\n                ans += 10 ** (i - 1)\n            if b[0] == '1':\n                x = b[1:]\n                if x == '':\n                    x = 0\n                else:\n                    x = int(x)\n                ans += x + 1\n            else:\n                ans += 10 ** (len(b) - 1)\n            return ans\n        return num_ones(0, b) - num_ones(0, a - 1)\n\n    def dp(far, need):\n        if DP[far][need] != -1:\n            return DP[far][need]\n        if need > far + 1:\n            return 0\n        if need == 0:\n            return 1\n        if far == 0:\n            return L[0]\n        ans = L[far] * dp(far - 1, need - 1) + (1 - L[far]) * dp(far - 1, need)\n        DP[far][need] = ans\n        return ans\n    L = []\n    for (Li, Ri) in intervals:\n        L.append(num_ones(Li, Ri) / (Ri - Li + 1))\n    atLeast = int((n * k - 1) / 100) + 1\n    if k == 0:\n        atLeast = 0\n    DP = []\n    for i in range(n):\n        DP.append([--1] * (atLeast + 5))\n    return round(dp(n - 1, atLeast), 10)"
    }
  ]
}