{
  "task_id": "taco_16227",
  "entry_point": "check_subsequence_coverage",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "matched = -1",
      "mutated_line": "for (i, ch) in enumerate(s):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = +1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_match = [0 for _ in range(len(s))]",
      "mutated_line": "max_match = [1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [1 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_match = [0 for _ in range(len(s))]",
      "mutated_line": "max_match = [-1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [-1 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_match = [0 for _ in range(len(s))]",
      "mutated_line": "max_match = [1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [1 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_match = [0 for _ in range(len(s))]",
      "mutated_line": "min_match = [1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [1 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_match = [0 for _ in range(len(s))]",
      "mutated_line": "min_match = [-1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [-1 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_match = [0 for _ in range(len(s))]",
      "mutated_line": "min_match = [1 for _ in range(len(s))]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [1 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [1 for _ in range(30)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [1 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [-1 for _ in range(30)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [-1 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [1 for _ in range(30)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [1 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) + ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) + ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) * ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) * ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) + ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) + ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) * ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) * ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "matched = -1",
      "mutated_line": "for (i, ch) in enumerate(s):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -2\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "matched = -1",
      "mutated_line": "for (i, ch) in enumerate(s):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -0\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "matched = -1",
      "mutated_line": "for (i, ch) in enumerate(s):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -0\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "matched = -1",
      "mutated_line": "for (i, ch) in enumerate(s):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = --1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched != len(t) - 1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched != len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) - i + 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i + 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = (len(s) - i) * 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = (len(s) - i) * 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if matched == 0:",
      "mutated_line": "if matched != 0:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched != 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ch_idx = ord(ch) - ord('a')",
      "mutated_line": "ch_idx = ord(ch) + ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) + ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ch_idx = ord(ch) - ord('a')",
      "mutated_line": "ch_idx = ord(ch) * ord('a')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) * ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx < len(char_occur[ch_idx]) or char_occur[ch_idx][idx] < low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) or char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "idx += 1",
      "mutated_line": "idx -= 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx -= 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if idx == len(char_occur[ch_idx]):",
      "mutated_line": "if idx != len(char_occur[ch_idx]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx != len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if char_occur[ch_idx][idx] > high:",
      "mutated_line": "if char_occur[ch_idx][idx] >= high:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] >= high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if char_occur[ch_idx][idx] > high:",
      "mutated_line": "if char_occur[ch_idx][idx] <= high:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] <= high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if char_occur[ch_idx][idx] > high:",
      "mutated_line": "if char_occur[ch_idx][idx] != high:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] != high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) - 1)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) - 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) * 1)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) * 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) + 1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) + 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) * 1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) * 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch != t[matched + 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch != t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "matched += 1",
      "mutated_line": "matched -= 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched -= 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) + i - 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) + i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) * i - 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) * i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) - i - 2",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 2\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) - i - 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 0\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) - i - 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 0\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i = len(s) - i - 1",
      "mutated_line": "i = len(s) - i - -1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - -1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if matched == 0:",
      "mutated_line": "if matched == 1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 1:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if matched == 0:",
      "mutated_line": "if matched == -1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == -1:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if matched == 0:",
      "mutated_line": "if matched == 1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 1:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch != t[matched - 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch != t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "matched -= 1",
      "mutated_line": "matched += 1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched += 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx <= len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx <= len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx >= len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx >= len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx != len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx != len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] <= low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] <= low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] >= low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] >= low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:",
      "mutated_line": "while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] != low:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] != low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "idx += 1",
      "mutated_line": "idx += 2",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 2\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 0\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "idx += 1",
      "mutated_line": "idx += 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 0\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "idx += 1",
      "mutated_line": "idx += -1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += -1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return ''\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return ''\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [0 for _ in range(31)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(31)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [0 for _ in range(29)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(29)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [0 for _ in range(0)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(0)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [0 for _ in range(1)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(1)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "char_idx = [0 for _ in range(30)]",
      "mutated_line": "char_idx = [0 for _ in range(-30)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(-30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "char_occur = [[] for _ in range(30)]",
      "mutated_line": "char_occur = [[] for _ in range(31)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(31)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "char_occur = [[] for _ in range(30)]",
      "mutated_line": "char_occur = [[] for _ in range(29)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(29)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "char_occur = [[] for _ in range(30)]",
      "mutated_line": "char_occur = [[] for _ in range(0)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(0)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "char_occur = [[] for _ in range(30)]",
      "mutated_line": "char_occur = [[] for _ in range(1)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(1)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "char_occur = [[] for _ in range(30)]",
      "mutated_line": "char_occur = [[] for _ in range(-30)]",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(-30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) - ord('')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "idx = ord(ch) - ord('a')",
      "mutated_line": "idx = ord(ch) - ord('')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) + 2)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 2)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) + 0)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 0)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) + 0)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 0)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "char_occur[idx].append(len(t) + 1)",
      "mutated_line": "char_occur[idx].append(len(t) + -1)",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + -1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) - 2:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 2:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) - 0:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 0:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) - 0:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 0:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if matched == len(t) - 1:",
      "mutated_line": "if matched == len(t) - -1:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - -1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "matched += 1",
      "mutated_line": "matched += 2",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 2\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "matched += 1",
      "mutated_line": "matched += 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 0\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "matched += 1",
      "mutated_line": "matched += 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 0\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "matched += 1",
      "mutated_line": "matched += -1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += -1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for i, ch in enumerate(s[::-1]):",
      "mutated_line": "for (i, ch) in enumerate(s[::+1]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::+1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "matched -= 1",
      "mutated_line": "matched -= 2",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 2\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "matched -= 1",
      "mutated_line": "matched -= 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 0\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "matched -= 1",
      "mutated_line": "matched -= 0",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 0\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "matched -= 1",
      "mutated_line": "matched -= -1",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= -1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ch_idx = ord(ch) - ord('a')",
      "mutated_line": "ch_idx = ord(ch) - ord('')",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched - 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched * 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched * 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, ch in enumerate(s[::-1]):",
      "mutated_line": "for (i, ch) in enumerate(s[::-2]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-2]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, ch in enumerate(s[::-1]):",
      "mutated_line": "for (i, ch) in enumerate(s[::-0]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-0]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, ch in enumerate(s[::-1]):",
      "mutated_line": "for (i, ch) in enumerate(s[::-0]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-0]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i, ch in enumerate(s[::-1]):",
      "mutated_line": "for (i, ch) in enumerate(s[::--1]):",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::--1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched + 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched * 1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched * 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched + 2]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 2]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched + 0]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 0]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched + 0]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 0]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if ch == t[matched + 1]:",
      "mutated_line": "if ch == t[matched + -1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + -1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched - 2]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 2]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched - 0]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 0]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched - 0]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - 0]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ch == t[matched - 1]:",
      "mutated_line": "if ch == t[matched - -1]:",
      "code": "import bisect\nimport string\n\ndef check_subsequence_coverage(s: str, t: str) -> str:\n    max_match = [0 for _ in range(len(s))]\n    min_match = [0 for _ in range(len(s))]\n    char_idx = [0 for _ in range(30)]\n    char_occur = [[] for _ in range(30)]\n    for (i, ch) in enumerate(t):\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(i)\n    for ch in string.ascii_lowercase:\n        idx = ord(ch) - ord('a')\n        char_occur[idx].append(len(t) + 1)\n    matched = -1\n    for (i, ch) in enumerate(s):\n        if matched == len(t) - 1:\n            max_match[i] = matched\n        else:\n            if ch == t[matched + 1]:\n                matched += 1\n            max_match[i] = matched\n    matched = len(t)\n    for (i, ch) in enumerate(s[::-1]):\n        i = len(s) - i - 1\n        if matched == 0:\n            min_match[i] = matched\n        else:\n            if ch == t[matched - -1]:\n                matched -= 1\n            min_match[i] = matched\n    for (i, ch) in enumerate(s):\n        low = min_match[i]\n        high = max_match[i]\n        ch_idx = ord(ch) - ord('a')\n        idx = char_idx[ch_idx]\n        while idx < len(char_occur[ch_idx]) and char_occur[ch_idx][idx] < low:\n            idx += 1\n        char_idx[ch_idx] = idx\n        if idx == len(char_occur[ch_idx]):\n            return 'No'\n        if char_occur[ch_idx][idx] > high:\n            return 'No'\n    return 'Yes'"
    }
  ]
}