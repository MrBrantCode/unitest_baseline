{
  "task_id": "taco_15491",
  "entry_point": "calculate_minimum_distance",
  "mutant_count": 222,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(1, 2 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(1, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(-1, 2 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(-1, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(1, 2 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(1, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 / N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 / N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 + N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 + N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 ** N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 ** N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 * N, 3):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 3):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 * N, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 1):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 * N, 0):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 0):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 * N, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 1):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 2 * N, -2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, -2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(1, 2 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(1, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(-1, 2 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(-1, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(1, 2 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(1, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 / M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 / M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 + M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 + M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 ** M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 ** M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 * M, 3):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 3):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 * M, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 1):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 * M, 0):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 0):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 * M, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 1):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 2 * M, -2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, -2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(1, 2 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(1, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(-1, 2 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(-1, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(1, 2 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(1, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 / K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 / K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 + K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 + K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 ** K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 ** K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 * K, 3):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 3):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 * K, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 1):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 * K, 0):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 0):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 * K, 1):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 1):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 2 * K, -2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, -2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans1 = ans2 = float('inf')",
      "mutated_line": "ans1 = ans2 = float('')",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s -= distance(l11[i][1], l22[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s -= distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s -= distance(l22[i][1], l11[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s -= distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 3 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 3 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 1 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 1 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 0 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 0 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, 1 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 1 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(0, 2 * N, 2):",
      "mutated_line": "for i in range(0, -2 * N, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, -2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 3 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 3 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 1 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 1 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 0 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 0 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, 1 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 1 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(0, 2 * M, 2):",
      "mutated_line": "for i in range(0, -2 * M, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, -2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 3 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 3 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 1 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 1 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 0 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 0 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, 1 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 1 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(0, 2 * K, 2):",
      "mutated_line": "for i in range(0, -2 * K, 2):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, -2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(min(N, 35)):",
      "mutated_line": "for i in range(min(N, 36)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 36)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(min(N, 35)):",
      "mutated_line": "for i in range(min(N, 34)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 34)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(min(N, 35)):",
      "mutated_line": "for i in range(min(N, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 0)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(min(N, 35)):",
      "mutated_line": "for i in range(min(N, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 1)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(min(N, 35)):",
      "mutated_line": "for i in range(min(N, -35)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, -35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s -= distance(l22[j][1], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s -= distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(min(M, 70)):",
      "mutated_line": "for i in range(min(M, 71)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 71)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(min(M, 70)):",
      "mutated_line": "for i in range(min(M, 69)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 69)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(min(M, 70)):",
      "mutated_line": "for i in range(min(M, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 0)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(min(M, 70)):",
      "mutated_line": "for i in range(min(M, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 1)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(min(M, 70)):",
      "mutated_line": "for i in range(min(M, -70)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, -70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s -= distance(l11[j][1], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s -= distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][2], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][2], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][0], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][0], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][0], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][0], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][-1], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][-1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][2], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][2], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][0], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][0], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][0], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][0], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][-1], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][-1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = distance((x, y), l11[i][1])",
      "mutated_line": "s = distance((x, y), l11[i][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][2])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = distance((x, y), l11[i][1])",
      "mutated_line": "s = distance((x, y), l11[i][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][0])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = distance((x, y), l11[i][1])",
      "mutated_line": "s = distance((x, y), l11[i][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][0])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = distance((x, y), l11[i][1])",
      "mutated_line": "s = distance((x, y), l11[i][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][-1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min(M, 70)):",
      "mutated_line": "for j in range(min(M, 71)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 71)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min(M, 70)):",
      "mutated_line": "for j in range(min(M, 69)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 69)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min(M, 70)):",
      "mutated_line": "for j in range(min(M, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 0)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min(M, 70)):",
      "mutated_line": "for j in range(min(M, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 1)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min(M, 70)):",
      "mutated_line": "for j in range(min(M, -70)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, -70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if s < ans1:",
      "mutated_line": "if s <= ans1:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s <= ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if s < ans1:",
      "mutated_line": "if s >= ans1:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s >= ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if s < ans1:",
      "mutated_line": "if s != ans1:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s != ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = distance((x, y), l22[i][1])",
      "mutated_line": "s = distance((x, y), l22[i][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][2])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = distance((x, y), l22[i][1])",
      "mutated_line": "s = distance((x, y), l22[i][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][0])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = distance((x, y), l22[i][1])",
      "mutated_line": "s = distance((x, y), l22[i][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][0])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s = distance((x, y), l22[i][1])",
      "mutated_line": "s = distance((x, y), l22[i][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][-1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for j in range(min(N, 35)):",
      "mutated_line": "for j in range(min(N, 36)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 36)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for j in range(min(N, 35)):",
      "mutated_line": "for j in range(min(N, 34)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 34)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for j in range(min(N, 35)):",
      "mutated_line": "for j in range(min(N, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 0)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for j in range(min(N, 35)):",
      "mutated_line": "for j in range(min(N, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 1)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for j in range(min(N, 35)):",
      "mutated_line": "for j in range(min(N, -35)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, -35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if s < ans2:",
      "mutated_line": "if s <= ans2:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s <= ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if s < ans2:",
      "mutated_line": "if s >= ans2:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s >= ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if s < ans2:",
      "mutated_line": "if s != ans2:",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s != ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i - 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i - 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i * 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i * 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l11.sort(key=lambda x: x[0])",
      "mutated_line": "l11.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[1])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l11.sort(key=lambda x: x[0])",
      "mutated_line": "l11.sort(key=lambda x: x[-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[-1])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "l11.sort(key=lambda x: x[0])",
      "mutated_line": "l11.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[1])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[1][1], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[1][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[-1][1], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[-1][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[1][1], (l2[i], l2[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[1][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i - 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i - 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i * 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i * 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l22.sort(key=lambda x: x[0])",
      "mutated_line": "l22.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[1])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l22.sort(key=lambda x: x[0])",
      "mutated_line": "l22.sort(key=lambda x: x[-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[-1])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l22.sort(key=lambda x: x[0])",
      "mutated_line": "l22.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[1])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[1][1], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[1][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[-1][1], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[-1][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[1][1], (l3[i], l3[i + 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[1][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i - 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i - 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i * 1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i * 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l33.sort(key=lambda x: x[0])",
      "mutated_line": "l33.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[1])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l33.sort(key=lambda x: x[0])",
      "mutated_line": "l33.sort(key=lambda x: x[-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[-1])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "l33.sort(key=lambda x: x[0])",
      "mutated_line": "l33.sort(key=lambda x: x[1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[1])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][2], l22[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][2], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][0], l22[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][0], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][0], l22[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][0], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][-1], l22[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][-1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][1], l22[j][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][2])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][1], l22[j][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][0])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][1], l22[j][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][0])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += distance(l11[i][1], l22[j][1])",
      "mutated_line": "s += distance(l11[i][1], l22[j][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][-1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 51)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 51)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 49)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 49)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 0)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 1)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, -50)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, -50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][2], l11[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][2], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][0], l11[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][0], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][0], l11[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][0], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][-1], l11[j][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][-1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][1], l11[j][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][2])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][1], l11[j][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][0])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][1], l11[j][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][0])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "s += distance(l22[i][1], l11[j][1])",
      "mutated_line": "s += distance(l22[i][1], l11[j][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][-1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 51)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 51)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 49)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 49)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 0)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 0)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, 1)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 1)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for q in range(min(K, 50)):",
      "mutated_line": "for q in range(min(K, -50)):",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, -50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i + 2]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 2]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 0]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 0]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "s = distance((x, y), (l1[i], l1[i + 1]))",
      "mutated_line": "s = distance((x, y), (l1[i], l1[i + -1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + -1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i - 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i - 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i * 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i * 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i + 2]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 2]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 0]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 0]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = distance(l11[0][1], (l2[i], l2[i + 1]))",
      "mutated_line": "s = distance(l11[0][1], (l2[i], l2[i + -1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + -1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i - 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i - 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i * 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i * 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i + 2]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 2]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 0]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i + 0]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 0]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = distance(l22[0][1], (l3[i], l3[i + 1]))",
      "mutated_line": "s = distance(l22[0][1], (l3[i], l3[i + -1]))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + -1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i - 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i - 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i * 1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i * 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][2], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][2], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][0], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][0], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][0], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][0], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][-1], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][-1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][1], l33[q][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][2])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][1], l33[q][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][0])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][1], l33[q][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][0])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s += distance(l22[j][1], l33[q][1])",
      "mutated_line": "s += distance(l22[j][1], l33[q][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][-1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][2], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][2], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][0], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][0], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][0], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][0], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][-1], l33[q][1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][-1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][1], l33[q][2])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][2])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][1], l33[q][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][0])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][1], l33[q][0])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][0])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "s += distance(l11[j][1], l33[q][1])",
      "mutated_line": "s += distance(l11[j][1], l33[q][-1])",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][-1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i + 2])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 2])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 0])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 0])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l11.append((s, (l1[i], l1[i + 1])))",
      "mutated_line": "l11.append((s, (l1[i], l1[i + -1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + -1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i + 2])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 2])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 0])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 0])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l22.append((s, (l2[i], l2[i + 1])))",
      "mutated_line": "l22.append((s, (l2[i], l2[i + -1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + -1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i + 2])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 2])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 0])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i + 0])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + 0])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l33.append((s, (l3[i], l3[i + 1])))",
      "mutated_line": "l33.append((s, (l3[i], l3[i + -1])))",
      "code": "import math\n\ndef calculate_minimum_distance(x, y, N, M, K, l1, l2, l3):\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    l11 = []\n    l22 = []\n    l33 = []\n    for i in range(0, 2 * N, 2):\n        s = distance((x, y), (l1[i], l1[i + 1]))\n        l11.append((s, (l1[i], l1[i + 1])))\n    l11.sort(key=lambda x: x[0])\n    for i in range(0, 2 * M, 2):\n        s = distance(l11[0][1], (l2[i], l2[i + 1]))\n        l22.append((s, (l2[i], l2[i + 1])))\n    l22.sort(key=lambda x: x[0])\n    for i in range(0, 2 * K, 2):\n        s = distance(l22[0][1], (l3[i], l3[i + 1]))\n        l33.append((s, (l3[i], l3[i + -1])))\n    l33.sort(key=lambda x: x[0])\n    ans1 = ans2 = float('inf')\n    for i in range(min(N, 35)):\n        s = distance((x, y), l11[i][1])\n        for j in range(min(M, 70)):\n            s1 = s\n            s += distance(l11[i][1], l22[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l22[j][1], l33[q][1])\n                if s < ans1:\n                    ans1 = s\n                s = s2\n            s = s1\n    for i in range(min(M, 70)):\n        s = distance((x, y), l22[i][1])\n        for j in range(min(N, 35)):\n            s1 = s\n            s += distance(l22[i][1], l11[j][1])\n            for q in range(min(K, 50)):\n                s2 = s\n                s += distance(l11[j][1], l33[q][1])\n                if s < ans2:\n                    ans2 = s\n                s = s2\n            s = s1\n    return min(ans1, ans2)"
    }
  ]
}