{
  "task_id": "taco_2602",
  "entry_point": "minimal_jumps_to_end",
  "mutant_count": 154,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 and L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 and L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 1] = 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 1\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 1] = -1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = -1\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 1] = 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 1\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) >= 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) >= 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) <= 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) <= 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) != 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) != 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L != 1 or L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L != 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L != 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L != 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L + 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L + 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L * 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L * 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "minJump = [2000000 for _ in range(L)]",
      "mutated_line": "minJump = [2000001 for _ in range(L)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000001 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "minJump = [2000000 for _ in range(L)]",
      "mutated_line": "minJump = [1999999 for _ in range(L)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [1999999 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "minJump = [2000000 for _ in range(L)]",
      "mutated_line": "minJump = [0 for _ in range(L)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [0 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "minJump = [2000000 for _ in range(L)]",
      "mutated_line": "minJump = [1 for _ in range(L)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [1 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "minJump = [2000000 for _ in range(L)]",
      "mutated_line": "minJump = [-2000000 for _ in range(L)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [-2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L + 1] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L + 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L * 1] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L * 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000001 for _ in range(10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000001 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [1999999 for _ in range(10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [1999999 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [0 for _ in range(10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [0 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [1 for _ in range(10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [1 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [-2000000 for _ in range(10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [-2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) > 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 1:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) > -1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > -1:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while len(h) > 0:",
      "mutated_line": "while len(h) > 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 1:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ - 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ - 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ * 1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ * 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if maxJumpForNum[num] > setJump:",
      "mutated_line": "if maxJumpForNum[num] >= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] >= setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if maxJumpForNum[num] > setJump:",
      "mutated_line": "if maxJumpForNum[num] <= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] <= setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if maxJumpForNum[num] > setJump:",
      "mutated_line": "if maxJumpForNum[num] != setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] != setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx >= 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx >= 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx <= 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx <= 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx != 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx != 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx <= L - 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx <= L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx >= L - 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx >= L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx != L - 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx != L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return minJump[0]",
      "mutated_line": "return minJump[1]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return minJump[0]",
      "mutated_line": "return minJump[-1]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return minJump[0]",
      "mutated_line": "return minJump[1]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 2 or L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 2 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 0 or L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 0 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 0 or L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 0 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == -1 or L == 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == -1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L == 3:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 3:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L == 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 1:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L == 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 0:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L == 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 1:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if L == 1 or L == 2:",
      "mutated_line": "if L == 1 or L == -2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == -2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L - 2",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 2\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L - 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 0\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L - 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 0\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return L - 1",
      "mutated_line": "return L - -1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - -1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 2] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 2] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 0] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 0] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - 0] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 0] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minJump[L - 1] = 0",
      "mutated_line": "minJump[L - -1] = 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - -1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (1, int(sequence[L - 1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (1, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (-1, int(sequence[L - 1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (-1, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (1, int(sequence[L - 1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (1, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L + 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L * 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L * 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ + 2",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 2\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ + 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 0\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ + 0",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 0\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "setJump = minJ + 1",
      "mutated_line": "setJump = minJ + -1",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + -1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx > 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 1:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx > -1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > -1:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if idx > 0:",
      "mutated_line": "if idx > 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 1:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 1] >= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] >= setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 1] <= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] <= setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 1] != setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] != setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L + 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L + 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L * 2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L * 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 1] >= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] >= setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 1] <= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] <= setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 1] != setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] != setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "numPos = [[] for _ in range(10)]",
      "mutated_line": "numPos = [[] for _ in range(11)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(11)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "numPos = [[] for _ in range(10)]",
      "mutated_line": "numPos = [[] for _ in range(9)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(9)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "numPos = [[] for _ in range(10)]",
      "mutated_line": "numPos = [[] for _ in range(0)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(0)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "numPos = [[] for _ in range(10)]",
      "mutated_line": "numPos = [[] for _ in range(1)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(1)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "numPos = [[] for _ in range(10)]",
      "mutated_line": "numPos = [[] for _ in range(-10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(-10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000000 for _ in range(11)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(11)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000000 for _ in range(9)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(9)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000000 for _ in range(0)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(0)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000000 for _ in range(1)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(1)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "maxJumpForNum = [2000000 for _ in range(10)]",
      "mutated_line": "maxJumpForNum = [2000000 for _ in range(-10)]",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(-10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 2))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 2))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 0))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 0))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - -1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - -1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i == idx:",
      "mutated_line": "if i != idx:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i != idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if minJump[i] > setJump:",
      "mutated_line": "if minJump[i] >= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] >= setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if minJump[i] > setJump:",
      "mutated_line": "if minJump[i] <= setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] <= setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if minJump[i] > setJump:",
      "mutated_line": "if minJump[i] != setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] != setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L - 3:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 3:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L - 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 1:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L - 0:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 0:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L - 1:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 1:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if idx < L - 2:",
      "mutated_line": "if idx < L - -2:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - -2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L + 1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L + 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L * 1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L * 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx + 1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx + 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx * 1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx * 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx + 1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx * 1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx * 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx - 1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx - 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx * 1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx * 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx - 1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx * 1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx * 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 2]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 2]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 0]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 0]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - 0]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 0]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))",
      "mutated_line": "heapq.heappush(h, (0, int(sequence[L - -1]), L - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - -1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 2] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 2] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 0] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 0] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - 0] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 0] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if minJump[idx - 1] > setJump:",
      "mutated_line": "if minJump[idx - -1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - -1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx - 2] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 2] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx - 0] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 0] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx - 0] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 0] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minJump[idx - 1] = setJump",
      "mutated_line": "minJump[idx - -1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - -1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx + 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx * 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx * 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 2] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 2] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 0] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 0] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + 0] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 0] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if minJump[idx + 1] > setJump:",
      "mutated_line": "if minJump[idx + -1] > setJump:",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + -1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx + 2] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 2] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx + 0] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 0] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx + 0] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 0] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "minJump[idx + 1] = setJump",
      "mutated_line": "minJump[idx + -1] = setJump",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + -1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx - 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx * 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx * 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 2))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 2))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 0))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 0))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - -1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - -1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 2))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 2))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 0))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 0))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 0))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + -1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + -1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx * 1]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx * 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx * 1]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx * 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 2]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 2]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 0]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 0]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - 0]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 0]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx - -1]), idx - 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - -1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 2]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 2]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 0]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 0]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + 0]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + 0]), idx + 1))\n    return minJump[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "heapq.heappush(h, (setJump, int(sequence[idx + 1]), idx + 1))",
      "mutated_line": "heapq.heappush(h, (setJump, int(sequence[idx + -1]), idx + 1))",
      "code": "import heapq\n\ndef minimal_jumps_to_end(sequence):\n    L = len(sequence)\n    if L == 1 or L == 2:\n        return L - 1\n    numPos = [[] for _ in range(10)]\n    minJump = [2000000 for _ in range(L)]\n    minJump[L - 1] = 0\n    maxJumpForNum = [2000000 for _ in range(10)]\n    for i in range(L):\n        numPos[int(sequence[i])].append(i)\n    h = []\n    heapq.heappush(h, (0, int(sequence[L - 1]), L - 1))\n    while len(h) > 0:\n        (minJ, num, idx) = heapq.heappop(h)\n        setJump = minJ + 1\n        if maxJumpForNum[num] > setJump:\n            maxJumpForNum[num] = setJump\n            for i in numPos[num]:\n                if i == idx:\n                    continue\n                if minJump[i] > setJump:\n                    minJump[i] = setJump\n                    heapq.heappush(h, (setJump, num, i))\n        if idx > 0:\n            if minJump[idx - 1] > setJump:\n                minJump[idx - 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx - 1]), idx - 1))\n        if idx < L - 2:\n            if minJump[idx + 1] > setJump:\n                minJump[idx + 1] = setJump\n                heapq.heappush(h, (setJump, int(sequence[idx + -1]), idx + 1))\n    return minJump[0]"
    }
  ]
}