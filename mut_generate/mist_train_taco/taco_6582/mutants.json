{
  "task_id": "taco_6582",
  "entry_point": "is_prime",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num <= 2:",
      "code": "def is_prime(num):\n    if num <= 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num >= 2:",
      "code": "def is_prime(num):\n    if num >= 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num != 2:",
      "code": "def is_prime(num):\n    if num != 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 2",
      "mutated_line": "i = 3",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 2",
      "mutated_line": "i = 1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 1\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 2",
      "mutated_line": "i = 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 0\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 2",
      "mutated_line": "i = 1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 1\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 2",
      "mutated_line": "i = -2",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = -2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i * i < num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i < num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i * i > num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i > num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i * i == num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i == num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i -= 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return False\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "four_digit_primes[Num1] = 1",
      "mutated_line": "four_digit_primes[Num1] = 2",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 2\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "four_digit_primes[Num1] = 1",
      "mutated_line": "four_digit_primes[Num1] = 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 0\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "four_digit_primes[Num1] = 1",
      "mutated_line": "four_digit_primes[Num1] = 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 0\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "four_digit_primes[Num1] = 1",
      "mutated_line": "four_digit_primes[Num1] = -1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = -1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num < 3:",
      "code": "def is_prime(num):\n    if num < 3:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num < 1:",
      "code": "def is_prime(num):\n    if num < 1:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num < 0:",
      "code": "def is_prime(num):\n    if num < 0:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num < 1:",
      "code": "def is_prime(num):\n    if num < 1:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if num < 2:",
      "mutated_line": "if num < -2:",
      "code": "def is_prime(num):\n    if num < -2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_prime(num):\n    if num < 2:\n        return True\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i / i <= num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i / i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i + i <= num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i + i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "while i * i <= num:",
      "mutated_line": "while i ** i <= num:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i ** i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i != 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i != 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 0\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 0\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += -1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 1 for num in range(1000, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 1 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: -1 for num in range(1000, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: -1 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 1 for num in range(1000, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 1 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if int(num) == Num2:",
      "mutated_line": "if int(num) != Num2:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) != Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num * i == 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num * i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num + i == 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num + i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 1:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == -1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == -1:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if num % i == 0:",
      "mutated_line": "if num % i == 1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 1:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return True\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append([Num1, 0])",
      "mutated_line": "queue.append([Num1, 1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 1])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append([Num1, 0])",
      "mutated_line": "queue.append([Num1, -1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, -1])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append([Num1, 0])",
      "mutated_line": "queue.append([Num1, 1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 1])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for place in range(4):",
      "mutated_line": "for place in range(5):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(5):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for place in range(4):",
      "mutated_line": "for place in range(3):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(3):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for place in range(4):",
      "mutated_line": "for place in range(0):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(0):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for place in range(4):",
      "mutated_line": "for place in range(1):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(1):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for place in range(4):",
      "mutated_line": "for place in range(-4):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(-4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) - num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) - num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = (num[:place] + str(temp)) * num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = (num[:place] + str(temp)) * num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1001, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1001, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(999, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(999, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(0, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(0, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(-1000, 10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(-1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1000, 10001) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10001) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1000, 9999) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 9999) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1000, 0) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 0) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1000, 1) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 1) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}",
      "mutated_line": "four_digit_primes = {num: 0 for num in range(1000, -10000) if is_prime(num)}",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, -10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[0]), top[2])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[2])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[0]), top[0])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[0])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[0]), top[0])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[0])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[0]), top[-1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[-1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for digit in range(10):",
      "mutated_line": "for digit in range(11):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(11):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for digit in range(10):",
      "mutated_line": "for digit in range(9):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(9):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for digit in range(10):",
      "mutated_line": "for digit in range(0):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(0):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for digit in range(10):",
      "mutated_line": "for digit in range(1):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(1):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for digit in range(10):",
      "mutated_line": "for digit in range(-10):",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(-10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) - num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) - num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = (num[:place] + str(digit)) * num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = (num[:place] + str(digit)) * num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) in four_digit_primes or four_digit_primes[int(num)] == 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes or four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] - str(temp) + num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] - str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] * str(temp) + num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] * str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[1]), top[1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[1]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[-1]), top[1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[-1]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "num, step = str(top[0]), top[1]",
      "mutated_line": "(num, step) = (str(top[1]), top[1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[1]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] - str(digit) + num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] - str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] * str(digit) + num[place + 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] * str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) not in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) not in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] != 0:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] != 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "four_digit_primes[int(num)] = 1",
      "mutated_line": "four_digit_primes[int(num)] = 2",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 2\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "four_digit_primes[int(num)] = 1",
      "mutated_line": "four_digit_primes[int(num)] = 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 0\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "four_digit_primes[int(num)] = 1",
      "mutated_line": "four_digit_primes[int(num)] = 0",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 0\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "four_digit_primes[int(num)] = 1",
      "mutated_line": "four_digit_primes[int(num)] = -1",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = -1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 1:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == -1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == -1:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:",
      "mutated_line": "if int(num) in four_digit_primes and four_digit_primes[int(num)] == 1:",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 1:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place - 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place - 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place * 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place * 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place - 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place - 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place * 1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place * 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step - 1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step - 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step * 1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step * 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place + 2:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 2:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place + 0:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 0:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place + 0:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 0:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "num = num[:place] + str(temp) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(temp) + num[place + -1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + -1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place + 2:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 2:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place + 0:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 0:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place + 0:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 0:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "num = num[:place] + str(digit) + num[place + 1:]",
      "mutated_line": "num = num[:place] + str(digit) + num[place + -1:]",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + -1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step + 2])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 2])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step + 0])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 0])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step + 0])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + 0])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "queue.append([int(num), step + 1])",
      "mutated_line": "queue.append([int(num), step + -1])",
      "code": "def is_prime(num):\n    if num < 2:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\ndef shortest_path_between_primes(Num1, Num2):\n    four_digit_primes = {num: 0 for num in range(1000, 10000) if is_prime(num)}\n    from collections import deque\n    queue = deque()\n    queue.append([Num1, 0])\n    four_digit_primes[Num1] = 1\n    while queue:\n        top = queue.popleft()\n        (num, step) = (str(top[0]), top[1])\n        if int(num) == Num2:\n            return step\n        for place in range(4):\n            temp = num[place]\n            for digit in range(10):\n                num = num[:place] + str(digit) + num[place + 1:]\n                if int(num) in four_digit_primes and four_digit_primes[int(num)] == 0:\n                    four_digit_primes[int(num)] = 1\n                    queue.append([int(num), step + -1])\n            num = num[:place] + str(temp) + num[place + 1:]\n    return -1"
    }
  ]
}