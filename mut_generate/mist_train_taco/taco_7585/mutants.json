{
  "task_id": "taco_7585",
  "entry_point": "determine_mosaic_status",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] / (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] / (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] + n * n",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] + n * n\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] ** (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] ** (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "finished = 1",
      "mutated_line": "finished = 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 2\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "finished = 1",
      "mutated_line": "finished = 0",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 0\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "finished = 1",
      "mutated_line": "finished = 0",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 0\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "finished = 1",
      "mutated_line": "finished = -1",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = -1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n * 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n + 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] / (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] + n // 2\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] ** (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "o = {'G': 'S', 'S': 'G'}",
      "mutated_line": "o = {'': 'S', 'S': 'G'}",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "o = {'G': 'S', 'S': 'G'}",
      "mutated_line": "o = {'G': 'S', '': 'G'}",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', '': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "o = {'G': 'S', 'S': 'G'}",
      "mutated_line": "o = {'G': '', 'S': 'G'}",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': '', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "o = {'G': 'S', 'S': 'G'}",
      "mutated_line": "o = {'G': 'S', 'S': ''}",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': ''}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] * (n / n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n / n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] * (n + n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n + n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [1] * n ** n",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * n ** n\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 3:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 1:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 0:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 1:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n % 2:",
      "mutated_line": "return ('NONE', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % -2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n / 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n * 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) * 2:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) * 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if j - i + 2:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if j - i + 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n / 2):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n / 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n * 2):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n * 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return \"UNIQUE\", completed_grid",
      "mutated_line": "return ('', completed_grid)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [2] * (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [2] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [0] * (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [0] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [0] * (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [0] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "f = [1] * (n * n)",
      "mutated_line": "f = [-1] * (n * n)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [-1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return \"NONE\", None",
      "mutated_line": "return ('', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = ['MUTATED'] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 3)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 1)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 0)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 1)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x = [''] * (n // 2)",
      "mutated_line": "",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // -2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) * 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) * 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if j - i + 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if j - i + 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) / 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) / 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) * 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) * 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) / 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) / 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) * 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) * 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j + i) % 2:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j + i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if j * i % 2:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if j * i % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) % 3:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 3:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) % 1:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 1:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) % 0:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 0:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) % 1:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 1:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (j - i) % 2:",
      "mutated_line": "if (j - i) % -2:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % -2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif i + j < n:",
      "mutated_line": "elif i + j <= n:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j <= n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif i + j < n:",
      "mutated_line": "elif i + j >= n:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j >= n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif i + j < n:",
      "mutated_line": "elif i + j != n:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j != n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d[i][j] != '.':",
      "mutated_line": "if d[i][j] == '.':",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] == '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 3):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 3):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 1):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 0):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 0):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // 1):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 1):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n // 2):",
      "mutated_line": "for i in range(n // -2):",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // -2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j + i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j + i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if j * i % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if j * i % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 3 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 3 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 1 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 1 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 0 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 0 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 1 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 1 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % -2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % -2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 3 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 3 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 1 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 1 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 0 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 0 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 1 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 1 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // -2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // -2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 3",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 3\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 1",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 1\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 0",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 0\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 1",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 1\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // -2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // -2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) * 2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) * 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) + 2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) + 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif i + j < n:",
      "mutated_line": "elif i - j < n:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i - j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif i + j < n:",
      "mutated_line": "elif i * j < n:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i * j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if d[i][j] != '.':",
      "mutated_line": "if d[i][j] != '':",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if x[t] == o[r]:",
      "mutated_line": "if x[t] != o[r]:",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] != o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return \"MULTIPLE\", None",
      "mutated_line": "return ('', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "completed_grid = [''.join(row) for row in d]",
      "mutated_line": "return ('UNIQUE', completed_grid)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = ['MUTATED'.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j + i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j + i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j * i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j * i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i - j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i - j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i * j, 2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i * j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j + i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j + i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, (2 * (n - 1) - j) * i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, (2 * (n - 1) - j) * i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) % 3 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 3 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) % 1 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 1 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) % 0 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 0 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) % 1 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 1 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return o[t] if min(i, j) % 2 else t",
      "mutated_line": "return o[t] if min(i, j) % -2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % -2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i * 2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i * 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i + 2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i + 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i * 2 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i * 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i + 2 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i + 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) + j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) + j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) * j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) * j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i % 3 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 3 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i % 1 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 1 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i % 0 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 0 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i % 1 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 1 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return o[t] if i % 2 else t",
      "mutated_line": "return o[t] if i % -2 else t",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % -2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i % 3 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 3 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i % 1 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 1 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i % 0 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 0 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i % 1 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 1 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return t if i % 2 else o[t]",
      "mutated_line": "return t if i % -2 else o[t]",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % -2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return \"NONE\", None",
      "mutated_line": "return ('', None)",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 / (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 / (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 + (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 + (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 ** (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 ** (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 3 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 3 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 1 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 1 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 0 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 0 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 1 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 1 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, -2 * (n - 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, -2 * (n - 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n + 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n + 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n * 1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n * 1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 2) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 2) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 0) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 0) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 0) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 0) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - 1) - j - i) // 2",
      "mutated_line": "return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - -1) - j - i) // 2",
      "code": "def determine_mosaic_status(n, grid):\n    o = {'G': 'S', 'S': 'G'}\n    d = [list(row) for row in grid]\n    f = [1] * (n * n)\n    finished = 1\n    if n % 2:\n        return ('NONE', None)\n    x = [''] * (n // 2)\n\n    def findt(i, j):\n        return abs(j - i) // 2 if (j - i) % 2 else min(i + j, 2 * (n - -1) - j - i) // 2\n\n    def findr(i, j, t):\n        if (j - i) % 2:\n            return o[t] if min(i, j) % 2 else t\n        elif i + j < n:\n            return o[t] if i % 2 else t\n        else:\n            return t if i % 2 else o[t]\n    for i in range(n):\n        for j in range(n):\n            if d[i][j] != '.':\n                t = findt(i, j)\n                r = findr(i, j, d[i][j])\n                if x[t] == o[r]:\n                    return ('NONE', None)\n                else:\n                    x[t] = r\n    for i in range(n // 2):\n        if not x[i]:\n            return ('MULTIPLE', None)\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = findr(i, j, x[findt(i, j)])\n    completed_grid = [''.join(row) for row in d]\n    return ('UNIQUE', completed_grid)"
    }
  ]
}