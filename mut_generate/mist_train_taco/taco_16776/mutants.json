{
  "task_id": "taco_16776",
  "entry_point": "find_minimum_jumps",
  "mutant_count": 249,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 20",
      "mutated_line": "N = 21",
      "code": "def find_minimum_jumps(board):\n    N = 21\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 20",
      "mutated_line": "N = 19",
      "code": "def find_minimum_jumps(board):\n    N = 19\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 20",
      "mutated_line": "N = 0",
      "code": "def find_minimum_jumps(board):\n    N = 0\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 20",
      "mutated_line": "N = 1",
      "code": "def find_minimum_jumps(board):\n    N = 1\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 20",
      "mutated_line": "N = -20",
      "code": "def find_minimum_jumps(board):\n    N = -20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 15",
      "mutated_line": "M = 16",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 16\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 15",
      "mutated_line": "M = 14",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 14\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 15",
      "mutated_line": "M = 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 0\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 15",
      "mutated_line": "M = 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 1\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 15",
      "mutated_line": "M = -15",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = -15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "L = 0",
      "mutated_line": "L = 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 1\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "L = 0",
      "mutated_line": "L = -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = -1\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "L = 0",
      "mutated_line": "L = 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 1\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INF = 30",
      "mutated_line": "INF = 31",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 31\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INF = 30",
      "mutated_line": "INF = 29",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 29\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INF = 30",
      "mutated_line": "INF = 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 0\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INF = 30",
      "mutated_line": "INF = 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 1\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "INF = 30",
      "mutated_line": "INF = -30",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = -30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-1] / M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] / M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-1] + M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] + M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-1] ** M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] ** M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (1, 0)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (1, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (-1, 0)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (-1, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (1, 0)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (1, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (0, 1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 1)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (0, -1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, -1)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = 0, 0",
      "mutated_line": "(sx, sy) = (0, 1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 1)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N + 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N * 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if key in D:",
      "mutated_line": "if key not in D:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key not in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y > N - 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y > N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y < N - 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y < N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y == N - 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y == N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "nx += dx",
      "mutated_line": "nx -= dx",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx -= dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "ny += dy",
      "mutated_line": "ny -= dy",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny -= dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L + 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L + 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L * 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L * 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r <= INF else -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r <= INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r >= INF else -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r >= INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r != INF else -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r != INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r < INF else +1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else +1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 2):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 0):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 0):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - -1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if c == 'O':",
      "mutated_line": "if c != 'O':",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c != 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((+1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((+1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, -1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, -1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 1), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (+1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (+1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, +1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, +1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (-1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (-1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (1, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, +1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, +1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (2, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (2, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (0, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (0, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (0, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (0, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (-1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (-1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, +1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, +1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (2, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (2, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (0, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (0, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (0, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (0, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 1), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 1), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, -1), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, -1), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 1), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 1), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (2, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (2, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (0, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (-1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (-1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 2), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 2), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 0), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 0), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 0), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 0), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, -1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, -1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (1, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (1, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (-1, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (-1, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (1, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (1, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 2), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 2), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 0), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 0), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 0), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 0), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, -1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, -1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (+1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (+1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 2))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 2))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 0))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, -1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, -1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N + 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N + 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N * 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N * 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 1\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return -1\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 1\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx = x + dx",
      "mutated_line": "nx = x - dx",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x - dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "nx = x + dx",
      "mutated_line": "nx = x * dx",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x * dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ny = y + dy",
      "mutated_line": "ny = y - dy",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y - dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ny = y + dy",
      "mutated_line": "ny = y * dy",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y * dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M and (not 0 <= ny < N):",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M and (not 0 <= ny < N):\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 and state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 and state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "n_state = state ^ 1 << k",
      "mutated_line": "n_state = state | 1 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state | 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M or 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M or 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "nx += dx",
      "mutated_line": "nx -= dx",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx -= dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ny += dy",
      "mutated_line": "ny -= dy",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny -= dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 * L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 * L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 + L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 + L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L - 2, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 2, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L - 0, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 0, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L - 0, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 0, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(2 ** L - -1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - -1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r < INF else -2",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -2"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r < INF else -0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r < INF else -0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return r if r < INF else -1",
      "mutated_line": "return r if r < INF else --1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else --1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[+1] * M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[+1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if c == 'O':",
      "mutated_line": "if c == '':",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == '':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif c == 'X':",
      "mutated_line": "elif c != 'X':",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c != 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "L += 1",
      "mutated_line": "L -= 1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L -= 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-2, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-2, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-0, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-0, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-0, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-0, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((--1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((--1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-2, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-2, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-0, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-0, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-0, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-0, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (--1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (--1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -2), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -2), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -0), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -0), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -0), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -0), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, --1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, --1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -2), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -2), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -0), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -0), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -0), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -0), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, --1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, --1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -2), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -2), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -0), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -0), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -0), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -0), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, --1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, --1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-2, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-2, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-0, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-0, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-0, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-0, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (--1, 1))",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (--1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N - 3:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 3:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 1:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N - 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 0:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 1:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if y >= N - 2:",
      "mutated_line": "if y >= N - -2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - -2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k != -1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k != -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k != 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k != 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 < nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 < nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 > nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 > nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 == nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 == nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and 0 < ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 < ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and 0 > ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 > ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and 0 == ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 == ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 and state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 and state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) or ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) or ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) - 1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) - 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) * 1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) * 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(3 ** L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(3 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(1 ** L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(1 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(0 ** L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(0 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(1 ** L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(1 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "r = dfs(2 ** L - 1, sx, sy)",
      "mutated_line": "r = dfs(-2 ** L - 1, sx, sy)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(-2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-2] * M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-2] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-0] * M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-0] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[-0] * M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-0] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MP = [[-1] * M for _ in range(N)]",
      "mutated_line": "MP = [[--1] * M for _ in range(N)]",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[--1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif c == 'X':",
      "mutated_line": "elif c == '':",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == '':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "L += 1",
      "mutated_line": "L += 2",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 2\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "L += 1",
      "mutated_line": "L += 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 0\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "L += 1",
      "mutated_line": "L += 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 0\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "L += 1",
      "mutated_line": "L += -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += -1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 < nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 < nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 > nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 > nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 == nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 == nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not 0 < ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 < ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not 0 > ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 > ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not 0 == ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 == ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == +1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == +1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state | 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state | 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 1:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == -1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == -1:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 1:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_state = state ^ 1 << k",
      "mutated_line": "n_state = state ^ 2 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 2 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_state = state ^ 1 << k",
      "mutated_line": "n_state = state ^ 0 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 0 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_state = state ^ 1 << k",
      "mutated_line": "n_state = state ^ 0 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 0 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_state = state ^ 1 << k",
      "mutated_line": "n_state = state ^ -1 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ -1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 1 <= nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 1 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while -1 <= nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while -1 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 1 <= nx < M and 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 1 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and 1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 1 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and -1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and -1 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while 0 <= nx < M and 0 <= ny < N:",
      "mutated_line": "while 0 <= nx < M and 1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 1 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k != -1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k != -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k != 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k != 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "n_state ^= 1 << k",
      "mutated_line": "n_state ^= 2 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 2 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "n_state ^= 1 << k",
      "mutated_line": "n_state ^= 0 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 0 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "n_state ^= 1 << k",
      "mutated_line": "n_state ^= 0 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 0 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "n_state ^= 1 << k",
      "mutated_line": "n_state ^= -1 << k",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= -1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 and nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 and nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny != N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny != N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 2\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 0\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 0\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return -1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) + 2)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 2)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) + 0)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 0)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) + 0)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 0)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "r = min(r, dfs(n_state, nx, ny) + 1)",
      "mutated_line": "r = min(r, dfs(n_state, nx, ny) + -1)",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + -1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 1 <= nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 1 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not -1 <= nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not -1 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 1 <= nx < M or not 0 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 1 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not 1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 1 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not -1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not -1 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if not 0 <= nx < M or not 0 <= ny < N:",
      "mutated_line": "if not 0 <= nx < M or not 1 <= ny < N:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 1 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -2 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -2 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -0 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -0 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -0 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -0 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == --1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == --1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == +1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == +1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state | 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state | 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 1:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == -1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == -1:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 1 << k == 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 1:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx != -1 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx != -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx != M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx != M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N + 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N + 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N * 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N * 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 2 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 2 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 0 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 0 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 0 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 0 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & -1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & -1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -2 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -2 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -0 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -0 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -0 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -0 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == --1 or state & 1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == --1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == +1 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == +1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N - 2:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 2:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N - 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 0:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N - 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 0:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -1 or nx == M) and ny == N - -1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - -1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 2 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 2 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 0 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 0 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & 0 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 0 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if k == -1 or state & 1 << k == 0:",
      "mutated_line": "if k == -1 or state & -1 << k == 0:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & -1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -2 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -2 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -0 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -0 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == -0 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == -0 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if (nx == -1 or nx == M) and ny == N - 1:",
      "mutated_line": "if (nx == --1 or nx == M) and ny == N - 1:",
      "code": "def find_minimum_jumps(board):\n    N = 20\n    M = 15\n    MP = [[-1] * M for _ in range(N)]\n    L = 0\n    (sx, sy) = (0, 0)\n    for i in range(N - 1):\n        for j in range(M):\n            c = board[i][j]\n            if c == 'O':\n                sx = j\n                sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n    INF = 30\n    D = {}\n\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N - 2:\n            return 0\n        r = INF\n        for (dx, dy) in dd:\n            nx = x + dx\n            ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & 1 << k == 0:\n                continue\n            n_state = state ^ 1 << k\n            nx += dx\n            ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & 1 << k == 0:\n                    break\n                n_state ^= 1 << k\n                nx += dx\n                ny += dy\n            else:\n                if (nx == --1 or nx == M) and ny == N - 1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2 ** L - 1, sx, sy)\n    return r if r < INF else -1"
    }
  ]
}