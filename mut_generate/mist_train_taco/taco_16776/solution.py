"""
QUESTION:
Ikta, who hates to lose, has recently been enthusiastic about playing games using the Go board. However, neither Go nor Gomoku can beat my friends at all, so I decided to give a special training to the lesser-known game Phutball.

This game is a difficult game, so I decided to give special training so that I could win my turn and decide if I could finish it.

The conditions for winning the game are as follows.

* Shiraishi cannot jump to the place where Kuroishi is placed.
* Use the 19 x 15 part in the center of the board.
* The board for which you want to judge the victory conditions is given with one white stone and several black stones.
* The goal point is the lower end of the board or the lower side. (See the figure below.)
* If you bring Shiraishi to the goal point, you will win.
* To win, do the following:
* Shiraishi can make one or more jumps.
* Jumping can be done by jumping over any of the eight directions (up, down, left, right, diagonally above, diagonally below) adjacent to Shiraishi.
* It is not possible to jump in a direction where Kuroishi is not adjacent.
* The jumped Kuroishi is removed from the board for each jump.
* After jumping, Shiraishi must be at the goal point or on the game board.
* Even if there are two or more Kuroishi in a row, you can jump just across them.
* Shiraishi cannot jump to the place where Kuroishi is placed. (Kuroishi that is continuous in the direction of jump must be jumped over.)

<image>



It is possible to jump to the places marked with circles in the figure, all of which are goal points, but since the places marked with crosses are neither the goal points nor the inside of the board, it is not possible to jump.

Your job is to help Ikta write a program to determine if you can reach the goal and to find the minimum number of jumps to reach the goal.



Input

A 19 x 15 board composed of .OX is given in 19 lines. Each line always consists of 15 characters, and each character represents the following:

* "." Represents a blank.
* "O" stands for Shiraishi.
* "X" stands for Kuroishi.



Constraints

* The number of black stones is 20 or less.
* There is always only one Shiraishi.
* The state that has already been reached will not be entered.

Output

Goal If possible, output the shortest effort on one line. If it is impossible to reach the goal, output -1.

Examples

Input

...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
......O........
......X........


Output

1


Input

...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
......O........
...............


Output

-1


Input

...............
...............
...............
...............
...............
...............
...............
...............
...........O...
............X..
.............X.
.............X.
.............X.
...............
..............X
.........X.....
.............X.
......X....X..X
.....X.X.XX.X..


Output

6


Input

...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
...............
.....XX........
.....XXXO......
......X........


Output

4
"""

def find_minimum_jumps(board):
    N = 20
    M = 15
    MP = [[-1] * M for _ in range(N)]
    L = 0
    sx, sy = 0, 0
    
    # Parse the board and initialize the MP array
    for i in range(N - 1):
        for j in range(M):
            c = board[i][j]
            if c == 'O':
                sx = j
                sy = i
            elif c == 'X':
                MP[i][j] = L
                L += 1
    
    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))
    INF = 30
    D = {}
    
    def dfs(state, x, y):
        key = (state, x, y)
        if key in D:
            return D[key]
        if y >= N - 2:
            return 0
        r = INF
        for (dx, dy) in dd:
            nx = x + dx
            ny = y + dy
            if not 0 <= nx < M or not 0 <= ny < N:
                continue
            k = MP[ny][nx]
            if k == -1 or state & 1 << k == 0:
                continue
            n_state = state ^ 1 << k
            nx += dx
            ny += dy
            while 0 <= nx < M and 0 <= ny < N:
                k = MP[ny][nx]
                if k == -1 or state & 1 << k == 0:
                    break
                n_state ^= 1 << k
                nx += dx
                ny += dy
            else:
                if (nx == -1 or nx == M) and ny == N - 1:
                    return 1
                continue
            r = min(r, dfs(n_state, nx, ny) + 1)
        D[key] = r
        return D[key]
    
    r = dfs(2 ** L - 1, sx, sy)
    return r if r < INF else -1