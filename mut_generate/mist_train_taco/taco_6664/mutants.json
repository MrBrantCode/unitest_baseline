{
  "task_id": "taco_6664",
  "entry_point": "find_min_divisible_rearrangement",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(same_min_perms) == 1:",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) != 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 'There is no possible rearrangement'",
      "mutated_line": "return ''",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return ''\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(same_min_perms) == 1:",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 2:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(same_min_perms) == 1:",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 0:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(same_min_perms) == 1:",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 0:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(same_min_perms) == 1:",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == -1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "min_number_str = ''.join(min_number)",
      "mutated_line": "min_number_str = 'MUTATED'.join(min_number)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = 'MUTATED'.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]",
      "mutated_line": "same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) != min_number_str]",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) != min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k != 0, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k != 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(",
      "mutated_line": "return ''.format(', '.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return ''.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(",
      "mutated_line": "return ''.format(sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return ''.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[1], sorted_perms[1], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[1], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[-1], sorted_perms[1], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[-1], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[1], sorted_perms[1], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[1], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[2], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[2], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[0], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[0], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[0], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[0], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sorted_perms[0], sorted_perms[1], min_number_str, k)",
      "mutated_line": "return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[-1], min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[-1], min_number_str, k)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) * k == 0, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) * k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) + k == 0, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) + k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 1, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 1, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == -1, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == -1, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 1, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 1, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "', '.join(min_number), min_number_str, k)",
      "mutated_line": "return 'Rearrangement: {} generates: {} divisible by {}'.format(''.join(min_number), min_number_str, k)",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(''.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]",
      "mutated_line": "same_min_perms = [perm for perm in divisible_by_k if 'MUTATED'.join(perm) == min_number_str]",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if 'MUTATED'.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sorted_perms = sorted(', '.join(perm) for perm in same_min_perms)",
      "mutated_line": "sorted_perms = sorted((''.join(perm) for perm in same_min_perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((''.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))",
      "mutated_line": "min_number = min(divisible_by_k, key=lambda x: int('MUTATED'.join(x)))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int('MUTATED'.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "divisible_by_k = list(filter(lambda x: int(''.join(x)) % k == 0, perms))",
      "mutated_line": "divisible_by_k = list(filter(lambda x: int('MUTATED'.join(x)) % k == 0, perms))",
      "code": "from itertools import permutations\n\ndef find_min_divisible_rearrangement(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = list(filter(lambda x: int('MUTATED'.join(x)) % k == 0, perms))\n    if not divisible_by_k:\n        return 'There is no possible rearrangement'\n    min_number = min(divisible_by_k, key=lambda x: int(''.join(x)))\n    min_number_str = ''.join(min_number)\n    same_min_perms = [perm for perm in divisible_by_k if ''.join(perm) == min_number_str]\n    if len(same_min_perms) == 1:\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(min_number), min_number_str, k)\n    else:\n        sorted_perms = sorted((', '.join(perm) for perm in same_min_perms))\n        return 'Rearrangements: {} and {} generates: {} divisible by {}'.format(sorted_perms[0], sorted_perms[1], min_number_str, k)"
    }
  ]
}