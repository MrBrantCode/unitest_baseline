{
  "task_id": "taco_15510",
  "entry_point": "find_color_intervals",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [0] / n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] / n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [0] + n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] + n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [0] ** n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] ** n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n / (k - 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n / (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n * (k - 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n * (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n * (k - 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n * (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n + (k - 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n + (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [0] / n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] / n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [0] + n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] + n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [0] ** n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] ** n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color + 1 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color + 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color * 1 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color * 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k + 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k * 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k * 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k + 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k * 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k * 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(2, k):",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(2, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(0, k):",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(0, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(0, k):",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(0, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(-1, k):",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(-1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "c = q + (i <= r)",
      "mutated_line": "c = q - (i <= r)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q - (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "c = q + (i <= r)",
      "mutated_line": "c = q * (i <= r)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q * (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color - 2 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 2 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color - 0 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 0 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color - 0 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 0 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "colors = [color - 1 for color in colors]",
      "mutated_line": "colors = [color - -1 for color in colors]",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - -1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [1] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [-1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [-1] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used_colors = [0] * n",
      "mutated_line": "used_colors = [1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [1] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k - 2)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 2)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k - 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 0)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k - 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 0)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "q = n // (k - 1)",
      "mutated_line": "q = n // (k - -1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - -1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k - 2)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 2)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k - 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 0)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k - 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 0)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = n % (k - 1)",
      "mutated_line": "r = n % (k - -1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - -1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [1] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [-1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [-1] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "result_intervals = [0] * n",
      "mutated_line": "result_intervals = [1] * n",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [1] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "c = q + (i <= r)",
      "mutated_line": "c = q + (i < r)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i < r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "c = q + (i <= r)",
      "mutated_line": "c = q + (i > r)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i > r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "c = q + (i <= r)",
      "mutated_line": "c = q + (i == r)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i == r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if used_colors[j] == 0:",
      "mutated_line": "if used_colors[j] != 0:",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] != 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "used_colors[ind] = 1",
      "mutated_line": "used_colors[ind] = 2",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 2\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "used_colors[ind] = 1",
      "mutated_line": "used_colors[ind] = 0",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 0\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "used_colors[ind] = 1",
      "mutated_line": "used_colors[ind] = 0",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 0\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "used_colors[ind] = 1",
      "mutated_line": "used_colors[ind] = -1",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = -1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if used_colors[j] == 0:",
      "mutated_line": "if used_colors[j] == 1:",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 1:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if used_colors[j] == 0:",
      "mutated_line": "if used_colors[j] == -1:",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == -1:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if used_colors[j] == 0:",
      "mutated_line": "if used_colors[j] == 1:",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 1:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] - 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] - 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] * 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] * 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] - 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] - 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] * 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] * 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 2, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 2, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 0, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 0, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 0, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 0, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + -1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + -1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 2)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 2)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 0)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 0)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 0)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + -1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + -1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i + 1] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i + 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i * 1] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i * 1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 2] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 2] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 0] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 0] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - 0] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - 0] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result_intervals[ind] = (color_positions[ind][i - 1] + 1, color_positions[ind][i] + 1)",
      "mutated_line": "result_intervals[ind] = (color_positions[ind][i - -1] + 1, color_positions[ind][i] + 1)",
      "code": "def find_color_intervals(n, k, colors):\n    \"\"\"\n    Finds n intervals [a_i, b_i] such that:\n    - For each 1 ≤ i ≤ n, 1 ≤ a_i < b_i ≤ n * k.\n    - For each 1 ≤ i ≤ n, the numbers a_i and b_i are colored with color i.\n    - Each number 1 ≤ x ≤ n * k belongs to at most ceil(n / (k - 1)) intervals.\n\n    Parameters:\n    - n (int): The number of colors.\n    - k (int): The number of occurrences of each color.\n    - colors (list[int]): A list of integers representing the colors of the numbers from 1 to n * k.\n\n    Returns:\n    - list[tuple[int, int]]: A list of tuples, where each tuple represents the interval [a_i, b_i] for each color i.\n    \"\"\"\n    colors = [color - 1 for color in colors]\n    color_positions = [[] for _ in range(n)]\n    for (index, color) in enumerate(colors):\n        color_positions[color].append(index)\n    used_colors = [0] * n\n    q = n // (k - 1)\n    r = n % (k - 1)\n    result_intervals = [0] * n\n    for i in range(1, k):\n        a = []\n        c = q + (i <= r)\n        for j in range(n):\n            if used_colors[j] == 0:\n                a.append((color_positions[j][i], j))\n        a = sorted(a)[:c]\n        for (x, ind) in a:\n            used_colors[ind] = 1\n            result_intervals[ind] = (color_positions[ind][i - -1] + 1, color_positions[ind][i] + 1)\n    return result_intervals"
    }
  ]
}