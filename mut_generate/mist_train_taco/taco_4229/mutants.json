{
  "task_id": "taco_4229",
  "entry_point": "prod_int_partII",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def prod_int_partII(n, s, min_=2):",
      "mutated_line": "def prod_int_partII(n, s, min_=3):",
      "code": "def prod_int_partII(n, s, min_=3):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def prod_int_partII(n, s, min_=2):",
      "mutated_line": "def prod_int_partII(n, s, min_=1):",
      "code": "def prod_int_partII(n, s, min_=1):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def prod_int_partII(n, s, min_=2):",
      "mutated_line": "def prod_int_partII(n, s, min_=0):",
      "code": "def prod_int_partII(n, s, min_=0):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def prod_int_partII(n, s, min_=2):",
      "mutated_line": "def prod_int_partII(n, s, min_=1):",
      "code": "def prod_int_partII(n, s, min_=1):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def prod_int_partII(n, s, min_=2):",
      "mutated_line": "def prod_int_partII(n, s, min_=-2):",
      "code": "def prod_int_partII(n, s, min_=-2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s == 1:",
      "mutated_line": "if s != 1:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s != 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(total, fac) = (0, [])",
      "mutated_line": "(total, fac) = (1, [])",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (1, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(total, fac) = (0, [])",
      "mutated_line": "(total, fac) = (-1, [])",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (-1, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "(total, fac) = (0, [])",
      "mutated_line": "(total, fac) = (1, [])",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (1, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) - 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) - 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) * 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) * 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total -= count + 1",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total -= count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s == 1:",
      "mutated_line": "if s == 2:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 2:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s == 1:",
      "mutated_line": "if s == 0:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 0:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s == 1:",
      "mutated_line": "if s == 0:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 0:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s == 1:",
      "mutated_line": "if s == -1:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == -1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) + 2):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 2):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) + 0):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 0):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) + 0):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 0):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0.5) + -1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + -1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if not n % d:",
      "mutated_line": "if not n * d:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n * d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if not n % d:",
      "mutated_line": "if not n + d:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n + d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if l == 1:",
      "mutated_line": "if l != 1:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l != 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count - 1",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count - 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count * 1",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count * 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[0] if len(fac) != 1 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) != 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n * 0.5) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n * 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n + 0.5) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n + 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n / d, s - 1, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n / d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n * d, s - 1, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n * d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s + 1, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s + 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s * 1, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s * 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if l == 1:",
      "mutated_line": "if l == 2:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 2:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if l == 1:",
      "mutated_line": "if l == 0:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 0:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if l == 1:",
      "mutated_line": "if l == 0:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 0:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if l == 1:",
      "mutated_line": "if l == -1:",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == -1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count + 2",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 2\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count + 0",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 0\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count + 0",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 0\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "total += count + 1",
      "mutated_line": "total += count + -1",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + -1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[0] if len(fac) == 2 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 2 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[0] if len(fac) == 0 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 0 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[0] if len(fac) == 0 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 0 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[0] if len(fac) == -1 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == -1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[1] if len(fac) == 1 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[1] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[-1] if len(fac) == 1 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[-1] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return [total, len(fac), fac[0] if len(fac) == 1 else fac]",
      "mutated_line": "return [total, len(fac), fac[1] if len(fac) == 1 else fac]",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[1] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 1.5) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 1.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** -0.5) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** -0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 0) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** 1) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 1) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for d in range(min_, int(n ** 0.5) + 1):",
      "mutated_line": "for d in range(min_, int(n ** -0.5) + 1):",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** -0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s - 2, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 2, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s - 0, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 0, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s - 0, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 0, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(count, l, sub) = prod_int_partII(n // d, s - 1, d)",
      "mutated_line": "(count, l, sub) = prod_int_partII(n // d, s - -1, d)",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - -1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] + x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac.extend(([d] + x for x in sub))",
      "mutated_line": "fac.extend(([d] - x for x in sub))",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] - x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "fac.extend(([d] + x for x in sub))",
      "mutated_line": "fac.extend(([d] * x for x in sub))",
      "code": "def prod_int_partII(n, s, min_=2):\n    (total, fac) = (0, [])\n    for d in range(min_, int(n ** 0.5) + 1):\n        if not n % d:\n            (count, l, sub) = prod_int_partII(n // d, s - 1, d)\n            if l == 1:\n                sub = [sub]\n            total += count + 1\n            fac.extend(([d] * x for x in sub))\n    if s == 1:\n        fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"
    }
  ]
}