{
  "task_id": "taco_16657",
  "entry_point": "calculate_max_force",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if of == len(skills):",
      "mutated_line": "if of != len(skills):",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of != len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f * cf - m * cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf - m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f * cf * (m * cm)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf * (m * cm)\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [0] / len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] / len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [0] + len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] + len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [0] ** len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] ** len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] - (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] - (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] * ((k - mt[i - 1]) // i)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] * ((k - mt[i - 1]) // i)\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k > len(a) * amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k > len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k < len(a) * amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k < len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k == len(a) * amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k == len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 1\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f = 0",
      "mutated_line": "f = -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = -1\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 1\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f - 1] != amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] != amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "f += 1",
      "mutated_line": "f -= 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f -= 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k > amax - sa[-f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k > amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k < amax - sa[-f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k < amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k == amax - sa[-f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k == amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k += amax - sa[-f - 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k += amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "f += 1",
      "mutated_line": "f -= 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f -= 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f / cf + m * cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f / cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f + cf + m * cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f + cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f ** cf + m * cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f ** cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f * cf + m / cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m / cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f * cf + (m + cm)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + (m + cm)\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return f * cf + m * cm",
      "mutated_line": "return f * cf + m ** cm",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m ** cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(sa)):",
      "mutated_line": "for i in range(2, len(sa)):",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(2, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(sa)):",
      "mutated_line": "for i in range(0, len(sa)):",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(0, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(sa)):",
      "mutated_line": "for i in range(0, len(sa)):",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(0, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, len(sa)):",
      "mutated_line": "for i in range(-1, len(sa)):",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(-1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] - i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] - i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] * (i * (sa[i] - sa[i - 1]))",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] * (i * (sa[i] - sa[i - 1]))\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - 1]) / i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) / i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - 1]) * i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) * i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) - k >= len(a) * amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) - k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) * k >= len(a) * amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) * k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k >= len(a) / amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) / amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k >= len(a) + amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) + amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sum(a) + k >= len(a) * amax:",
      "mutated_line": "if sum(a) + k >= len(a) ** amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) ** amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "f += 1",
      "mutated_line": "f += 2",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 2\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "f += 1",
      "mutated_line": "f += 0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 0\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "f += 1",
      "mutated_line": "f += 0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 0\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "f += 1",
      "mutated_line": "f += -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += -1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax + sa[-f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax + sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax * sa[-f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax * sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax + sa[-f - 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax + sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax * sa[-f - 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax * sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "f += 1",
      "mutated_line": "f += 2",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 2\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "f += 1",
      "mutated_line": "f += 0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 0\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "f += 1",
      "mutated_line": "f += 0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 0\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "f += 1",
      "mutated_line": "f += -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += -1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if t > o:",
      "mutated_line": "if t >= o:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t >= o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if t > o:",
      "mutated_line": "if t <= o:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t <= o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if t > o:",
      "mutated_line": "if t != o:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t != o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (t, [A] * len(skills))",
      "mutated_line": "return (t, [A] / len(skills))",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] / len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (t, [A] * len(skills))",
      "mutated_line": "return (t, [A] + len(skills))",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] + len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (t, [A] * len(skills))",
      "mutated_line": "return (t, [A] ** len(skills))",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] ** len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [1] * len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [1] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [-1] * len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [-1] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mt = [0] * len(sa)",
      "mutated_line": "mt = [1] * len(sa)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [1] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i / (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i / (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + (i + (sa[i] - sa[i - 1]))",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + (i + (sa[i] - sa[i - 1]))\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i ** (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i ** (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = bs.bisect_right(mt, k, hi=len(sa) - f)",
      "mutated_line": "i = bs.bisect_right(mt, k, hi=len(sa) + f)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) + f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i = bs.bisect_right(mt, k, hi=len(sa) - f)",
      "mutated_line": "i = bs.bisect_right(mt, k, hi=len(sa) * f)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) * f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i + 1] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i + 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i * 1] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i * 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k + mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k + mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + k * mt[i - 1] // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + k * mt[i - 1] // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) * cf - amax * cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf - amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) * cf * (amax * cm), len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf * (amax * cm), len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f + 1] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f + 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f * 1] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f * 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "h = [(-a[i], i) for i in range(len(a))]",
      "mutated_line": "h = [(+a[i], i) for i in range(len(a))]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(+a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i + 1] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i + 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i * 1] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i * 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] + sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] + sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] * sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] * sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 2] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 2] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 0] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 0] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 0] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 0] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - -1] + (k - mt[i - 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - -1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) / cf + amax * cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) / cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) + cf + amax * cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) + cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) ** cf + amax * cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) ** cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) * cf + amax / cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax / cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) * cf + (amax + cm), len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + (amax + cm), len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (len(a) * cf + amax * cm, len(a), amax)",
      "mutated_line": "return (len(a) * cf + amax ** cm, len(a), amax)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax ** cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[+f - 1] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[+f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f - 2] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 2] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f - 0] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 0] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f - 0] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 0] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while sa[-f - 1] == amax:",
      "mutated_line": "while sa[-f - -1] == amax:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - -1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f + 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f + 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f * 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f * 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f + 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f + 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f * 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f * 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 2] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 2] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 0] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 0] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 0] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 0] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - -1] + i * (sa[i] - sa[i - 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - -1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i + 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i + 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i * 1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i * 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[+f - 1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[+f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f - 2]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 2]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f - 0]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 0]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f - 0]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 0]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while k >= amax - sa[-f - 1]:",
      "mutated_line": "while k >= amax - sa[-f - -1]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - -1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[+f - 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[+f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f - 2]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 2]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f - 0]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 0]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f - 0]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 0]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k -= amax - sa[-f - 1]",
      "mutated_line": "k -= amax - sa[-f - -1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - -1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i + 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i + 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i * 1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i * 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - 2]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 2]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - 0]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 0]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - 0]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 0]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return sa[i - 1] + (k - mt[i - 1]) // i",
      "mutated_line": "return sa[i - 1] + (k - mt[i - -1]) // i",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - -1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 2])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 2])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 0])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 0])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 0])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 0])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - 1])",
      "mutated_line": "mt[i] = mt[i - 1] + i * (sa[i] - sa[i - -1])",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n\n    def force(cf, cm, f, m):\n        return f * cf + m * cm\n\n    def mtable(sa):\n        mt = [0] * len(sa)\n        for i in range(1, len(sa)):\n            mt[i] = mt[i - 1] + i * (sa[i] - sa[i - -1])\n        return mt\n\n    def maxm(sa, mt, f, k):\n        i = bs.bisect_right(mt, k, hi=len(sa) - f)\n        return sa[i - 1] + (k - mt[i - 1]) // i\n\n    def optimize(a, amax, cf, cm, k):\n        if sum(a) + k >= len(a) * amax:\n            return (len(a) * cf + amax * cm, len(a), amax)\n        sa = sorted(a)\n        f = 0\n        while sa[-f - 1] == amax:\n            f += 1\n        mt = mtable(sa)\n        of = f\n        om = maxm(sa, mt, f, k)\n        o = force(cf, cm, of, om)\n        while k >= amax - sa[-f - 1]:\n            k -= amax - sa[-f - 1]\n            f += 1\n            m = maxm(sa, mt, f, k)\n            t = force(cf, cm, f, m)\n            if t > o:\n                (of, om, o) = (f, m, t)\n        return (o, of, om)\n\n    def apply(a, amax, of, om):\n        a_ = [max(om, ai) for ai in a]\n        h = [(-a[i], i) for i in range(len(a))]\n        hq.heapify(h)\n        for _ in range(of):\n            (_, i) = hq.heappop(h)\n            a_[i] = amax\n        return a_\n    (t, of, om) = optimize(skills, A, cf, cm, m)\n    if of == len(skills):\n        return (t, [A] * len(skills))\n    else:\n        return (t, apply(skills, A, of, om))"
    }
  ]
}