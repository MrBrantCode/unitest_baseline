{
  "task_id": "taco_14246",
  "entry_point": "calculate_tree_combinations",
  "mutant_count": 163,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-1] / N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] / N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-1] + N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] + N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-1] ** N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] ** N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 - 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 - 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 * 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 * 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [0] / N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] / N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [0] + N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] + N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [0] ** N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] ** N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v1 = 13",
      "mutated_line": "v1 = 14",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 14\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v1 = 13",
      "mutated_line": "v1 = 12",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 12\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v1 = 13",
      "mutated_line": "v1 = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 0\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v1 = 13",
      "mutated_line": "v1 = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 1\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v1 = 13",
      "mutated_line": "v1 = -13",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = -13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [0] / N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] / N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [0] + N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] + N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [0] ** N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] ** N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v2 = 17",
      "mutated_line": "v2 = 18",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 18\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v2 = 17",
      "mutated_line": "v2 = 16",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 16\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v2 = 17",
      "mutated_line": "v2 = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 0\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v2 = 17",
      "mutated_line": "v2 = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 1\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v2 = 17",
      "mutated_line": "v2 = -17",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = -17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] / N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] / N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] + N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] + N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [0] ** N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] ** N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[0] = 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 2\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[0] = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 0\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[0] = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 0\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[0] = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = -1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "M[k, w1, w2] += 1",
      "mutated_line": "M[k, w1, w2] -= 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] -= 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 1\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = -1\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 1\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans -= v * (v - 1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans -= v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 * 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 * 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 + 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 + 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 10",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 10\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 8\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 0\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 1\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + -9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + -9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[1] = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[1] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[-1] = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[-1] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "U[0] = 1",
      "mutated_line": "U[1] = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[1] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D = [0]",
      "mutated_line": "D = [1]",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [1]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D = [0]",
      "mutated_line": "D = [-1]",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [-1]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D = [0]",
      "mutated_line": "D = [1]",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [1]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 1\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "h = 0",
      "mutated_line": "h = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = -1\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 1\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "su1 = su2 = 0",
      "mutated_line": "su1 = su2 = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 1\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "su1 = su2 = 0",
      "mutated_line": "su1 = su2 = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = -1\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "su1 = su2 = 0",
      "mutated_line": "su1 = su2 = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 1\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "su1 += X1[w]",
      "mutated_line": "su1 -= X1[w]",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 -= X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "su2 += X2[w]",
      "mutated_line": "su2 -= X2[w]",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 -= X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h - 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h - 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h * 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h * 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 + 1) * MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) * MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = su1 * v1 + 1 + MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = su1 * v1 + 1 + MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 + 1) * MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) * MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = su2 * v2 + 1 + MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = su2 * v2 + 1 + MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "M[k, w1, w2] += 1",
      "mutated_line": "M[k, w1, w2] += 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 2\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "M[k, w1, w2] += 1",
      "mutated_line": "M[k, w1, w2] += 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 0\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "M[k, w1, w2] += 1",
      "mutated_line": "M[k, w1, w2] += 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 0\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "M[k, w1, w2] += 1",
      "mutated_line": "M[k, w1, w2] += -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += -1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) / 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) / 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) * 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b + 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b + 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b * 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b * 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a + 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a + 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a * 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a * 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [+1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [+1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 11 ** 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 11 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 9 ** 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 9 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 0 ** 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 0 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 1 ** 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 1 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = -10 ** 9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = -10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 10 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 10 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 8 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 8 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 0 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 0 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 1 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 1 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** -9 + 9",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** -9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [1] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [-1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [-1] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "X1 = [0] * N",
      "mutated_line": "X1 = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [1] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [1] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [-1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [-1] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "X2 = [0] * N",
      "mutated_line": "X2 = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [1] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [1] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [-1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [-1] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "U = [0] * N",
      "mutated_line": "U = [1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [1] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([0])",
      "mutated_line": "que = deque([1])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([1])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([0])",
      "mutated_line": "que = deque([-1])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([-1])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "que = deque([0])",
      "mutated_line": "que = deque([1])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([1])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[w] = 1",
      "mutated_line": "U[w] = 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 2\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[w] = 1",
      "mutated_line": "U[w] = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 0\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[w] = 1",
      "mutated_line": "U[w] = 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 0\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "U[w] = 1",
      "mutated_line": "U[w] = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = -1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] != -1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] != -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h + 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 2\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h + 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 0\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h + 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 0\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "H[v] = k = h + 1",
      "mutated_line": "H[v] = k = h + -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + -1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 - 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 - 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = su1 * v1 * 1 % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = su1 * v1 * 1 % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 - 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 - 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = su2 * v2 * 1 % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = su2 * v2 * 1 % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v / (v - 1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v / (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += (v + (v - 1)) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += (v + (v - 1)) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v ** (v - 1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v ** (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) // 3",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 3\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) // 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) // 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) // 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 1) // -2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // -2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 2)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 2)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 0)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 0)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 0)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 0)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - -1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - -1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 2)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 2)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 0)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 0)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 0)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 0)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - -1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - -1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-2] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-2] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-0] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-0] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [-0] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-0] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "H = [-1] * N",
      "mutated_line": "H = [--1] * N",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [--1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] == +1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == +1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 / v1 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 / v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 + v1 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 + v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 ** v1 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 ** v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 + 2) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 2) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 + 0) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 0) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 + 0) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 0) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "X1[v] = w1 = (su1 * v1 + 1) % MOD",
      "mutated_line": "X1[v] = w1 = (su1 * v1 + -1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + -1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 / v2 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 / v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 + v2 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 + v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 ** v2 + 1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 ** v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 + 2) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 2) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 + 0) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 0) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 + 0) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 0) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "X2[v] = w2 = (su2 * v2 + 1) % MOD",
      "mutated_line": "X2[v] = w2 = (su2 * v2 + -1) % MOD",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + -1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v + 1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v + 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v * 1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v * 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a + 1].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a + 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a * 1].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a * 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b + 1].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b + 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b * 1].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b * 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] == -2:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -2:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] == -0:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -0:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] == -0:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -0:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if H[w] == -1:",
      "mutated_line": "if H[w] == --1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == --1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 2) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 2) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 0) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 0) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - 0) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 0) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans += v * (v - 1) // 2",
      "mutated_line": "ans += v * (v - -1) // 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - -1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 2].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 2].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 0].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 0].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 0].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 0].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - -1].append(b - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - -1].append(b - 1)\n        G[b - 1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 2].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 2].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 0].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 0].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 0].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - 0].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - -1].append(a - 1)",
      "code": "from collections import deque, defaultdict\n\ndef calculate_tree_combinations(N, edges):\n    G = [[] for _ in range(N)]\n    for (a, b) in edges:\n        G[a - 1].append(b - 1)\n        G[b - -1].append(a - 1)\n    H = [-1] * N\n    MOD = 10 ** 9 + 9\n    X1 = [0] * N\n    v1 = 13\n    X2 = [0] * N\n    v2 = 17\n    U = [0] * N\n    que = deque([0])\n    U[0] = 1\n    D = [0]\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if U[w]:\n                continue\n            U[w] = 1\n            que.append(w)\n            D.append(w)\n    M = defaultdict(int)\n    for v in reversed(D):\n        h = 0\n        su1 = su2 = 0\n        for w in G[v]:\n            if H[w] == -1:\n                continue\n            h = max(h, H[w])\n            su1 += X1[w]\n            su2 += X2[w]\n        H[v] = k = h + 1\n        X1[v] = w1 = (su1 * v1 + 1) % MOD\n        X2[v] = w2 = (su2 * v2 + 1) % MOD\n        M[k, w1, w2] += 1\n    ans = 0\n    for v in M.values():\n        ans += v * (v - 1) // 2\n    return ans"
    }
  ]
}