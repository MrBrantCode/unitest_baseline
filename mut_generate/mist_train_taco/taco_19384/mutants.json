{
  "task_id": "taco_19384",
  "entry_point": "can_make_elements_zero",
  "mutant_count": 128,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "assert len(A) == N",
      "mutated_line": "assert len(A) != N",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) != N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 2 == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 == 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // 2 in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while len(vals_1) != 0:",
      "mutated_line": "while len(vals_1) == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) == 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[0][0] += min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] += min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[0][0] += min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] += min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "assert len(vals_2) == 0",
      "mutated_line": "return (len(ops), ops)",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) != 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm * 2 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm * 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm + 2 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm + 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 2 != 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 1:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 2 != -1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != -1:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 2 != 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 1:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return +1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ps_sm = {0: []}",
      "mutated_line": "ps_sm = {1: []}",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {1: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ps_sm = {0: []}",
      "mutated_line": "ps_sm = {-1: []}",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {-1: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ps_sm = {0: []}",
      "mutated_line": "ps_sm = {1: []}",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {1: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm / 2 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm / 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm * 2 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm * 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return +1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm / 2]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm / 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm * 2]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm * 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(vals_1) != 0:",
      "mutated_line": "while len(vals_1) != 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 1:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(vals_1) != 0:",
      "mutated_line": "while len(vals_1) != -1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != -1:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while len(vals_1) != 0:",
      "mutated_line": "while len(vals_1) != 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 1:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][0] != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] != 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][0] != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] != 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "assert len(vals_2) == 0",
      "mutated_line": "return (len(ops), ops)",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 1\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "assert len(vals_2) == 0",
      "mutated_line": "return (len(ops), ops)",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == -1\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "assert len(vals_2) == 0",
      "mutated_line": "return (len(ops), ops)",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 1\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x >= 0 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x >= 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x <= 0 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x <= 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x != 0 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x != 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 3 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 3 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 1 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 1 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 0 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 0 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % 1 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 1 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if sm % 2 != 0:",
      "mutated_line": "if sm % -2 != 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % -2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -2\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -0\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -0\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return --1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v + x not in ps_sm_new:",
      "mutated_line": "if v + x in ps_sm_new:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // 3 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 3 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // 1 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 1 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // 0 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 0 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // 1 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 1 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sm // 2 not in ps_sm:",
      "mutated_line": "if sm // -2 not in ps_sm:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // -2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -2\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -0\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -0\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return --1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm // 3]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 3]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm // 1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 1]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm // 0]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 0]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm // 1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 1]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "indices_1 = ps_sm[sm // 2]",
      "mutated_line": "indices_1 = ps_sm[sm // -2]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // -2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "indices_2 = [i for i in range(len(A)) if i not in indices_1]",
      "mutated_line": "indices_2 = [i for i in range(len(A)) if i in indices_1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[0][1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][1] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[0][-1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][-1] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[0][1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][1] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[0][1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][1] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[0][-1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][-1] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[0][1] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][1] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][0] == 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 1:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][0] == -1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == -1:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][0] == 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 1:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][0] == 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 1:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][0] == -1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == -1:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][0] == 1:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 1:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x > 1 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 1 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x > -1 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > -1 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "assert all((x > 0 for x in A))",
      "mutated_line": "assert all((x > 1 for x in A))",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 1 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if v + x not in ps_sm_new:",
      "mutated_line": "if v - x not in ps_sm_new:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v - x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if v + x not in ps_sm_new:",
      "mutated_line": "if v * x not in ps_sm_new:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v * x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ps_sm_new[v + x] = indices + [i]",
      "mutated_line": "ps_sm_new[v + x] = indices - [i]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices - [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ps_sm_new[v + x] = indices + [i]",
      "mutated_line": "ps_sm_new[v + x] = indices * [i]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices * [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][1], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][1], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][-1], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][-1], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][1], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][1], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[0][1])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][1])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[0][-1])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][-1])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[0][1])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][1])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[1][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[-1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[-1][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vals_1[0][0] -= min_v",
      "mutated_line": "vals_1[1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[1][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[1][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[-1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[-1][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vals_2[0][0] -= min_v",
      "mutated_line": "vals_2[1][0] -= min_v",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[1][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][1] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][-1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][-1] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[0][1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][1] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "del vals_1[0]",
      "mutated_line": "del vals_1[1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[1]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "del vals_1[0]",
      "mutated_line": "del vals_1[-1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[-1]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "del vals_1[0]",
      "mutated_line": "del vals_1[1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[1]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][1] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][-1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][-1] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[0][1] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][1] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "del vals_2[0]",
      "mutated_line": "del vals_2[1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[1]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "del vals_2[0]",
      "mutated_line": "del vals_2[-1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[-1]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "del vals_2[0]",
      "mutated_line": "del vals_2[1]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[1]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ps_sm_new[v + x] = indices + [i]",
      "mutated_line": "ps_sm_new[v - x] = indices + [i]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v - x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ps_sm_new[v + x] = indices + [i]",
      "mutated_line": "ps_sm_new[v * x] = indices + [i]",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v * x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][2], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][2], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][0], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][0], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][0], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][0], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][-1], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][-1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[0][2]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][2]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[0][0]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][0]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[0][0]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][0]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[0][-1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][-1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[1][0], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[1][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[-1][0], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[-1][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[1][0], vals_2[0][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[1][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[1][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[1][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[-1][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[-1][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "min_v = min(vals_1[0][0], vals_2[0][0])",
      "mutated_line": "min_v = min(vals_1[0][0], vals_2[1][0])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[1][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[1][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[-1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[-1][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if vals_1[0][0] == 0:",
      "mutated_line": "if vals_1[1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[1][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[1][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[-1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[-1][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if vals_2[0][0] == 0:",
      "mutated_line": "if vals_2[1][0] == 0:",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[1][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[1][1], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[1][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[-1][1], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[-1][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[1][1], vals_2[0][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[1][1], vals_2[0][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[1][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[1][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[-1][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[-1][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ops.append([vals_1[0][1], vals_2[0][1]])",
      "mutated_line": "ops.append([vals_1[0][1], vals_2[1][1]])",
      "code": "def can_make_elements_zero(A, N):\n    assert len(A) == N\n    assert all((x > 0 for x in A))\n    sm = sum(A)\n    if sm % 2 != 0:\n        return -1\n    ps_sm = {0: []}\n    for (i, x) in enumerate(A):\n        ps_sm_new = ps_sm.copy()\n        for (v, indices) in ps_sm.items():\n            if v + x not in ps_sm_new:\n                ps_sm_new[v + x] = indices + [i]\n        ps_sm = ps_sm_new\n    if sm // 2 not in ps_sm:\n        return -1\n    indices_1 = ps_sm[sm // 2]\n    indices_2 = [i for i in range(len(A)) if i not in indices_1]\n    vals_1 = [[A[i], i] for i in indices_1]\n    vals_2 = [[A[i], i] for i in indices_2]\n    ops = []\n    while len(vals_1) != 0:\n        ops.append([vals_1[0][1], vals_2[1][1]])\n        min_v = min(vals_1[0][0], vals_2[0][0])\n        vals_1[0][0] -= min_v\n        vals_2[0][0] -= min_v\n        if vals_1[0][0] == 0:\n            del vals_1[0]\n        if vals_2[0][0] == 0:\n            del vals_2[0]\n    assert len(vals_2) == 0\n    return (len(ops), ops)"
    }
  ]
}