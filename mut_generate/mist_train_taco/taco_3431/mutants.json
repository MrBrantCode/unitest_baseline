{
  "task_id": "taco_3431",
  "entry_point": "calculate_minimum_maintenance_cost",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 * 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 + 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d_cost = 0",
      "mutated_line": "d_cost = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 1\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d_cost = 0",
      "mutated_line": "d_cost = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = -1\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d_cost = 0",
      "mutated_line": "d_cost = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 1\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a += 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b += 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "d_cost += d",
      "mutated_line": "d_cost -= d",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost -= d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] / n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] / n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] + n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] + n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] ** n",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] ** n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 1\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = -1\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 1\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "d_cost -= v",
      "mutated_line": "d_cost += v",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost += v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 11 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 9 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 0 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 1 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = -10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 21\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 19\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 0\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 1\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** -20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 2\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 0\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 0\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= -1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 2\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 0\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 0\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= -1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[1] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[-1] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[1] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if max_d in removal:",
      "mutated_line": "if max_d not in removal:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d not in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "removal[max_d] += d",
      "mutated_line": "removal[max_d] -= d",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] -= d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + k * c <= ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c <= ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + k * c >= ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c >= ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + k * c != ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c != ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (1, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (-1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (-1, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (1, 0))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (1, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 1))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, -1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, -1))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "heappush(que, (0, 0))",
      "mutated_line": "heappush(que, (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 1))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dist[to] > total + d:",
      "mutated_line": "if dist[to] >= total + d:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] >= total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dist[to] > total + d:",
      "mutated_line": "if dist[to] <= total + d:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] <= total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dist[to] > total + d:",
      "mutated_line": "if dist[to] != total + d:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] != total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost - k * c < ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost - k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost * (k * c) < ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost * (k * c) < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = d_cost + k * c",
      "mutated_line": "ans = d_cost - k * c",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost - k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = d_cost + k * c",
      "mutated_line": "ans = d_cost * (k * c)",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost * (k * c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if dist[to] > total + d:",
      "mutated_line": "if dist[to] > total - d:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total - d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if dist[to] > total + d:",
      "mutated_line": "if dist[to] > total * d:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total * d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[to] = total + d",
      "mutated_line": "dist[to] = total - d",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total - d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[to] = total + d",
      "mutated_line": "dist[to] = total * d",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total * d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + k / c < ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k / c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + (k + c) < ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + (k + c) < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if d_cost + k * c < ans:",
      "mutated_line": "if d_cost + k ** c < ans:",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k ** c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = d_cost + k * c",
      "mutated_line": "ans = d_cost + k / c",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k / c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = d_cost + k * c",
      "mutated_line": "ans = d_cost + (k + c)",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + (k + c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ans = d_cost + k * c",
      "mutated_line": "ans = d_cost + k ** c",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k ** c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[1]], dist[t[1]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[1]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[-1]], dist[t[1]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[-1]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[1]], dist[t[1]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[1]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[0]], dist[t[2]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[2]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[0]], dist[t[0]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[0]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[0]], dist[t[0]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[0]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "max_d = max(dist[t[0]], dist[t[1]])",
      "mutated_line": "max_d = max(dist[t[0]], dist[t[-1]])",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total + d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[-1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (total + d, to))",
      "mutated_line": "heappush(que, (total - d, to))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total - d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (total + d, to))",
      "mutated_line": "heappush(que, (total * d, to))",
      "code": "from heapq import heappush, heappop\n\ndef calculate_minimum_maintenance_cost(n, m, c, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    edges_dict = {}\n    d_cost = 0\n    for (a, b, d) in roads:\n        a -= 1\n        b -= 1\n        edges[a].append((b, d))\n        edges[b].append((a, d))\n        edges_dict[a, b] = d\n        d_cost += d\n    dist = [INF] * n\n    dist[0] = 0\n    que = []\n    heappush(que, (0, 0))\n    while que:\n        (total, node) = heappop(que)\n        for (to, d) in edges[node]:\n            if dist[to] > total + d:\n                dist[to] = total + d\n                heappush(que, (total * d, to))\n    removal = {}\n    for (t, d) in edges_dict.items():\n        max_d = max(dist[t[0]], dist[t[1]])\n        if max_d in removal:\n            removal[max_d] += d\n        else:\n            removal[max_d] = d\n    ans = d_cost\n    for (k, v) in sorted(removal.items()):\n        d_cost -= v\n        if d_cost + k * c < ans:\n            ans = d_cost + k * c\n    return ans"
    }
  ]
}