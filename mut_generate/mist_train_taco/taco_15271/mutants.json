{
  "task_id": "taco_15271",
  "entry_point": "calculate_min_distance_or_failure",
  "mutant_count": 129,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 * 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 * 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 + 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 + 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[0] = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 1\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[0] = -1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = -1\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[0] = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 1\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cp = 0",
      "mutated_line": "cp = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 1\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cp = 0",
      "mutated_line": "cp = -1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = -1\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cp = 0",
      "mutated_line": "cp = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 1\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0",
      "mutated_line": "ct = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 1\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0",
      "mutated_line": "ct = -1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = -1\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ct = 0",
      "mutated_line": "ct = 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 1\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if r < inf:",
      "mutated_line": "return ('NG', r)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r <= inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if r < inf:",
      "mutated_line": "return ('NG', r)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r >= inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if r < inf:",
      "mutated_line": "return ('NG', r)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r != inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 11 ** 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 11 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 9 ** 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 9 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 0 ** 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 0 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 1 ** 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 1 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = -10 ** 20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = -10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 21",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 21\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 19",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 19\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 0\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 1\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** -20",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** -20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[1] = 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[1] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[-1] = 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[-1] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d[0] = 0",
      "mutated_line": "d[1] = 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[1] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) != 0:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) != 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 or abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 or abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) + p + ct < t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct < t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) + p + ct > t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct > t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) + p + ct == t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct == t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == 1:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 1:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == -1:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == -1:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(e) == 0:",
      "mutated_line": "if len(e) == 1:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 1:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i - 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i - 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i * 1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i * 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (\"NG\", r)",
      "mutated_line": "return ('', r)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if r > ck + cp:",
      "mutated_line": "if r >= ck + cp:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r >= ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if r > ck + cp:",
      "mutated_line": "if r <= ck + cp:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r <= ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if r > ck + cp:",
      "mutated_line": "if r != ck + cp:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r != ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"OK\", r)",
      "mutated_line": "return ('', r)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k <= 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k <= 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k >= 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k >= 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k != 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k != 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 1) + ct < t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct < t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 1) + ct > t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct > t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 1) + ct == t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct == t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] >= ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] >= ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] <= ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] <= ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] != ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] != ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) + p - ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p - ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if (cp * (k + 1) + p) * ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if (cp * (k + 1) + p) * ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] >= ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] >= ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] <= ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] <= ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] != ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] != ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i + 2",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 2\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i + 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 0\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i + 0",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 0\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "r = i + 1",
      "mutated_line": "r = i + -1",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + -1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if r > ck + cp:",
      "mutated_line": "if r > ck - cp:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck - cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if r > ck + cp:",
      "mutated_line": "if r > ck * cp:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck * cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "r = ck + cp",
      "mutated_line": "r = ck - cp",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck - cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "r = ck + cp",
      "mutated_line": "r = ck * cp",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck * cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 4 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 4 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 2 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 2 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 0 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 0 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 1 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 1 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < -3 and abs(cp - p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < -3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 1) - ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) - ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 1) * ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) * ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] > ck - abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck - abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] > ck * abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck * abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 1] = ck - abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck - abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 1] = ck * abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck * abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) - p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) - p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 1) * p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) * p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] > ck + cp - p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp - p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] > (ck + cp) * p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > (ck + cp) * p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[1] = ck + cp - p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp - p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[1] = (ck + cp) * p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = (ck + cp) * p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) / (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) / (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) + (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) + (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) ** (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) ** (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k - 1] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k - 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k * 1] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k * 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k - 1] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k - 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k * 1] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k * 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp / (k + 1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp / (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp + (k + 1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp + (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp ** (k + 1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp ** (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[2] > ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[2] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[0] > ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[0] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[0] > ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[0] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[-1] > ck + cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[-1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] > ck - cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck - cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if e[1] > ck + cp + p:",
      "mutated_line": "if e[1] > ck * cp + p:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck * cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[2] = ck + cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[2] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[0] = ck + cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[0] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[0] = ck + cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[0] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[-1] = ck + cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[-1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[1] = ck - cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck - cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e[1] = ck + cp + p",
      "mutated_line": "e[1] = ck * cp + p",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck * cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k - 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k - 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k * 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k * 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 2] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 2] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 0] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 0] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 0] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 0] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + -1] > ck + abs(cp - p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + -1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] > ck + abs(cp + p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp + p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if e[k + 1] > ck + abs(cp - p):",
      "mutated_line": "if e[k + 1] > ck + abs(cp * p):",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp * p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 2] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 2] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 0] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 0] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 0] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 0] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + -1] = ck + abs(cp - p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + -1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 1] = ck + abs(cp + p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp + p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "e[k + 1] = ck + abs(cp - p)",
      "mutated_line": "e[k + 1] = ck + abs(cp * p)",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp * p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k - 1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k - 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k * 1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k * 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp + p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp + p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp * p) * (k + 1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp * p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 2) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 2) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 0) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 0) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + 0) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 0) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k < 3 and abs(cp - p) * (k + 1) + ct <= t:",
      "mutated_line": "if k < 3 and abs(cp - p) * (k + -1) + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + -1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 2) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 2) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 0) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 0) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + 0) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + 0) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cp * (k + 1) + p + ct <= t:",
      "mutated_line": "if cp * (k + -1) + p + ct <= t:",
      "code": "import collections\n\ndef calculate_min_distance_or_failure(n, balloons):\n    inf = 10 ** 20\n    d = collections.defaultdict(lambda : inf)\n    d[0] = 0\n    cp = 0\n    ct = 0\n    r = inf\n    for i in range(n):\n        (p, t) = balloons[i]\n        e = collections.defaultdict(lambda : inf)\n        for (k, ck) in list(d.items()):\n            if k < 3 and abs(cp - p) * (k + 1) + ct <= t:\n                if e[k + 1] > ck + abs(cp - p):\n                    e[k + 1] = ck + abs(cp - p)\n            if cp * (k + -1) + p + ct <= t:\n                if e[1] > ck + cp + p:\n                    e[1] = ck + cp + p\n        d = e\n        if len(e) == 0:\n            r = i + 1\n            break\n        cp = p\n        ct = t\n    if r < inf:\n        return ('NG', r)\n    else:\n        for (k, ck) in d.items():\n            if r > ck + cp:\n                r = ck + cp\n        return ('OK', r)"
    }
  ]
}