{
  "task_id": "taco_11695",
  "entry_point": "count_valid_amidakuji",
  "mutant_count": 214,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 - 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 * 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 2",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 2\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 0\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 0\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = -1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = -1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - 1] * MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - 1] + MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 * 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 + 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 8\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 6\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 0\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 1\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + -7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] / W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] / W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] + W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] + W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] ** W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] ** W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][1] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][-1] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][-1] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][1] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(2, H + 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(2, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(0, H + 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(0, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(0, H + 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(0, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(-1, H + 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(-1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H - 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H - 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H * 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H * 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] -= dp[h - 1][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] -= dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 11 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 9 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 0 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 1 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = -10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 10 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 8 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 0 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 1 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** -9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[1][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[-1][0] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[-1][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[1][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H + 2):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 2):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H + 0):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 0):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H + 0):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 0):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for h in range(1, H + 1):",
      "mutated_line": "for h in range(1, H + -1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + -1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 > 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 > 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 < 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 < 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 == 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 == 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] -= dp[h - 1][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] -= dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 1][w] / B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] / B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 1][w] + B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] + B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 1][w] ** B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] ** B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 < W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 < W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 > W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 > W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 == W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 == W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] -= dp[h - 1][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] -= dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K + 1] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K + 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K * 1] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K * 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[1] * W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[1] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[-1] * W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[-1] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[1] * W for _ in range(H + 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[1] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H - 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H - 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H * 1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H * 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (1, 0, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (1, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (-1, 0, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (-1, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (1, 0, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (1, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, 1, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 1, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, -1, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, -1, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, 1, 0)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 1, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, 0, 1)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 1)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, 0, -1)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, -1)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "A, B, C = 0, 0, 0",
      "mutated_line": "(A, B, C) = (0, 0, 1)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 1)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 * (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 * (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 + (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 + (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w + 1 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w + 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w * 1 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w * 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 >= 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 1:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 >= -1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= -1:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 1 >= 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 1:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 1] / A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] / A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 1] + A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] + A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 1] ** A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] ** A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w - 1 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w - 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w * 1 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w * 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W + 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W + 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W * 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W * 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 1] / C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] / C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 1] + C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] + C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 1] ** C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] ** C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - 2] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 2] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - 0] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - 0] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dp[H][K - 1] % MOD",
      "mutated_line": "return dp[H][K - -1] % MOD",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - -1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H + 2)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 2)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H + 0)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 0)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H + 0)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 0)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0] * W for _ in range(H + 1)]",
      "mutated_line": "dp = [[0] * W for _ in range(H + -1)]",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + -1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(3 ** (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(3 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(1 ** (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(1 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(0 ** (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(0 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(1 ** (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(1 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(-2 ** (W - 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(-2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W + 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W + 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W * 1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W * 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W + 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W + 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W * 1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W * 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i >> j & 1:",
      "mutated_line": "if i >> j | 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j | 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 or lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 or lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "A += 1",
      "mutated_line": "A -= 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A -= 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 2 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 2 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 0 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 0 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - 0 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 0 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if w - 1 >= 0:",
      "mutated_line": "if w - -1 >= 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - -1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 2 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 2 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 0 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 0 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 0 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 0 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + -1 <= W - 1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + -1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W - 2:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 2:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W - 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 0:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W - 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 0:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if w + 1 <= W - 1:",
      "mutated_line": "if w + 1 <= W - -1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - -1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W - 2)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 2)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W - 0)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 0)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W - 0)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 0)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2 ** (W - 1)):",
      "mutated_line": "for i in range(2 ** (W - -1)):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - -1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 2):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 2):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 0):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 0):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 0):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 0):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - -1):",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - -1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i >> j & 1:",
      "mutated_line": "if i >> j & 2:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 2:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i >> j & 1:",
      "mutated_line": "if i >> j & 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 0:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i >> j & 1:",
      "mutated_line": "if i >> j & 0:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 0:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if i >> j & 1:",
      "mutated_line": "if i >> j & -1:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & -1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines or lines[-1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines or lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 > 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 > 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 < 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 < 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 == 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 == 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A += 1",
      "mutated_line": "A += 2",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 2\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A += 1",
      "mutated_line": "A += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 0\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A += 1",
      "mutated_line": "A += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 0\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A += 1",
      "mutated_line": "A += -1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += -1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - 2 or lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 or lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "C += 1",
      "mutated_line": "C -= 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C -= 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "B += 1",
      "mutated_line": "B -= 1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B -= 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w + 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w * 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w * 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h + 1][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h + 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h * 1][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h * 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w - 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w * 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w * 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "lines.append(True)",
      "mutated_line": "lines.append(False)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(False)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "lines.append(False)",
      "mutated_line": "lines.append(True)",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(True)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w + 1 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w + 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w * 1 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w * 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 1 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 1 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= -1 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= -1 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 1 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 1 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w + 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w + 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w * 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w * 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w < W - 2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w < W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w > W - 2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w > W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w == W - 2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w == W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C += 1",
      "mutated_line": "C += 2",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 2\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C += 1",
      "mutated_line": "C += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 0\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C += 1",
      "mutated_line": "C += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 0\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "C += 1",
      "mutated_line": "C += -1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += -1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B += 1",
      "mutated_line": "B += 2",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 2\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B += 1",
      "mutated_line": "B += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 0\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B += 1",
      "mutated_line": "B += 0",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 0\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "B += 1",
      "mutated_line": "B += -1",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += -1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h + 1][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h + 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h * 1][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h * 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 2] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 2] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 0] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 0] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - 0] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 0] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 1][w - -1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - -1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 2][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 2][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 0][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 0][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - 0][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 0][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[h][w] += dp[h - 1][w] * B",
      "mutated_line": "dp[h][w] += dp[h - -1][w] * B",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - -1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h + 1][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h + 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h * 1][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h * 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 2] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 2] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 0] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 0] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + 0] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 0] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 1][w + -1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + -1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines and lines[+1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[+1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 2 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 2 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 0 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 0 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 0 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 0 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - -1 >= 0 and lines[w - 1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - -1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w - 2]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 2]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w - 0]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 0]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w - 0]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 0]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if w - 1 >= 0 and lines[w - 1]:",
      "mutated_line": "if w - 1 >= 0 and lines[w - -1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - -1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W + 2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W + 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W * 2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W * 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 2][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 2][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 0][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 0][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - 0][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 0][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[h][w] += dp[h - 1][w - 1] * A",
      "mutated_line": "dp[h][w] += dp[h - -1][w - 1] * A",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - -1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 2][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 2][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 0][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 0][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - 0][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 0][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[h][w] += dp[h - 1][w + 1] * C",
      "mutated_line": "dp[h][w] += dp[h - -1][w + 1] * C",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - -1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines and lines[-2]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-2]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines and lines[-0]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-0]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines and lines[-0]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-0]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if lines and lines[-1]:",
      "mutated_line": "if lines and lines[--1]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[--1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - 3 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 3 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - 1 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 1 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - 0 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 0 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - 1 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - 1 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif w <= W - 2 and lines[w]:",
      "mutated_line": "elif w <= W - -2 and lines[w]:",
      "code": "def count_valid_amidakuji(H, W, K):\n    MOD = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for w in range(W):\n            (A, B, C) = (0, 0, 0)\n            for i in range(2 ** (W - 1)):\n                lines = []\n                for j in range(W - 1):\n                    if i >> j & 1:\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w - 1 >= 0 and lines[w - 1]:\n                        A += 1\n                    elif w <= W - -2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w - 1 >= 0:\n                dp[h][w] += dp[h - 1][w - 1] * A\n            dp[h][w] += dp[h - 1][w] * B\n            if w + 1 <= W - 1:\n                dp[h][w] += dp[h - 1][w + 1] * C\n    return dp[H][K - 1] % MOD"
    }
  ]
}