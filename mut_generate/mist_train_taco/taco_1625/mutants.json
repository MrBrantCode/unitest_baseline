{
  "task_id": "taco_1625",
  "entry_point": "min_steps_to_color_text",
  "mutant_count": 63,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if s != 0:",
      "mutated_line": "if s == 0:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s == 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mmax = 0",
      "mutated_line": "mmax = 1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 1\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mmax = 0",
      "mutated_line": "mmax = -1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = -1\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mmax = 0",
      "mutated_line": "mmax = 1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 1\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "ec = -1",
      "mutated_line": "ec = +1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = +1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if mmax != len(t):",
      "mutated_line": "if mmax == len(t):",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax == len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if sum(covered) == len(t):",
      "mutated_line": "if sum(covered) != len(t):",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) != len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return +1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(s, e, ind) = intervals[0]",
      "mutated_line": "(s, e, ind) = intervals[1]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[1]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(s, e, ind) = intervals[0]",
      "mutated_line": "(s, e, ind) = intervals[-1]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[-1]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(s, e, ind) = intervals[0]",
      "mutated_line": "(s, e, ind) = intervals[1]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[1]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 1:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s != 0:",
      "mutated_line": "if s != -1:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != -1:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if s != 0:",
      "mutated_line": "if s != 1:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 1:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return +1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ec = -1",
      "mutated_line": "ec = -2",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -2\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ec = -1",
      "mutated_line": "ec = -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -0\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ec = -1",
      "mutated_line": "ec = -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -0\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ec = -1",
      "mutated_line": "ec = --1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = --1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s <= mmax:",
      "mutated_line": "if s < mmax:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s < mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s <= mmax:",
      "mutated_line": "if s > mmax:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s > mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if s <= mmax:",
      "mutated_line": "if s == mmax:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s == mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "covered = [0 for _ in range(len(t))]",
      "mutated_line": "covered = [1 for _ in range(len(t))]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [1 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "covered = [0 for _ in range(len(t))]",
      "mutated_line": "covered = [-1 for _ in range(len(t))]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [-1 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "covered = [0 for _ in range(len(t))]",
      "mutated_line": "covered = [1 for _ in range(len(t))]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [1 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return +1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if t[j:j + len(s)] == s:",
      "mutated_line": "if t[j:j + len(s)] != s:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] != s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -2\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -0\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -0\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return --1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -2\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -0\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -0\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return --1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if e > ec:",
      "mutated_line": "if e >= ec:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e >= ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if e > ec:",
      "mutated_line": "if e <= ec:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e <= ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if e > ec:",
      "mutated_line": "if e != ec:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e != ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if e == len(t):",
      "mutated_line": "if e != len(t):",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e != len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "covered[i] = 1",
      "mutated_line": "covered[i] = 2",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 2\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "covered[i] = 1",
      "mutated_line": "covered[i] = 0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 0\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "covered[i] = 1",
      "mutated_line": "covered[i] = 0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 0\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "covered[i] = 1",
      "mutated_line": "covered[i] = -1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = -1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return --1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind - 1, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind - 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind * 1, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind * 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s - 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s - 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s * 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s * 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 2, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 2, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 0, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 0, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 0, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 0, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + -1, s + 1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + -1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s + 2) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 2) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s + 0) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 0) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s + 0) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 0) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "steps = [(ind + 1, s + 1) for (s, e, ind) in used]",
      "mutated_line": "steps = [(ind + 1, s + -1) for (s, e, ind) in used]",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + -1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if t[j:j + len(s)] == s:",
      "mutated_line": "if t[j:j - len(s)] == s:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j - len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if t[j:j + len(s)] == s:",
      "mutated_line": "if t[j:j * len(s)] == s:",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j * len(s)] == s:\n                intervals.append((j, j + len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "intervals.append((j, j + len(s), i))",
      "mutated_line": "intervals.append((j, j - len(s), i))",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j - len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "intervals.append((j, j + len(s), i))",
      "mutated_line": "intervals.append((j, j * len(s), i))",
      "code": "def min_steps_to_color_text(t: str, strings: list) -> tuple:\n    intervals = []\n    for (i, s) in enumerate(strings):\n        for j in range(len(t)):\n            if t[j:j + len(s)] == s:\n                intervals.append((j, j * len(s), i))\n    intervals.sort()\n    if not intervals:\n        return -1\n    (s, e, ind) = intervals[0]\n    if s != 0:\n        return -1\n    mmax = 0\n    used = []\n    ec = -1\n    for (s, e, ind) in intervals:\n        if s <= mmax:\n            if e > ec:\n                (sc, ec, indc) = (s, e, ind)\n        else:\n            used.append((sc, ec, indc))\n            mmax = ec\n            (sc, ec, indc) = (s, e, ind)\n    if mmax != len(t):\n        for (s, e, ind) in intervals:\n            if e == len(t):\n                used.append((s, e, ind))\n                break\n    covered = [0 for _ in range(len(t))]\n    for (s, e, ind) in used:\n        for i in range(s, e):\n            covered[i] = 1\n    if sum(covered) == len(t):\n        steps = [(ind + 1, s + 1) for (s, e, ind) in used]\n        return (len(steps), steps)\n    else:\n        return -1"
    }
  ]
}