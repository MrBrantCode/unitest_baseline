{
  "task_id": "taco_13460",
  "entry_point": "construct_binary_tree",
  "mutant_count": 231,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) / 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) / 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) * 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) * 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 - k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 - k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = (k * 2 ** (k + 1) - 2 ** (k + 1) + 2) * (k * (n - 2 ** (k + 1) + 1))",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = (k * 2 ** (k + 1) - 2 ** (k + 1) + 2) * (k * (n - 2 ** (k + 1) + 1))\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d < mind and d > maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind and d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lowest = 1",
      "mutated_line": "lowest = 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 2\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lowest = 1",
      "mutated_line": "lowest = 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 0\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lowest = 1",
      "mutated_line": "lowest = 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 0\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "lowest = 1",
      "mutated_line": "lowest = -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = -1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n + 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n + 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n * 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n * 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while s > d:",
      "mutated_line": "while s >= d:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s >= d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while s > d:",
      "mutated_line": "while s <= d:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s <= d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while s > d:",
      "mutated_line": "while s != d:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s != d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 1\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = -1\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 1\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n / (n - 1) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n / (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = (n + (n - 1)) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = (n + (n - 1)) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n ** (n - 1) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n ** (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) // 3",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 3\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) // 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 1\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) // 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 0\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) // 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 1\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 1) // -2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // -2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) - 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) - 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = (k * 2 ** (k + 1) - 2 ** (k + 1)) * 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = (k * 2 ** (k + 1) - 2 ** (k + 1)) * 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k / (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k / (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + (k + (n - 2 ** (k + 1) + 1))",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + (k + (n - 2 ** (k + 1) + 1))\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k ** (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k ** (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d <= mind or d > maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d <= mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d >= mind or d > maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d >= mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d != mind or d > maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d != mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d < mind or d >= maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d >= maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d < mind or d <= maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d <= maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d < mind or d > maxd:",
      "mutated_line": "if d < mind or d != maxd:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d != maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return ''\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = [1 for i in range(n)]",
      "mutated_line": "l = [2 for i in range(n)]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [2 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = [1 for i in range(n)]",
      "mutated_line": "l = [0 for i in range(n)]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [0 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = [1 for i in range(n)]",
      "mutated_line": "l = [0 for i in range(n)]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [0 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = [1 for i in range(n)]",
      "mutated_line": "l = [-1 for i in range(n)]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [-1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n - 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 2\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n - 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 0\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n - 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 0\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "highest = n - 1",
      "mutated_line": "highest = n - -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - -1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "diff = s - d",
      "mutated_line": "diff = s + d",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s + d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "diff = s - d",
      "mutated_line": "diff = s * d",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s * d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if diff > highest - lowest:",
      "mutated_line": "if diff >= highest - lowest:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff >= highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if diff > highest - lowest:",
      "mutated_line": "if diff <= highest - lowest:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff <= highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if diff > highest - lowest:",
      "mutated_line": "if diff != highest - lowest:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff != highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] += 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] += 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "l[lowest] += 1",
      "mutated_line": "l[lowest] -= 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] -= 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "s -= highest - lowest",
      "mutated_line": "s += highest - lowest",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s += highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "highest -= 1",
      "mutated_line": "highest += 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest += 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "l[level] += 1",
      "mutated_line": "l[level] -= 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] -= 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] += 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] += 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "s -= diff",
      "mutated_line": "s += diff",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s += diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return 'YES', parents",
      "mutated_line": "return ('', parents)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(l2[j]) == l[j]:",
      "mutated_line": "if len(l2[j]) != l[j]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) != l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j -= 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(2, len(l)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(2, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(0, len(l)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(0, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(0, len(l)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(0, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(-1, len(l)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(-1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 1\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 0",
      "mutated_line": "p = -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = -1\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 1\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(t)):",
      "mutated_line": "for i in range(2, len(t)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(2, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(t)):",
      "mutated_line": "for i in range(0, len(t)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(0, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(t)):",
      "mutated_line": "for i in range(0, len(t)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(0, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, len(t)):",
      "mutated_line": "for i in range(-1, len(t)):",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(-1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n + 1) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n + 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n * 1) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n * 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) + 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) + 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) * 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) * 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 3 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 3 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 1 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 1 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 0 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 0 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 1 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 1 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + -2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + -2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) - 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) - 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * ((n - 2 ** (k + 1)) * 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * ((n - 2 ** (k + 1)) * 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if diff > highest - lowest:",
      "mutated_line": "if diff > highest + lowest:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest + lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if diff > highest - lowest:",
      "mutated_line": "if diff > highest * lowest:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest * lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 2\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 0\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 0\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= -1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "l[lowest] += 1",
      "mutated_line": "l[lowest] += 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 2\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "l[lowest] += 1",
      "mutated_line": "l[lowest] += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 0\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "l[lowest] += 1",
      "mutated_line": "l[lowest] += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 0\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "l[lowest] += 1",
      "mutated_line": "l[lowest] += -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += -1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "s -= highest - lowest",
      "mutated_line": "s -= highest + lowest",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest + lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "s -= highest - lowest",
      "mutated_line": "s -= highest * lowest",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest * lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "highest -= 1",
      "mutated_line": "highest -= 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 2\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "highest -= 1",
      "mutated_line": "highest -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 0\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "highest -= 1",
      "mutated_line": "highest -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 0\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "highest -= 1",
      "mutated_line": "highest -= -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= -1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * 2 != l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 != l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "lowest += 1",
      "mutated_line": "lowest -= 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest -= 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "level = highest - diff",
      "mutated_line": "level = highest + diff",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest + diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "level = highest - diff",
      "mutated_line": "level = highest * diff",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest * diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "l[level] += 1",
      "mutated_line": "l[level] += 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 2\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "l[level] += 1",
      "mutated_line": "l[level] += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 0\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "l[level] += 1",
      "mutated_line": "l[level] += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 0\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "l[level] += 1",
      "mutated_line": "l[level] += -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += -1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 2\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 0\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 0\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "l[highest] -= 1",
      "mutated_line": "l[highest] -= -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= -1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = [{'p': None, 'c': []} for i in range(sum(l))]",
      "mutated_line": "t = [{'': None, 'c': []} for i in range(sum(l))]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t = [{'p': None, 'c': []} for i in range(sum(l))]",
      "mutated_line": "t = [{'p': None, '': []} for i in range(sum(l))]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, '': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i - 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i - 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i * 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i * 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 2\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 0\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 0\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += -1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) != 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) != 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p -= 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 2) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 2) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 0) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 0) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - 0) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 0) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "maxd = n * (n - 1) // 2",
      "mutated_line": "maxd = n * (n - -1) // 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - -1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k / 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k / 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k + 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k + 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k ** 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k ** 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 * (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 * (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - (2 + (k + 1)) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - (2 + (k + 1)) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n + 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n + 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n * 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n * 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 2)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 2)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 0)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 0)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 0)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 0)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + -1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + -1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] / 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] / 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] + 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] + 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] ** 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] ** 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lowest += 1",
      "mutated_line": "lowest += 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 2\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lowest += 1",
      "mutated_line": "lowest += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 0\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lowest += 1",
      "mutated_line": "lowest += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 0\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "lowest += 1",
      "mutated_line": "lowest += -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += -1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i + 2)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 2)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i + 0)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 0)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i + 0)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 0)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "l2[j].append(i + 1)",
      "mutated_line": "l2[j].append(i + -1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + -1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n - 1][''] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1][''] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) == 3:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 3:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) == 1:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 1:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) == 0:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 0:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) == 1:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 1:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['c']) == -2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == -2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 2\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 0\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 0\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += -1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "parents.append(t[i]['p'])",
      "mutated_line": "parents.append(t[i][''])",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i][''])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * (2 * (k + 1)) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * (2 * (k + 1)) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * (2 + (k + 1)) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * (2 + (k + 1)) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 3 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 3 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 1 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 1 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 0 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 0 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 1 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 1 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - -2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - -2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k - 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k - 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k * 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k * 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 * (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 * (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - (2 + (k + 1)) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - (2 + (k + 1)) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * 3 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 3 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * 1 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 1 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * 0 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 0 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * 1 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 1 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 1] * -2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * -2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i + 1][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i + 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i * 1][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i * 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n + 1]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n + 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n * 1]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n * 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 3 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 3 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 1 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 1 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 0 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 0 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 1 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 1 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * -2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * -2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k - 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k - 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k * 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k * 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 2) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 2) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 0) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 0) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 0) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 0) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + -1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + -1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 3 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 3 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 1 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 1 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 0 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 0 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 1 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 1 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - -2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - -2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k - 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k - 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k * 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k * 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest + 1] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest + 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest * 1] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest * 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i - 2][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 2][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i - 0][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 0][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i - 0][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 0][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pi = l2[i - 1][p]",
      "mutated_line": "pi = l2[i - -1][p]",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - -1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n - 2]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 2]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n - 0]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 0]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n - 0]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 0]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "t[n - 1]['p'] = pi",
      "mutated_line": "t[n - -1]['p'] = pi",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - -1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi - 1][''].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1][''].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 1]['']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 2) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 2) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 0) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 0) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 0) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 0) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + -1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + -1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 2) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 2) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 0) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 0) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 0) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 0) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)",
      "mutated_line": "mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + -1) + 1)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + -1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 2] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 2] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 0] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 0] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - 0] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 0] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if l[lowest - 1] * 2 == l[lowest]:",
      "mutated_line": "if l[lowest - -1] * 2 == l[lowest]:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - -1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi + 1]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi + 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi * 1]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi * 1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi + 1]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi + 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi * 1]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi * 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi - 2]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 2]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi - 0]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 0]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi - 0]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 0]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t[pi - 1]['c'].append(n)",
      "mutated_line": "t[pi - -1]['c'].append(n)",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - -1]['c'].append(n)\n                if len(t[pi - 1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 2]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 2]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 0]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 0]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - 0]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - 0]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if len(t[pi - 1]['c']) == 2:",
      "mutated_line": "if len(t[pi - -1]['c']) == 2:",
      "code": "import math as m\n\ndef construct_binary_tree(n, d):\n\n    def print_tree(l):\n        t = [{'p': None, 'c': []} for i in range(sum(l))]\n        l2 = {i: [] for i in range(len(l))}\n        j = 0\n        for i in range(sum(l)):\n            l2[j].append(i + 1)\n            if len(l2[j]) == l[j]:\n                j += 1\n        for i in range(1, len(l)):\n            p = 0\n            for n in l2[i]:\n                pi = l2[i - 1][p]\n                t[n - 1]['p'] = pi\n                t[pi - 1]['c'].append(n)\n                if len(t[pi - -1]['c']) == 2:\n                    p += 1\n        parents = []\n        for i in range(1, len(t)):\n            parents.append(t[i]['p'])\n        return parents\n    k = m.floor(m.log2(n))\n    maxd = n * (n - 1) // 2\n    mind = k * 2 ** (k + 1) - 2 ** (k + 1) + 2 + k * (n - 2 ** (k + 1) + 1)\n    if d < mind or d > maxd:\n        return 'NO'\n    l = [1 for i in range(n)]\n    s = maxd\n    lowest = 1\n    highest = n - 1\n    while s > d:\n        diff = s - d\n        if diff > highest - lowest:\n            l[highest] -= 1\n            l[lowest] += 1\n            s -= highest - lowest\n            highest -= 1\n            if l[lowest - 1] * 2 == l[lowest]:\n                lowest += 1\n        else:\n            level = highest - diff\n            l[level] += 1\n            l[highest] -= 1\n            s -= diff\n    parents = print_tree(l)\n    return ('YES', parents)"
    }
  ]
}