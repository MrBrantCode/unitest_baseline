{
  "task_id": "taco_8698",
  "entry_point": "find_spec_partition",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if com == 'max':",
      "mutated_line": "if com != 'max':",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com != 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if com == 'max':",
      "mutated_line": "if com == '':",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == '':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r - [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r - [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r * ([x] * (k - r))",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r * ([x] * (k - r))\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif com == 'min':",
      "mutated_line": "elif com != 'min':",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com != 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] / r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] / r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] + r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] + r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] ** r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] ** r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r + [x] / (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] / (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r + ([x] + (k - r))",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + ([x] + (k - r))\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r + [x] ** (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] ** (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif com == 'min':",
      "mutated_line": "elif com == '':",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == '':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] - [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] - [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] * ([1] * (k - 1))",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] * ([1] * (k - 1))\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r + [x] * (k + r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k + r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 1] * r + [x] * (k * r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k * r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] / (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] / (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + ([1] + (k - 1))",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + ([1] + (k - 1))\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] ** (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] ** (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "raise ValueError(\"Invalid command. Use 'max' or 'min'.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError('')"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x - 1] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x - 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x * 1] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x * 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 + k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 + k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [(n + 1) * k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [(n + 1) * k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k + 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k + 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k * 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k * 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 2] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 2] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 0] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 0] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + 0] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 0] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return [x + 1] * r + [x] * (k - r)",
      "mutated_line": "return [x + -1] * r + [x] * (k - r)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + -1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n - 1 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n - 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n * 1 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n * 1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [2] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [2] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [0] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [0] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [0] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [0] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [-1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [-1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k - 2)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 2)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k - 0)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 0)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k - 0)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - 0)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 1 - k] + [1] * (k - -1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 1 - k] + [1] * (k - -1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 2 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 2 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 0 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 0 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + 0 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + 0 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [n + 1 - k] + [1] * (k - 1)",
      "mutated_line": "return [n + -1 - k] + [1] * (k - 1)",
      "code": "def find_spec_partition(n, k, com):\n    \"\"\"\n    Finds the partition of integer `n` into `k` parts that has either the maximum or minimum product of its terms.\n\n    Parameters:\n    - n (int): The integer to be partitioned.\n    - k (int): The number of partitions.\n    - com (str): The command indicating whether to find the partition with the maximum ('max') or minimum ('min') product of its terms.\n\n    Returns:\n    - list: A list of integers representing the partition with the specified product property.\n    \"\"\"\n    (x, r) = divmod(n, k)\n    if com == 'max':\n        return [x + 1] * r + [x] * (k - r)\n    elif com == 'min':\n        return [n + -1 - k] + [1] * (k - 1)\n    else:\n        raise ValueError(\"Invalid command. Use 'max' or 'min'.\")"
    }
  ]
}