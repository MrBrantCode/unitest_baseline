{
  "task_id": "taco_18067",
  "entry_point": "calculate_minimum_destroying_cost",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 or t == 0 or k == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 or t == 0 or k == 0:\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 1\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = -1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = -1\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_cost = 0",
      "mutated_line": "total_cost = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 1\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "total_cost += c",
      "mutated_line": "total_cost -= c",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost -= c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [0] / n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] / n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [0] + n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] + n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [0] ** n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] ** n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k + 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = (t - k) * 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n != 0 and t == 0 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n != 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t != 0 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t != 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 0 and (k != 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k != 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 1] = 2",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 2\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 1] = 0",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 0\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 1] = 0",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 0\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 1] = -1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = -1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x == prt[x]:",
      "mutated_line": "if x != prt[x]:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x != prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if px < py:",
      "mutated_line": "if px <= py:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px <= py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if px < py:",
      "mutated_line": "if px >= py:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px >= py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if px < py:",
      "mutated_line": "if px != py:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px != py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "sz[px] += sz[py]",
      "mutated_line": "sz[px] -= sz[py]",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] -= sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "sz[py] += sz[px]",
      "mutated_line": "sz[py] -= sz[px]",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] -= sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t + k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t * k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 2\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 0\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 0\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d = t - k - 1",
      "mutated_line": "for (c, a, b) in E:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - -1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 0 and sz[pb] == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 and sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "total_cost -= c",
      "mutated_line": "total_cost += c",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost += c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d >= 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d >= 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d <= 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d <= 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d != 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d != 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "d -= 1",
      "mutated_line": "d += 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d += 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "total_cost -= c",
      "mutated_line": "total_cost += c",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost += c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 1 and t == 0 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 1 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == -1 and t == 0 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == -1 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 1 and t == 0 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 1 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 1 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 1 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == -1 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == -1 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 1 and (k == 0):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 1 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 0 and (k == 1):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 1):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 0 and (k == -1):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == -1):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 0 and t == 0 and k == 0:",
      "mutated_line": "if n == 0 and t == 0 and (k == 1):",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 1):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "E.sort(reverse=True)",
      "mutated_line": "E.sort(reverse=False)",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=False)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [1] * n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [1] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [-1] * n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [-1] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sz = [0] * n",
      "mutated_line": "sz = [1] * n",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [1] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v + 1] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v + 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v * 1] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v * 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] != 0 or sz[pb] == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] != 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 0 or sz[pb] != 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] != 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d > 1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 1:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d > -1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > -1:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if d > 0:",
      "mutated_line": "if d > 1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 1:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d -= 1",
      "mutated_line": "d -= 2",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 2\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 0\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 0\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d -= 1",
      "mutated_line": "d -= -1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= -1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a + 1, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a + 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a * 1, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a * 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b + 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b + 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b * 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b * 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 2] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 2] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 0] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 0] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - 0] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 0] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "sz[v - 1] = 1",
      "mutated_line": "sz[v - -1] = 1",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - -1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 1 or sz[pb] == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 1 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == -1 or sz[pb] == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == -1 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 1 or sz[pb] == 0:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 1 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 0 or sz[pb] == 1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 1:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 0 or sz[pb] == -1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == -1:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if sz[pa] == 0 or sz[pb] == 0:",
      "mutated_line": "if sz[pa] == 0 or sz[pb] == 1:",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 1:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 2, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 2, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 0, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 0, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 0, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 0, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - -1, b - 1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - -1, b - 1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b - 2))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 2))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b - 0))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 0))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b - 0))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - 0))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "E.append((c, a - 1, b - 1))",
      "mutated_line": "E.append((c, a - 1, b - -1))",
      "code": "def calculate_minimum_destroying_cost(n, t, k, edges, bases):\n    if n == 0 and t == 0 and (k == 0):\n        return None\n    G = [[] for _ in range(n)]\n    E = []\n    total_cost = 0\n    for (a, b, c) in edges:\n        total_cost += c\n        E.append((c, a - 1, b - -1))\n    E.sort(reverse=True)\n    sz = [0] * n\n    for v in bases:\n        sz[v - 1] = 1\n    prt = list(range(n))\n\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n\n    def unite(x, y):\n        px = root(x)\n        py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = t - k - 1\n    for (c, a, b) in E:\n        pa = root(a)\n        pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            total_cost -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            total_cost -= c\n    return total_cost"
    }
  ]
}