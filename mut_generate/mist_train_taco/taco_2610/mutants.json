{
  "task_id": "taco_2610",
  "entry_point": "calculate_permutation_score",
  "mutant_count": 211,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 1\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = -1\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 1\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans -= B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans -= B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "l = -1",
      "mutated_line": "l = +1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = +1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N - 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N - 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N * 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N * 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) / 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) * 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l >= 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l >= 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l <= 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l <= 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l != 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l != 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 1 + B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 + B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = (N - 1) * B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = (N - 1) * B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "l = -1",
      "mutated_line": "l = +1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = +1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N - 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N - 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N * 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N * 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) / 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) * 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l >= 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l >= 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l <= 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l <= 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l != 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l != 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) / (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) / (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) + (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) + (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += (B[i][0] * (B[i][1] - LL)) ** (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += (B[i][0] * (B[i][1] - LL)) ** (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] / (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] / (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] + (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] + (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] ** (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] ** (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = -1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i >= 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i <= 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i != 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "s += self.tree[i]",
      "mutated_line": "s -= self.tree[i]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s -= self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i += i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i < self.size:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i < self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i > self.size:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i > self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i == self.size:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i == self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "self.tree[i] += x",
      "mutated_line": "self.tree[i] -= x",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] -= x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i -= i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = -1",
      "mutated_line": "l = -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -2\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = -1",
      "mutated_line": "l = -0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -0\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = -1",
      "mutated_line": "l = -0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -0\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = -1",
      "mutated_line": "l = --1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = --1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 2\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 0\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 0\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + -1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + -1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l - r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = l * r // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 3\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 1\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 0\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 1\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // -2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r + l > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r + l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r * l > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r * l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 2:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 2:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 0:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 0:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > -1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > -1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) <= L.sum(B[i][1] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) <= L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) >= L.sum(B[i][1] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) >= L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) != L.sum(B[i][1] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) != L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) / 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) * 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] - 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] - 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] * 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] * 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 1, 2)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 2)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 1, 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 0)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 1, 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 0)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 1, -1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, -1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N + 1 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N + 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N * 1 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N * 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "l = -1",
      "mutated_line": "l = -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -2\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "l = -1",
      "mutated_line": "l = -0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -0\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "l = -1",
      "mutated_line": "l = -0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -0\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "l = -1",
      "mutated_line": "l = --1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = --1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 2\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 0\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 0\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r = N + 1",
      "mutated_line": "r = N + -1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + -1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l - r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = l * r // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 3\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 1\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 0\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 1\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // -2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r + l > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r + l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r * l > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r * l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 2:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 2:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 0:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 0:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > -1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > -1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) <= R.sum(rr + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) <= R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) >= R.sum(rr + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) >= R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) != R.sum(rr + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) != R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) / 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) * 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] - 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] - 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add((N - 1 - B[i][1]) * 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add((N - 1 - B[i][1]) * 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 1, 2)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 2)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 1, 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 0)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 1, 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 0)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 1, -1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, -1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] / (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] / (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += (B[i][0] + (B[i][1] - LL)) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += (B[i][0] + (B[i][1] - LL)) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] ** (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] ** (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR + B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR + B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * ((N - 1 - RR) * B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * ((N - 1 - RR) * B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n - 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n - 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n * 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n * 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > -1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i | -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i | -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l - r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = l * r // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 3\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 1\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 0\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 1\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // -2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 2, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 2, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 0, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 0, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + 0, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 0, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][1] + -1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + -1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 2 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 2 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 0 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 0 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 0 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 0 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - -1 - B[i][1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - -1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 1 - B[i][2]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][2]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 1 - B[i][0]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][0]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 1 - B[i][0]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][0]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rr = N - 1 - B[i][1]",
      "mutated_line": "rr = N - 1 - B[i][-1]",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][-1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l - r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = l * r // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 3\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 1\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 0\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 1\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // -2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 + B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 + B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add((N - 1) * B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add((N - 1) * B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 2, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 2, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 0, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 0, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + 0, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 0, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][1] + -1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + -1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] + LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] + LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] * LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] * LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 + RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 + RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * ((N - 1) * RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * ((N - 1) * RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [-1] * (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [-1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [1] * (n + 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [1] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 2)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 2)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 0)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + 0)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 0)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.tree = [0] * (n + 1)",
      "mutated_line": "self.tree = [0] * (n + -1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + -1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & +i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & +i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] - 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] - 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] * 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] * 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][2] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][2] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][0] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][0] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][0] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][0] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "L.add(B[i][1] + 1, 1)",
      "mutated_line": "L.add(B[i][-1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][-1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr - 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr - 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr * 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr * 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N + 1 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N + 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N * 1 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N * 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][-1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][-1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][1] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N + 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N + 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N * 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N * 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][2])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][2])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][0])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][0])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][-1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] + 2):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 2):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] + 0):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 0):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] + 0):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 0):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][1] + -1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + -1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr + 2):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 2):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr + 0):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 0):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr + 0):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 0):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if R.sum(m) < R.sum(rr + 1):",
      "mutated_line": "if R.sum(m) < R.sum(rr + -1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + -1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 2 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 2 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 0 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 0 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 0 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 0 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - -1 - B[i][1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - -1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][2] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][2] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][0] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][0] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][0] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][0] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "R.add(N - 1 - B[i][1] + 1, 1)",
      "mutated_line": "R.add(N - 1 - B[i][-1] + 1, 1)",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][-1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][2] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][2] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][0] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][0] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][0] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][0] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][-1] - LL) * (N - 1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][-1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 2 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 2 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 0 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 0 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 0 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 0 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])",
      "mutated_line": "ans += B[i][0] * (B[i][1] - LL) * (N - -1 - RR - B[i][1])",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - -1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][2] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][2] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][0] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][0] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][0] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][0] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if L.sum(m) < L.sum(B[i][1] + 1):",
      "mutated_line": "if L.sum(m) < L.sum(B[i][-1] + 1):",
      "code": "def calculate_permutation_score(N, A):\n\n    class Bit:\n\n        def __init__(self, n):\n            self.size = n\n            self.tree = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.tree[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.size:\n                self.tree[i] += x\n                i += i & -i\n    B = [[A[i], i] for i in range(N)]\n    B.sort()\n    L = Bit(N)\n    R = Bit(N)\n    ans = 0\n    for i in range(N):\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if L.sum(m) < L.sum(B[i][-1] + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        L.add(B[i][1] + 1, 1)\n        LL = l\n        rr = N - 1 - B[i][1]\n        l = -1\n        r = N + 1\n        m = (l + r) // 2\n        while r - l > 1:\n            if R.sum(m) < R.sum(rr + 1):\n                l = m\n            else:\n                r = m\n            m = (l + r) // 2\n        R.add(N - 1 - B[i][1] + 1, 1)\n        RR = l\n        ans += B[i][0] * (B[i][1] - LL) * (N - 1 - RR - B[i][1])\n    return ans"
    }
  ]
}