{
  "task_id": "taco_13018",
  "entry_point": "find_largest_product_subset",
  "mutant_count": 190,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][1] = 1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 1\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][1] = -1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = -1\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][1] = 1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 1\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prod = 1",
      "mutated_line": "prod = 2",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 2\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prod = 1",
      "mutated_line": "prod = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 0\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prod = 1",
      "mutated_line": "prod = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 0\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prod = 1",
      "mutated_line": "prod = -1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = -1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now >= 0:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now >= 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now <= 0:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now <= 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now != 0:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now != 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d or len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] / 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] / 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] + 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] + 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] ** 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] ** 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][2] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][2] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][0] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][0] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[0][-1] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][-1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now > 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 1:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now > -1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > -1:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while now > 0:",
      "mutated_line": "while now > 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 1:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][2] != 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] != 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i * 10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i * 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i + 10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i + 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod != d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) >= 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) <= 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) != 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 11 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 11 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 9 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 9 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 0 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 0 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 1 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 1 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * -10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * -10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[1][1] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[1][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[-1][1] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[-1][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp[0][1] = 0",
      "mutated_line": "dp[1][1] = 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[1][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(10):",
      "mutated_line": "for j in range(11):",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(11):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(10):",
      "mutated_line": "for j in range(9):",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(9):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(10):",
      "mutated_line": "for j in range(0):",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(0):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(10):",
      "mutated_line": "for j in range(1):",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(1):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(10):",
      "mutated_line": "for j in range(-10):",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(-10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "val = dp[i][j] + math.log(a[i])",
      "mutated_line": "val = dp[i][j] - math.log(a[i])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] - math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "val = dp[i][j] + math.log(a[i])",
      "mutated_line": "val = dp[i][j] * math.log(a[i])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] * math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 10] < val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] < val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 10] > val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] > val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 10] == val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] == val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 1][j] < val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] < val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 1][j] > val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] > val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 1][j] == val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] == val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][2] == 2:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 2:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][2] == 0:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 0:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][2] == 0:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 0:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][2] == -1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == -1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod / i % 10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod / i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = (prod + i) % 10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = (prod + i) % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod ** i % 10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod ** i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i % 11",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 11\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i % 9",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 9\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i % 0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 0\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i % 1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 1\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "prod = prod * i % 10",
      "mutated_line": "prod = prod * i % -10",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % -10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 1:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > -1:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if prod == d and len(soln) > 0:",
      "mutated_line": "return (len(soln), soln)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 1:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return --1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[+10000000000.0] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[+10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n - 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n - 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n * 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n * 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(1, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(1, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(-1, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(-1, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(1, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(1, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 1, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 1, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, -1, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, -1, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 1, 0) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 1, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 1) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 1) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, -1) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, -1) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 1) for i in range(10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 1) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n - 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n - 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n * 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n * 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][3] == 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][3] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][1] == 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][1] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][0] == 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][0] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][1] == 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][1] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if come[now][dig][2] == 1:",
      "mutated_line": "if come[now][dig][-2] == 1:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][-2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(now, dig) = come[now][dig][:2]",
      "mutated_line": "(now, dig) = come[now][dig][:3]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:3]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(now, dig) = come[now][dig][:2]",
      "mutated_line": "(now, dig) = come[now][dig][:1]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:1]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(now, dig) = come[now][dig][:2]",
      "mutated_line": "(now, dig) = come[now][dig][:0]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:0]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(now, dig) = come[now][dig][:2]",
      "mutated_line": "(now, dig) = come[now][dig][:1]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:1]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(now, dig) = come[now][dig][:2]",
      "mutated_line": "(now, dig) = come[now][dig][:-2]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:-2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000001.0] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000001.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-9999999999.0] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-9999999999.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-1] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[--10000000000.0] * 10 for _ in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[--10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 2)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 2)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 0)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 0)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 0)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 0)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[-10000000000.0] * 10 for _ in range(n + 1)]",
      "mutated_line": "dp = [[-10000000000.0] * 10 for _ in range(n + -1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + -1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(11)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(11)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(9)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(9)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(0)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(0)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(1)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(1)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(-10)] for j in range(n + 1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(-10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 2)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 2)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 0)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 0)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 0)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 0)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]",
      "mutated_line": "come = [[(0, 0, 0) for i in range(10)] for j in range(n + -1)]",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + -1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] * 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] * 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] + 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] + 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] * 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] * 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] + 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] + 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] * 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] * 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] + 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] + 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 10] = (i, j, 2)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 2)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 10] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 0)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 10] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 0)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 10] = (i, j, -1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, -1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 1][j] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 1)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 1][j] = (i, j, -1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, -1)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 1][j] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 1)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now + 1])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now + 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now * 1])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now * 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i - 1][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i - 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i * 1][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i * 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j / a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j / a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][(j + a[i]) % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][(j + a[i]) % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j ** a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j ** a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 11] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 11] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 9] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 9] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 0] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 0] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % 1] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 1] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 1][j * a[i] % -10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % -10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i - 1][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i - 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i * 1][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i * 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j / a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j / a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][(j + a[i]) % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][(j + a[i]) % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j ** a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j ** a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] % 11] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 11] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] % 9] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 9] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] % 0] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 0] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] % 1] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 1] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 1][j * a[i] % -10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % -10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i - 1][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i - 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i * 1][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i * 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j / a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j / a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][(j + a[i]) % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][(j + a[i]) % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j ** a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j ** a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 11] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 11] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 9] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 9] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 0] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 0] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % 1] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 1] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 1][j * a[i] % -10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % -10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i - 1][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i - 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i * 1][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i * 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i - 1][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i - 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i * 1][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i * 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i - 1][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i - 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i * 1][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i * 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now - 2])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 2])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now - 0])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 0])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now - 0])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 0])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "soln.append(a[now - 1])",
      "mutated_line": "soln.append(a[now - -1])",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - -1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 2][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 2][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 0][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 0][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + 0][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 0][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i + 1][j * a[i] % 10] <= val:",
      "mutated_line": "if dp[i + -1][j * a[i] % 10] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + -1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 2][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 2][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 0][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 0][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + 0][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 0][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][j * a[i] % 10] = val",
      "mutated_line": "dp[i + -1][j * a[i] % 10] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + -1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 2][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 2][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 0][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 0][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + 0][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 0][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "come[i + 1][j * a[i] % 10] = (i, j, 1)",
      "mutated_line": "come[i + -1][j * a[i] % 10] = (i, j, 1)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + -1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 2][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 2][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 0][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 0][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + 0][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 0][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i + 1][j] <= val:",
      "mutated_line": "if dp[i + -1][j] <= val:",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + -1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i + 2][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 2][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i + 0][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 0][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i + 0][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 0][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[i + 1][j] = val",
      "mutated_line": "dp[i + -1][j] = val",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + -1][j] = val\n                come[i + 1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 2][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 2][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 0][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 0][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + 0][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + 0][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "come[i + 1][j] = (i, j, 0)",
      "mutated_line": "come[i + -1][j] = (i, j, 0)",
      "code": "import math\n\ndef find_largest_product_subset(n, d, a):\n    dp = [[-10000000000.0] * 10 for _ in range(n + 1)]\n    come = [[(0, 0, 0) for i in range(10)] for j in range(n + 1)]\n    dp[0][1] = 0\n    for i in range(n):\n        for j in range(10):\n            val = dp[i][j] + math.log(a[i])\n            if dp[i + 1][j * a[i] % 10] <= val:\n                dp[i + 1][j * a[i] % 10] = val\n                come[i + 1][j * a[i] % 10] = (i, j, 1)\n            val = dp[i][j]\n            if dp[i + 1][j] <= val:\n                dp[i + 1][j] = val\n                come[i + -1][j] = (i, j, 0)\n    now = n\n    prod = 1\n    dig = d\n    soln = []\n    while now > 0:\n        if come[now][dig][2] == 1:\n            soln.append(a[now - 1])\n        (now, dig) = come[now][dig][:2]\n    for i in soln:\n        prod = prod * i % 10\n    if prod == d and len(soln) > 0:\n        return (len(soln), soln)\n    else:\n        return -1"
    }
  ]
}