{
  "task_id": "taco_2694",
  "entry_point": "count_visible_endpoints",
  "mutant_count": 178,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][3]] -= c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] -= c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fr = [0 for i in range(N)]",
      "mutated_line": "fr = [1 for i in range(N)]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [1 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fr = [0 for i in range(N)]",
      "mutated_line": "fr = [-1 for i in range(N)]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [-1 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fr = [0 for i in range(N)]",
      "mutated_line": "fr = [1 for i in range(N)]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [1 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "slope2 = -float('inf')",
      "mutated_line": "slope2 = +float('inf')",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = +float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 1\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = -1\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 1\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "slope1 = float('inf')",
      "mutated_line": "slope1 = float('')",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "typ = r[i][0]",
      "mutated_line": "typ = r[i][1]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][1]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "typ = r[i][0]",
      "mutated_line": "typ = r[i][-1]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][-1]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "typ = r[i][0]",
      "mutated_line": "typ = r[i][1]",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][1]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i - 1, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i - 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i * 1, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i * 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if typ == 0:",
      "mutated_line": "if typ != 0:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ != 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if slope2 >= slope1:",
      "mutated_line": "if slope2 > slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 > slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if slope2 >= slope1:",
      "mutated_line": "if slope2 < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 < slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if slope2 >= slope1:",
      "mutated_line": "if slope2 == slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 == slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "slope2 = -float('inf')",
      "mutated_line": "slope2 = -float('')",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][2], r[i][2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][2], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][0], r[i][2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][0], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][0], r[i][2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][0], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][-1], r[i][2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][-1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][1], r[i][3])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][3])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][1], r[i][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][1])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][1], r[i][0])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][0])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][1], r[i][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][1])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x, y = r[i][1], r[i][2]",
      "mutated_line": "(x, y) = (r[i][1], r[i][-2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][-2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 2, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 2, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 0, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 0, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + -1, N):",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + -1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) * (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) * (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) // (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) // (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c -= 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] -= 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if typ == 0:",
      "mutated_line": "if typ == 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 1:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if typ == 0:",
      "mutated_line": "if typ == -1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == -1:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if typ == 0:",
      "mutated_line": "if typ == 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 1:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][0] != 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] != 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] != 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][4]] += c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][4]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][2]] += c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][2]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][0]] += c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][0]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][1]] += c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][1]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "fr[r[i][3]] += c",
      "mutated_line": "fr[r[i][-3]] += c",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][-3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r.sort(key=lambda x: x[1])",
      "mutated_line": "r.sort(key=lambda x: x[2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[2])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r.sort(key=lambda x: x[1])",
      "mutated_line": "r.sort(key=lambda x: x[0])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[0])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r.sort(key=lambda x: x[1])",
      "mutated_line": "r.sort(key=lambda x: x[0])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[0])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r.sort(key=lambda x: x[1])",
      "mutated_line": "r.sort(key=lambda x: x[-1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[-1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y + r[j][2]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y + r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = y * r[j][2] / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = y * r[j][2] / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x + r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x + r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x * r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x * r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 2\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 0\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 0\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += -1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 2\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 0\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 0\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += -1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][0] == 2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 2:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][0] == 0:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 0:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][0] == 0:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 0:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][0] == -1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == -1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 > cur or cur > slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur or cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c -= 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] -= 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 < cur or cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur or cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c -= 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] -= 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] -= 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 2:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 0:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 0:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == -1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur or cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "c += 1",
      "mutated_line": "fr[r[j][3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c -= 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] -= 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur or cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "c += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c -= 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] -= 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][1] == 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][1] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][-1] == 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][-1] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if r[j][1] == 1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][1] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 >= cur and cur > slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 >= cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 <= cur and cur > slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 <= cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 != cur and cur > slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 != cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 > cur and cur >= slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur >= slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 > cur and cur <= slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur <= slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "if slope1 > cur and cur != slope2:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur != slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 2\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 0\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 0\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += -1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 2\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 0\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 0\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += -1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 <= cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 <= cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 >= cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 >= cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 != cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 != cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 < cur and cur <= slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur <= slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 < cur and cur >= slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur >= slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "if slope2 < cur and cur != slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur != slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 2\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 0\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 0\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += -1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 2",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 2\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 0\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += 0",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 0\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][3]] += -1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += -1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][1] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][-1] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r[j][0] == 1:",
      "mutated_line": "if slope2 < cur and cur < slope1:",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][1] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 >= cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 <= cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 != cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur >= slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur <= slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if slope1 > cur and cur > slope2:",
      "mutated_line": "c += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur != slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "c += 1",
      "mutated_line": "fr[r[j][3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 2\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "c += 1",
      "mutated_line": "fr[r[j][3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 0\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "c += 1",
      "mutated_line": "fr[r[j][3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 0\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "c += 1",
      "mutated_line": "fr[r[j][3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += -1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 2\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 0\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 0\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += -1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 <= cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 >= cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 != cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur <= slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur >= slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if slope2 < cur and cur < slope1:",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur != slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 2\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 0\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 0\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "c += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += -1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 2\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 0\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 0\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += -1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][3]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][3]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][1]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][1]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][0]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][0]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][1]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][1]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][-2]) / (x - r[j][1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][-2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x - r[j][2])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][2])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x - r[j][0])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][0])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x - r[j][0])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][0])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cur = (y - r[j][2]) / (x - r[j][1])",
      "mutated_line": "cur = (y - r[j][2]) / (x - r[j][-1])",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][-1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][4]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][4]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][2]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][2]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][0]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][0]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][1]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][1]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][-3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][-3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][4]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][4]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][2]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][2]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][0]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][0]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][1]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][1]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][-3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][-3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][4]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][4]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][2]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][2]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][0]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][0]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][1]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][1]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "fr[r[j][-3]] += 1",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][-3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][4]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][2]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][0]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][1]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][-3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][4]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][2]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][0]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][1]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "fr[r[j][3]] += 1",
      "mutated_line": "slope2 = max(cur, slope2)",
      "code": "def count_visible_endpoints(H, N, obstacles):\n    r = []\n    for i in range(N):\n        (tt, x, a) = obstacles[i]\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(N)]\n    for i in range(N):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        typ = r[i][0]\n        c = 0\n        for j in range(i + 1, N):\n            try:\n                cur = (y - r[j][2]) / (x - r[j][1])\n            except ZeroDivisionError:\n                c += 1\n                fr[r[j][3]] += 1\n                continue\n            if typ == 0:\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            elif r[j][0] == 1:\n                if slope1 > cur and cur > slope2:\n                    c += 1\n                    fr[r[j][3]] += 1\n                slope1 = min(cur, slope1)\n            else:\n                if slope2 < cur and cur < slope1:\n                    c += 1\n                    fr[r[j][-3]] += 1\n                slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    return fr"
    }
  ]
}