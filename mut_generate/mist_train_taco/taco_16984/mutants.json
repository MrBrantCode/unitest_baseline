{
  "task_id": "taco_16984",
  "entry_point": "find_matching_or_independent_set",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 3 / n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 / n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 3 + n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 + n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 3 ** n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 ** n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] / (total_node + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] / (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] + (total_node + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] + (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] ** (total_node + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] ** (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] / (m + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] / (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] + (m + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] + (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] ** (m + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] ** (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "matching_edge_count = 0",
      "mutated_line": "matching_edge_count = 1",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 1\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "matching_edge_count = 0",
      "mutated_line": "matching_edge_count = -1",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = -1\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "matching_edge_count = 0",
      "mutated_line": "matching_edge_count = 1",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 1\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if matching_edge_count >= n:",
      "mutated_line": "result_type = 'Matching'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count > n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if matching_edge_count >= n:",
      "mutated_line": "result_type = 'Matching'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count < n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if matching_edge_count >= n:",
      "mutated_line": "result_type = 'Matching'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count == n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(result_indices) < n:",
      "mutated_line": "result_type = 'Impossible'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) <= n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(result_indices) < n:",
      "mutated_line": "result_type = 'Impossible'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) >= n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(result_indices) < n:",
      "mutated_line": "result_type = 'Impossible'",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) != n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 4 * n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 4 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 2 * n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 2 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 0 * n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 0 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = 1 * n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 1 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "total_node = 3 * n",
      "mutated_line": "total_node = -3 * n",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = -3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node - 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node - 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node * 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node * 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m - 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m - 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m * 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m * 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if not is_node_covered[u] and not is_node_covered[v]:",
      "mutated_line": "if not is_node_covered[u] or not is_node_covered[v]:",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] or not is_node_covered[v]:\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "matching_edge_count += 1",
      "mutated_line": "matching_edge_count -= 1",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count -= 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result_type = \"Matching\"",
      "mutated_line": "result_type = ''",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = ''\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "result_type = \"IndSet\"",
      "mutated_line": "result_type = ''",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = ''\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result_type = \"Impossible\"",
      "mutated_line": "result_type = ''",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = ''\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [True] * (total_node + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [True] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node + 2)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 2)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node + 0)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 0)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node + 0)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 0)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "is_node_covered = [False] * (total_node + 1)",
      "mutated_line": "is_node_covered = [False] * (total_node + -1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + -1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [True] * (m + 1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [True] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m + 2)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 2)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m + 0)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 0)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m + 0)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 0)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_edge_in_matching = [False] * (m + 1)",
      "mutated_line": "is_edge_in_matching = [False] * (m + -1)",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + -1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i, (u, v) in enumerate(edges, start=1):",
      "mutated_line": "if not is_node_covered[u] and (not is_node_covered[v]):",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=2):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i, (u, v) in enumerate(edges, start=1):",
      "mutated_line": "if not is_node_covered[u] and (not is_node_covered[v]):",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=0):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i, (u, v) in enumerate(edges, start=1):",
      "mutated_line": "if not is_node_covered[u] and (not is_node_covered[v]):",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=0):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i, (u, v) in enumerate(edges, start=1):",
      "mutated_line": "if not is_node_covered[u] and (not is_node_covered[v]):",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=-1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "is_node_covered[u] = is_node_covered[v] = True",
      "mutated_line": "is_node_covered[u] = is_node_covered[v] = False",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = False\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "is_edge_in_matching[i] = True",
      "mutated_line": "is_edge_in_matching[i] = False",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = False\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matching_edge_count += 1",
      "mutated_line": "matching_edge_count += 2",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 2\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matching_edge_count += 1",
      "mutated_line": "matching_edge_count += 0",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 0\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matching_edge_count += 1",
      "mutated_line": "matching_edge_count += 0",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 0\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "matching_edge_count += 1",
      "mutated_line": "matching_edge_count += -1",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += -1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(2, m + 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(2, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(0, m + 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(0, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(0, m + 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(0, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(-1, m + 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(-1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m - 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m - 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m * 1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m * 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(2, total_node + 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(2, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(0, total_node + 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(0, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(0, total_node + 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(0, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(-1, total_node + 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(-1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node - 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node - 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node * 1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node * 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m + 2) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 2) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m + 0) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 0) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m + 0) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 0) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, m + -1) if is_edge_in_matching[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + -1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node + 2) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 2) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node + 0) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 0) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node + 0) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + 0) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result_indices = [i for i in range(1, total_node + 1) if not is_node_covered[i]][:n]",
      "mutated_line": "result_indices = [i for i in range(1, total_node + -1) if not is_node_covered[i]][:n]",
      "code": "def find_matching_or_independent_set(n, m, edges):\n    total_node = 3 * n\n    is_node_covered = [False] * (total_node + 1)\n    is_edge_in_matching = [False] * (m + 1)\n    matching_edge_count = 0\n    for (i, (u, v)) in enumerate(edges, start=1):\n        if not is_node_covered[u] and (not is_node_covered[v]):\n            is_node_covered[u] = is_node_covered[v] = True\n            is_edge_in_matching[i] = True\n            matching_edge_count += 1\n    if matching_edge_count >= n:\n        result_type = 'Matching'\n        result_indices = [i for i in range(1, m + 1) if is_edge_in_matching[i]][:n]\n    else:\n        result_type = 'IndSet'\n        result_indices = [i for i in range(1, total_node + -1) if not is_node_covered[i]][:n]\n    if len(result_indices) < n:\n        result_type = 'Impossible'\n        result_indices = []\n    return (result_type, result_indices)"
    }
  ]
}