{
  "task_id": "taco_2928",
  "entry_point": "determine_replication_order",
  "mutant_count": 163,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] / n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] + n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] ** n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = True",
      "mutated_line": "res = False",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = False\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ba = 0",
      "mutated_line": "ba = 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 1\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ba = 0",
      "mutated_line": "ba = -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = -1\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ba = 0",
      "mutated_line": "ba = 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 1\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "while to_use and res:",
      "mutated_line": "while to_use or res:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use or res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] += 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 1] -= 2",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 2\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 1] -= 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 0\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 1] -= 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 0\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 1] -= -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= -1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 or loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 or loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] -= 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] -= 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ba += 1",
      "mutated_line": "ba -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba -= 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] -= 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba >= n * 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba >= n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba <= n * 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba <= n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba != n * 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba != n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return ''\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [5] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [3] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [0] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [1] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "loads = [4] * n",
      "mutated_line": "indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [-4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i - 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i - 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i * 1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i * 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] + 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] + 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] * 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] * 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] <= 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] <= 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] >= 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] >= 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] != 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] != 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] <= 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] <= 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] >= 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] >= 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] != 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] != 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ba = 0",
      "mutated_line": "ba = 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 1\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ba = 0",
      "mutated_line": "ba = -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = -1\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ba = 0",
      "mutated_line": "ba = 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 1\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 2",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 2\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 0\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 0\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += -1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] += 2",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 2\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 0\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 0\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] += -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += -1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ba += 1",
      "mutated_line": "ba += 2",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 2\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ba += 1",
      "mutated_line": "ba += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 0\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ba += 1",
      "mutated_line": "ba += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 0\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ba += 1",
      "mutated_line": "ba += -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += -1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 2",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 2\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 0\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 0",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 0\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += -1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += -1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n / 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n / 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n + 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n + 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n ** 12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n ** 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "res = False",
      "mutated_line": "res = True",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = True\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return \"YES\", order",
      "mutated_line": "return ('', order)",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('', order)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i + 2) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 2) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i + 0) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 0) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i + 0) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 0) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indexed_rules = [(a, b, c, i + 1) for i, (a, b, c) in enumerate(rules)]",
      "mutated_line": "indexed_rules = [(a, b, c, i + -1) for (i, (a, b, c)) in enumerate(rules)]",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + -1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 2] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 2] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 0] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 0] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - 0] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 0] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[0] - -1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - -1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 10 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 10 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 8 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 8 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 0 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 0 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 1 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 1 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < -9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < -9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 - (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 - (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 * (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 * (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] + 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] + 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] * 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] * 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] + 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] + 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] * 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] * 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] + 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] + 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] * 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] * 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n * 13:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 13:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n * 11:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 11:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n * 0:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 0:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n * 1:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 1:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ba > n * 12:",
      "mutated_line": "if ba > n * -12:",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * -12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[1] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[1] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[-1] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[-1] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "loads[moving[0] - 1] -= 1",
      "mutated_line": "loads[moving[1] - 1] -= 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[1] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] + 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] + 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] * 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] * 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] + 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] + 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] * 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] * 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 10 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 10 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 8 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 8 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 0 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 0 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 1 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 1 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < -9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < -9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 2] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 2] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 0] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 0] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[1] - -1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - -1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 2] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 2] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 0] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 0] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[2] - -1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - -1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order.append(moving[3])",
      "mutated_line": "order.append(moving[4])",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[4])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order.append(moving[3])",
      "mutated_line": "order.append(moving[2])",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[2])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order.append(moving[3])",
      "mutated_line": "order.append(moving[0])",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[0])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order.append(moving[3])",
      "mutated_line": "order.append(moving[1])",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[1])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "order.append(moving[3])",
      "mutated_line": "order.append(moving[-3])",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[-3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 2] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 2] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 0] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - 0] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 0] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[0] - -1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - -1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 2] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 2] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 0] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 0] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 0] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 0] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - -1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - -1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 2] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 2] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 0] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 0] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 0] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 0] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - -1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - -1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] != moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] != moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (+1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (+1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 1):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 1):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else -1):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else -1):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 1):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 1):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[2] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[2] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[0] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[0] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "loads[moving[1] - 1] += 1",
      "mutated_line": "loads[moving[-1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[-1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[3] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[3] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[1] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[0] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[0] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[1] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "loads[moving[2] - 1] += 1",
      "mutated_line": "loads[moving[-2] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[-2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[1] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[-1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[-1] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "loads[moving[0] - 1] += 1",
      "mutated_line": "loads[moving[1] - 1] += 1",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[1] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[2] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[2] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[0] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[0] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[0] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[0] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[-1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[-1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[3] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[3] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[1] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[1] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[0] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[0] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[1] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[1] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[-2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[-2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-2 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-2 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-0 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-0 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-0 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-0 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (--1 if moving[2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (--1 if moving[2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[3] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[3] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[1] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[1] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[0] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[0] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[1] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[1] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[-2] == moving[1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[-2] == moving[1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[2] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[2] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[0] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[0] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[0] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[0] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[1] else 0):",
      "mutated_line": "if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[-1] else 0):",
      "code": "from collections import deque\nimport random\n\ndef determine_replication_order(n, rules):\n    loads = [4] * n\n    indexed_rules = [(a, b, c, i + 1) for (i, (a, b, c)) in enumerate(rules)]\n    random.shuffle(indexed_rules)\n    to_use = deque(indexed_rules)\n    order = []\n    res = True\n    ba = 0\n    while to_use and res:\n        moving = to_use.popleft()\n        loads[moving[0] - 1] -= 1\n        if loads[moving[1] - 1] < 9 and loads[moving[2] - 1] < 9 + (-1 if moving[2] == moving[-1] else 0):\n            ba = 0\n            loads[moving[1] - 1] += 1\n            loads[moving[2] - 1] += 1\n            order.append(moving[3])\n        else:\n            ba += 1\n            loads[moving[0] - 1] += 1\n            to_use.append(moving)\n        if ba > n * 12:\n            res = False\n    if not res:\n        return 'NO'\n    else:\n        return ('YES', order)"
    }
  ]
}