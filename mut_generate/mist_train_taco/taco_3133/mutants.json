{
  "task_id": "taco_3133",
  "entry_point": "are_nodes_in_same_scc",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] / num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] + num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] ** num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [0] / v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] / v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [0] + v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] + v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [0] ** v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] ** v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[0] -= 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] -= 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 * 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 * 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 + 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 + 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "k = [1]",
      "mutated_line": "k = [2]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [2]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "k = [1]",
      "mutated_line": "k = [0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [0]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "k = [1]",
      "mutated_line": "k = [0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [0]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "k = [1]",
      "mutated_line": "k = [-1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [-1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "order[v] = 1",
      "mutated_line": "order[v] = 2",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 2\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "order[v] = 1",
      "mutated_line": "order[v] = 0",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 0\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "order[v] = 1",
      "mutated_line": "order[v] = 0",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 0\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "order[v] = 1",
      "mutated_line": "order[v] = -1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = -1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[0] += 2",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 2\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[0] += 0",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 0\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[0] += 0",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 0\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[0] += -1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += -1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "order[v] = 0",
      "mutated_line": "order[v] = 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 1\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "order[v] = 0",
      "mutated_line": "order[v] = -1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = -1\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "order[v] = 0",
      "mutated_line": "order[v] = 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 1\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] - [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] - [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] * [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] * [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [1] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [-1] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "group = [0] * num_nodes",
      "mutated_line": "for (i, component) in enumerate(scc):",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [1] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(11 ** 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(11 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(9 ** 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(9 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(0 ** 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(0 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(1 ** 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(1 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(-10 ** 7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(-10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 8)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 8)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 6)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 6)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 0)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 0)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 1)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 1)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** -7)",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** -7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [1] * v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [1] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [-1] * v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [-1] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "order = [0] * v_count",
      "mutated_line": "order = [1] * v_count",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [1] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "order[v] = k[0]",
      "mutated_line": "order[v] = k[1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[1]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "order[v] = k[0]",
      "mutated_line": "order[v] = k[-1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[-1]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "order[v] = k[0]",
      "mutated_line": "order[v] = k[1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[1]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[1] += 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[1] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[-1] += 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[-1] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k[0] += 1",
      "mutated_line": "k[1] += 1",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[1] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "[None for v in range(v_count) if order[v] == 0 and get_order(v)]",
      "mutated_line": "[None for v in range(v_count) if order[v] == 0 or get_order(v)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 or get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] >= 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] >= 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] <= 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] <= 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] != 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] != 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "result.append('1' if group[u] == group[v] else '0')",
      "mutated_line": "result.append('1' if group[u] != group[v] else '0')",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] != group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result.append('1' if group[u] == group[v] else '0')",
      "mutated_line": "result.append('' if group[u] == group[v] else '0')",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "result.append('1' if group[u] == group[v] else '0')",
      "mutated_line": "result.append('1' if group[u] == group[v] else '')",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '')\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "[None for dest in edges[v] if order[dest] == 0 and get_order(dest)]",
      "mutated_line": "[None for dest in edges[v] if order[dest] == 0 or get_order(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 or get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "[None for v in range(v_count) if order[v] == 0 and get_order(v)]",
      "mutated_line": "[None for v in range(v_count) if order[v] != 0 and get_order(v)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] != 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 1]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > -1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > -1]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 1]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 1]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "[None for dest in edges[v] if order[dest] == 0 and get_order(dest)]",
      "mutated_line": "[None for dest in edges[v] if order[dest] != 0 and get_order(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] != 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] >= 0 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] >= 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] <= 0 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] <= 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] != 0 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] != 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[None for v in range(v_count) if order[v] == 0 and get_order(v)]",
      "mutated_line": "[None for v in range(v_count) if order[v] == 1 and get_order(v)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 1 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[None for v in range(v_count) if order[v] == 0 and get_order(v)]",
      "mutated_line": "[None for v in range(v_count) if order[v] == -1 and get_order(v)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == -1 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[None for v in range(v_count) if order[v] == 0 and get_order(v)]",
      "mutated_line": "[None for v in range(v_count) if order[v] == 1 and get_order(v)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 1 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=False) if order[v] > 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=False) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "[None for dest in edges[v] if order[dest] == 0 and get_order(dest)]",
      "mutated_line": "[None for dest in edges[v] if order[dest] == 1 and get_order(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 1 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "[None for dest in edges[v] if order[dest] == 0 and get_order(dest)]",
      "mutated_line": "[None for dest in edges[v] if order[dest] == -1 and get_order(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == -1 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "[None for dest in edges[v] if order[dest] == 0 and get_order(dest)]",
      "mutated_line": "[None for dest in edges[v] if order[dest] == 1 and get_order(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 1 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 1 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 1 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > -1 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > -1 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]",
      "mutated_line": "return [v] + [_v for dest in reverse_edges[v] if order[dest] > 1 for _v in get_components(dest)]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 1 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[2], reverse=True) if order[v] > 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[2], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[0], reverse=True) if order[v] > 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[0], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[0], reverse=True) if order[v] > 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[0], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[1], reverse=True) if order[v] > 0]",
      "mutated_line": "return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[-1], reverse=True) if order[v] > 0]",
      "code": "def are_nodes_in_same_scc(num_nodes, edges, queries):\n\n    def kosaraju(edges, reverse_edges):\n        import sys\n        sys.setrecursionlimit(10 ** 7)\n        v_count = len(edges)\n        order = [0] * v_count\n        k = [1]\n\n        def get_order(v):\n            order[v] = 1\n            [None for dest in edges[v] if order[dest] == 0 and get_order(dest)]\n            order[v] = k[0]\n            k[0] += 1\n\n        def get_components(v):\n            order[v] = 0\n            return [v] + [_v for dest in reverse_edges[v] if order[dest] > 0 for _v in get_components(dest)]\n        [None for v in range(v_count) if order[v] == 0 and get_order(v)]\n        return [get_components(v) for (v, _) in sorted(enumerate(order), key=lambda x: x[-1], reverse=True) if order[v] > 0]\n    adj_list = [[] for _ in range(num_nodes)]\n    reverse_adj_list = [[] for _ in range(num_nodes)]\n    for (a, b) in edges:\n        adj_list[a].append(b)\n        reverse_adj_list[b].append(a)\n    scc = kosaraju(adj_list, reverse_adj_list)\n    group = [0] * num_nodes\n    for (i, component) in enumerate(scc):\n        for node in component:\n            group[node] = i\n    result = []\n    for (u, v) in queries:\n        result.append('1' if group[u] == group[v] else '0')\n    return result"
    }
  ]
}