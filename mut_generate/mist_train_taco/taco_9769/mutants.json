{
  "task_id": "taco_9769",
  "entry_point": "maximize_balanced_cities",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = n - len(odds)",
      "mutated_line": "ans = n + len(odds)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n + len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = n - len(odds)",
      "mutated_line": "ans = n * len(odds)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n * len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 2 != 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 != 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) * 2 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) * 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) + 2 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) + 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 2 == 1",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 1\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 2 == -1",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == -1\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 2 == 1",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 1\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n - 1, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n - 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n * 1, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n * 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 3 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 3 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 1 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 1 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 0 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 0 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % 1 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 1 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "assert len(odds) % 2 == 0",
      "mutated_line": "assert len(odds) % -2 == 0",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % -2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n - 1)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n - 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n * 1)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n * 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n + 2, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 2, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n + 0, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 0, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n + 0, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 0, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "diredges = eucycle(n + 1, m, adj)",
      "mutated_line": "diredges = eucycle(n + -1, m, adj)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + -1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 or v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 or v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while v1 != u:",
      "mutated_line": "while v1 == u:",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 == u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 2 != 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 != 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n + 2)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 2)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n + 0)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 0)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n + 0)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 0)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[o].add(n + 1)",
      "mutated_line": "adj[o].add(n + -1)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + -1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u == n + 1 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u == n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v == n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v == n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) * 2 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) * 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) + 2 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) + 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 2))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 2))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 0))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 0))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 0))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 0))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 2 == -1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == -1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n - 1].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n - 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n * 1].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n * 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n - 1 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n - 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n * 1 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n * 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n - 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n - 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n * 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n * 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 3 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 3 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 1 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 1 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 0 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 0 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % 1 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 1 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "odds = set((u for u in adj if len(adj[u]) % 2 == 1))",
      "mutated_line": "odds = set((u for u in adj if len(adj[u]) % -2 == 1))",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % -2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n + 2].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 2].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n + 0].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 0].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n + 0].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 0].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "adj[n + 1].add(o)",
      "mutated_line": "adj[n + -1].add(o)",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + -1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 2 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 2 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 0 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 0 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 0 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 0 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + -1 and v != n + 1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + -1 and v != n + 1]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 2]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 2]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 0]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 0]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 0]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 0]\n    return (ans, filtered_diredges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + 1]",
      "mutated_line": "filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + -1]",
      "code": "import collections\n\ndef maximize_balanced_cities(n, m, edges):\n\n    def eucycle(n, m, adj):\n        diredges = []\n        us = list(adj.keys())\n        for u in us:\n            while adj[u]:\n                v0 = u\n                v1 = adj[v0].pop()\n                adj[v1].remove(v0)\n                diredges.append((v0, v1))\n                while v1 != u:\n                    v0 = v1\n                    v1 = adj[v0].pop()\n                    adj[v1].remove(v0)\n                    diredges.append((v0, v1))\n        return diredges\n    adj = collections.defaultdict(set)\n    diredges = []\n    for (u, v) in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    odds = set((u for u in adj if len(adj[u]) % 2 == 1))\n    ans = n - len(odds)\n    assert len(odds) % 2 == 0\n    for o in odds:\n        adj[n + 1].add(o)\n        adj[o].add(n + 1)\n    diredges = eucycle(n + 1, m, adj)\n    filtered_diredges = [(u, v) for (u, v) in diredges if u != n + 1 and v != n + -1]\n    return (ans, filtered_diredges)"
    }
  ]
}