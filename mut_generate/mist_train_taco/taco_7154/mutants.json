{
  "task_id": "taco_7154",
  "entry_point": "calculate_expected_inversion_modulo",
  "mutant_count": 174,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244354\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244352\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 0\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 1\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = -998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 1\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = -1\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 1\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += i - bit.get(p[i])",
      "mutated_line": "ans -= i - bit.get(p[i])",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans -= i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "w = 1",
      "mutated_line": "w = 2",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 2\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "w = 1",
      "mutated_line": "w = 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 0\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "w = 1",
      "mutated_line": "w = 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 0\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "w = 1",
      "mutated_line": "w = -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = -1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "winv = 1",
      "mutated_line": "winv = 2",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 2\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "winv = 1",
      "mutated_line": "winv = 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 0\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "winv = 1",
      "mutated_line": "winv = 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 0\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "winv = 1",
      "mutated_line": "winv = -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = -1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 2, mod) * mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) * mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 2, mod) + mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) + mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x + 1 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x + 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x * 1 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x * 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += i - bit.get(p[i])",
      "mutated_line": "ans += i + bit.get(p[i])",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i + bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += i - bit.get(p[i])",
      "mutated_line": "ans += i * bit.get(p[i])",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i * bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(3, mod - 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(3, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(1, mod - 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(1, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(0, mod - 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(0, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(1, mod - 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(1, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(-2, mod - 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(-2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod + 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod + 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod * 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod * 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) / pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) / pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1 + pow(K, mod - 2, mod)) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1 + pow(K, mod - 2, mod)) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) ** pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) ** pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod + 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod + 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod * 2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod * 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = (lw - up + mod) * mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) * mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = lw - up + mod + mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = lw - up + mod + mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + dif * w * z) * mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) * mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = ans + dif * w * z + mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = ans + dif * w * z + mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i > K - 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i > K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i < K - 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i < K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i == K - 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i == K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [0] / n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] / n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [0] + n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] + n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [0] ** n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] ** n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i < self.n:",
      "mutated_line": "while i <= self.n:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i <= self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i < self.n:",
      "mutated_line": "while i >= self.n:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i >= self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while i < self.n:",
      "mutated_line": "while i != self.n:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i != self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "buf[i] += v",
      "mutated_line": "buf[i] -= v",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] -= v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i -= i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 1\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = -1\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 1\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i > 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i > 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i < 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i < 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i == 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i == 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "res += buf[i]",
      "mutated_line": "res -= buf[i]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res -= buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i += i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - 1) + self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) + self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - 1) * self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) * self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res <= 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res <= 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res >= 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res >= 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res != 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res != 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "res += mod",
      "mutated_line": "res -= mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res -= mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x - 2 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 2 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x - 0 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 0 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x - 0 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 0 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = [x - 1 for x in p]",
      "mutated_line": "p = [x - -1 for x in p]",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - -1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "bit.add(p[i], 1)",
      "mutated_line": "bit.add(p[i], 2)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 2)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "bit.add(p[i], 1)",
      "mutated_line": "bit.add(p[i], 0)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 0)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "bit.add(p[i], 1)",
      "mutated_line": "bit.add(p[i], 0)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 0)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "bit.add(p[i], 1)",
      "mutated_line": "bit.add(p[i], -1)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], -1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod - 3, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 3, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod - 1, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 1, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod - 0, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 0, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod - 1, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 1, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "z = pow(2, mod - 2, mod)",
      "mutated_line": "z = pow(2, mod - -2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - -2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K + 1) * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K + 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = K * 1 * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = K * 1 * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod - 3, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 3, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod - 1, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 1, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod - 0, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 0, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod - 1, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 1, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "reminv = pow(rem, mod - 2, mod)",
      "mutated_line": "reminv = pow(rem, mod - -2, mod)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - -2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = (lw - up - mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up - mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = (lw - up) * mod % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up) * mod % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans - dif * w * z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans - dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = ans * (dif * w * z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = ans * (dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K + 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K + 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K * 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K * 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "w = w * rem % mod",
      "mutated_line": "w = w * rem * mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem * mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "w = w * rem % mod",
      "mutated_line": "w = w * rem + mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem + mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "winv = winv * reminv % mod",
      "mutated_line": "winv = winv * reminv * mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "winv = winv * reminv % mod",
      "mutated_line": "winv = winv * reminv + mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv + mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if buf[i] >= mod:",
      "mutated_line": "if buf[i] > mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] > mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if buf[i] >= mod:",
      "mutated_line": "if buf[i] < mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] < mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if buf[i] >= mod:",
      "mutated_line": "if buf[i] == mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] == mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "buf[i] -= mod",
      "mutated_line": "buf[i] += mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] += mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 | -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 | -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 1:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= -1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= -1:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 1:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if res >= mod:",
      "mutated_line": "if res > mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res > mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if res >= mod:",
      "mutated_line": "if res < mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res < mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if res >= mod:",
      "mutated_line": "if res == mod:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res == mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "res -= mod",
      "mutated_line": "res += mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res += mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 | -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 | -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 1:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res < -1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < -1:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 1:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 2) * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 2) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 0) * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 0) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 0) * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 0) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - -1) * pow(K, mod - 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - -1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod + 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod + 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod * 2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod * 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = (lw + up + mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw + up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "dif = (lw - up + mod) % mod",
      "mutated_line": "dif = (lw * up + mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw * up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + dif * w / z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w / z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + (dif * w + z)) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + (dif * w + z)) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + (dif * w) ** z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + (dif * w) ** z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K - 2:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 2:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K - 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 0:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K - 0:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 0:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if i >= K - 1:",
      "mutated_line": "if i >= K - -1:",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - -1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "w = w * rem % mod",
      "mutated_line": "w = w / rem % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w / rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "w = w * rem % mod",
      "mutated_line": "w = (w + rem) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = (w + rem) % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "w = w * rem % mod",
      "mutated_line": "w = w ** rem % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w ** rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "winv = winv * reminv % mod",
      "mutated_line": "winv = winv / reminv % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv / reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "winv = winv * reminv % mod",
      "mutated_line": "winv = (winv + reminv) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = (winv + reminv) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "winv = winv * reminv % mod",
      "mutated_line": "winv = winv ** reminv % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv ** reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [1] * n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [1] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [-1] * n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [-1] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.buf = [0] * n",
      "mutated_line": "self.buf = [1] * n",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [1] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i - 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i - 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i * 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i * 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i + 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i + 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i * 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i * 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i - 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i - 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i * 1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i * 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i + 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i + 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i * 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i * 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e + 1) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e + 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e * 1) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e * 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 3, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 3, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 1, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 1, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 0, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 0, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - 1, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 1, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "rem = (K - 1) * pow(K, mod - 2, mod) % mod",
      "mutated_line": "rem = (K - 1) * pow(K, mod - -2, mod) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - -2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + dif / w * z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif / w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + (dif + w) * z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + (dif + w) * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = (ans + dif * w * z) % mod",
      "mutated_line": "ans = (ans + dif ** w * z) % mod",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif ** w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 2 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 2 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 0 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 0 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 0 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 0 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + -1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + -1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & +i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & +i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i - 2",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 2\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i - 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 0\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i - 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 0\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i += i + 1 & -i - 1",
      "mutated_line": "i += i + 1 & -i - -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - -1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 2 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 2 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 0 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 0 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 0 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 0 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + -1 & -i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + -1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & +i - 1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & +i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i - 2",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 2\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i - 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 0\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i - 0",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 0\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i -= i + 1 & -i - 1",
      "mutated_line": "i -= i + 1 & -i - -1",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - -1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - 2) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 2) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - 0) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 0) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - 0) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - 0) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = self.get(e - 1) - self.get(b)",
      "mutated_line": "res = self.get(e - -1) - self.get(b)",
      "code": "def calculate_expected_inversion_modulo(N, K, p):\n    mod = 998244353\n\n    class BIT:\n\n        def __init__(self, n):\n            self.n = n\n            self.buf = [0] * n\n\n        def add(self, i, v):\n            buf = self.buf\n            while i < self.n:\n                buf[i] += v\n                if buf[i] >= mod:\n                    buf[i] -= mod\n                i += i + 1 & -i - 1\n\n        def get(self, i):\n            buf = self.buf\n            res = 0\n            while i >= 0:\n                res += buf[i]\n                if res >= mod:\n                    res -= mod\n                i -= i + 1 & -i - 1\n            return res\n\n        def rng(self, b, e):\n            res = self.get(e - -1) - self.get(b)\n            if res < 0:\n                res += mod\n            return res\n    p = [x - 1 for x in p]\n    ans = 0\n    bit = BIT(N)\n    for i in range(N):\n        ans += i - bit.get(p[i])\n        bit.add(p[i], 1)\n    z = pow(2, mod - 2, mod)\n    w = 1\n    winv = 1\n    rem = (K - 1) * pow(K, mod - 2, mod) % mod\n    reminv = pow(rem, mod - 2, mod)\n    bit = BIT(N)\n    for i in range(N):\n        lw = bit.get(p[i])\n        up = bit.rng(p[i], N)\n        dif = (lw - up + mod) % mod\n        ans = (ans + dif * w * z) % mod\n        bit.add(p[i], winv)\n        if i >= K - 1:\n            w = w * rem % mod\n            winv = winv * reminv % mod\n    return ans"
    }
  ]
}