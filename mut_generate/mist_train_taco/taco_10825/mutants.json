{
  "task_id": "taco_10825",
  "entry_point": "determine_candidate_outcomes",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "votes[cand] += 1",
      "mutated_line": "votes[cand] -= 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] -= 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "__slots__ = ['candidate', 'votes', 'last_vote']",
      "mutated_line": "__slots__ = ['', 'votes', 'last_vote']",
      "code": "class State:\n    __slots__ = ['', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "__slots__ = ['candidate', 'votes', 'last_vote']",
      "mutated_line": "__slots__ = ['candidate', '', 'last_vote']",
      "code": "class State:\n    __slots__ = ['candidate', '', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "__slots__ = ['candidate', 'votes', 'last_vote']",
      "mutated_line": "__slots__ = ['candidate', 'votes', '']",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', '']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.votes + extra > other.votes",
      "mutated_line": "return self.votes + extra >= other.votes",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra >= other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.votes + extra > other.votes",
      "mutated_line": "return self.votes + extra <= other.votes",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra <= other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.votes + extra > other.votes",
      "mutated_line": "return self.votes + extra != other.votes",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra != other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "votes = [0 for _ in range(n)]",
      "mutated_line": "votes = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [1 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "votes = [0 for _ in range(n)]",
      "mutated_line": "votes = [-1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [-1 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "votes = [0 for _ in range(n)]",
      "mutated_line": "votes = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [1 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_vote = [0 for _ in range(n)]",
      "mutated_line": "last_vote = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [1 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_vote = [0 for _ in range(n)]",
      "mutated_line": "last_vote = [-1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [-1 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_vote = [0 for _ in range(n)]",
      "mutated_line": "last_vote = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [1 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] + 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] + 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] * 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] * 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "votes[cand] += 1",
      "mutated_line": "votes[cand] += 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 2\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "votes[cand] += 1",
      "mutated_line": "votes[cand] += 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 0\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "votes[cand] += 1",
      "mutated_line": "votes[cand] += 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 0\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "votes[cand] += 1",
      "mutated_line": "votes[cand] += -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += -1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res = [0 for _ in range(n)]",
      "mutated_line": "res = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [1 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res = [0 for _ in range(n)]",
      "mutated_line": "res = [-1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [-1 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res = [0 for _ in range(n)]",
      "mutated_line": "res = [1 for _ in range(n)]",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [1 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i < n - k:",
      "mutated_line": "if i <= n - k:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i <= n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i < n - k:",
      "mutated_line": "if i >= n - k:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i >= n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i < n - k:",
      "mutated_line": "if i != n - k:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i != n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return self.votes + extra > other.votes",
      "mutated_line": "return self.votes - extra > other.votes",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes - extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return self.votes + extra > other.votes",
      "mutated_line": "return self.votes * extra > other.votes",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes * extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] - 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 2\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] - 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 0\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] - 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 0\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cand = votes_cast[t] - 1",
      "mutated_line": "cand = votes_cast[t] - -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - -1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i < n - k:",
      "mutated_line": "if i < n + k:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n + k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i < n - k:",
      "mutated_line": "if i < n * k:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n * k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "low = n - k",
      "mutated_line": "low = n + k",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n + k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "low = n - k",
      "mutated_line": "low = n * k",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n * k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "extra = m - a",
      "mutated_line": "extra = m + a",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m + a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "extra = m - a",
      "mutated_line": "extra = m * a",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m * a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i + 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i + 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i * 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i * 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 0 or states[i].votes == 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 or states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 or extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 or extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if states[i].beats(states[low], m - a):",
      "mutated_line": "if states[i].beats(states[low], m + a):",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m + a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if states[i].beats(states[low], m - a):",
      "mutated_line": "if states[i].beats(states[low], m * a):",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m * a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res[states[i].candidate] = 2",
      "mutated_line": "res[states[i].candidate] = 3",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 3\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res[states[i].candidate] = 2",
      "mutated_line": "res[states[i].candidate] = 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 1\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res[states[i].candidate] = 2",
      "mutated_line": "res[states[i].candidate] = 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 0\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res[states[i].candidate] = 2",
      "mutated_line": "res[states[i].candidate] = 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 1\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res[states[i].candidate] = 2",
      "mutated_line": "res[states[i].candidate] = -2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = -2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 4",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 4\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 2\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 0\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 1\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = -3",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = -3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i - 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 2\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i - 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 0\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i - 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 0\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "other = i - 1",
      "mutated_line": "other = i - -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - -1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra != 0 and states[i].votes == 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra != 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 0 and states[i].votes != 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes != 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 4",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 4\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 2\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 0\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 1\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res[states[i].candidate] = 3",
      "mutated_line": "res[states[i].candidate] = -3",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = -3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other > 0 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other > 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other < 0 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other < 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other == 0 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other == 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra >= 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra >= 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra <= 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra <= 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra != 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra != 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes - states[other].votes - 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes - 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = (states[i].votes - states[other].votes) * 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = (states[i].votes - states[other].votes) * 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if needed <= extra:",
      "mutated_line": "if needed < extra:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed < extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if needed <= extra:",
      "mutated_line": "if needed > extra:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed > extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if needed <= extra:",
      "mutated_line": "if needed == extra:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed == extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "extra -= needed",
      "mutated_line": "extra += needed",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra += needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "place -= 1",
      "mutated_line": "place += 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place += 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "other -= 1",
      "mutated_line": "other += 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other += 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n or states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n or states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 2 if place + k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 2 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 0 if place + k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 0 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 0 if place + k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 0 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = -1 if place + k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = -1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 3",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 3\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 0\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else -2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else -2\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "states = sorted(states, key=lambda x: (x.votes, -x.last_vote))",
      "mutated_line": "states = sorted(states, key=lambda x: (x.votes, +x.last_vote))",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, +x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 1 and states[i].votes == 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 1 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == -1 and states[i].votes == 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == -1 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 1 and states[i].votes == 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 1 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 0 and states[i].votes == 1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 1:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 0 and states[i].votes == -1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == -1:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if extra == 0 and states[i].votes == 0:",
      "mutated_line": "if extra == 0 and states[i].votes == 1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 1:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 1 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 1 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= -1 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= -1 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 1 and extra > 0:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 1 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra > 1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 1:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra > -1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > -1:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while other >= 0 and extra > 0:",
      "mutated_line": "while other >= 0 and extra > 1:",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 1:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes + states[other].votes + 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes + states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes * states[other].votes + 1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes * states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes - states[other].votes + 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 2\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes - states[other].votes + 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 0\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes - states[other].votes + 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 0\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "needed = states[i].votes - states[other].votes + 1",
      "mutated_line": "needed = states[i].votes - states[other].votes + -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + -1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "place -= 1",
      "mutated_line": "place -= 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 2\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "place -= 1",
      "mutated_line": "place -= 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 0\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "place -= 1",
      "mutated_line": "place -= 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 0\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "place -= 1",
      "mutated_line": "place -= -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= -1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "other -= 1",
      "mutated_line": "other -= 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 2\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "other -= 1",
      "mutated_line": "other -= 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 0\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "other -= 1",
      "mutated_line": "other -= 0",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 0\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "other -= 1",
      "mutated_line": "other -= -1",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= -1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k > n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k > n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k < n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k < n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k == n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k == n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes >= 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes >= 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes <= 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes <= 0 else 2\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes != 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes != 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place - k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place - k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place * k >= n and states[i].votes > 0 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place * k >= n and states[i].votes > 0 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 1 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 1 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > -1 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > -1 else 2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 0 else 2",
      "mutated_line": "res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 1 else 2",
      "code": "class State:\n    __slots__ = ['candidate', 'votes', 'last_vote']\n\n    def __init__(self, cand, votes, last):\n        self.candidate = cand\n        self.votes = votes\n        self.last_vote = last\n\n    def beats(self, other, extra):\n        return self.votes + extra > other.votes\n\ndef determine_candidate_outcomes(n, k, m, a, votes_cast):\n    votes = [0 for _ in range(n)]\n    last_vote = [0 for _ in range(n)]\n    for t in range(a):\n        cand = votes_cast[t] - 1\n        votes[cand] += 1\n        last_vote[cand] = t\n    states = [State(i, votes[i], last_vote[i]) for i in range(n)]\n    states = sorted(states, key=lambda x: (x.votes, -x.last_vote))\n    res = [0 for _ in range(n)]\n    for i in range(n):\n        if i < n - k:\n            low = n - k\n            if states[i].beats(states[low], m - a):\n                res[states[i].candidate] = 2\n            else:\n                res[states[i].candidate] = 3\n        else:\n            extra = m - a\n            other = i - 1\n            place = i\n            if extra == 0 and states[i].votes == 0:\n                res[states[i].candidate] = 3\n                continue\n            while other >= 0 and extra > 0:\n                needed = states[i].votes - states[other].votes + 1\n                if needed <= extra:\n                    extra -= needed\n                    place -= 1\n                    other -= 1\n                else:\n                    break\n            res[states[i].candidate] = 1 if place + k >= n and states[i].votes > 1 else 2\n    return res"
    }
  ]
}