{
  "task_id": "taco_13498",
  "entry_point": "count_valid_edge_sets",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244354\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244352\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 0\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 1\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = -998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) * mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) * mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) + mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) + mod"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "parent = [-1 for _ in range(n)]",
      "mutated_line": "parent = [+1 for _ in range(n)]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [+1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b + 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b * 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b * 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a + 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a * 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a * 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [-1 for _ in range(n)]",
      "mutated_line": "parent = [-2 for _ in range(n)]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-2 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [-1 for _ in range(n)]",
      "mutated_line": "parent = [-0 for _ in range(n)]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-0 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [-1 for _ in range(n)]",
      "mutated_line": "parent = [-0 for _ in range(n)]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-0 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [-1 for _ in range(n)]",
      "mutated_line": "parent = [--1 for _ in range(n)]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [--1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "deq = deque([0])",
      "mutated_line": "deq = deque([1])",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([1])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "deq = deque([0])",
      "mutated_line": "deq = deque([-1])",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([-1])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "deq = deque([0])",
      "mutated_line": "deq = deque([1])",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([1])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if nv != parent[v]:",
      "mutated_line": "if nv == parent[v]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv == parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[1] for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[2] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[1] for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[0] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[1] for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[0] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [[1] for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[-1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [-1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [-1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [1 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "res_dp[i] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[i] -= dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] -= dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "for v in res[::-1]:",
      "mutated_line": "for v in res[::+1]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::+1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if nv == parent[v]:",
      "mutated_line": "if nv != parent[v]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv != parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 2)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 2)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 0)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 0)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 0)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 0)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - -1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - -1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 2)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 2)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 0)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 0)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 0)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 0)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - -1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - -1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 1 + i < k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i < k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 1 + i > k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i > k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 1 + i == k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i == k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 1, i)] -= dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] -= dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "res_dp[i] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[i] += dp[v][i] / dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] / dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "res_dp[i] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[i] += dp[v][i] + dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] + dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "res_dp[i] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[i] += dp[v][i] ** dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] ** dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in res[::-1]:",
      "mutated_line": "for v in res[::-2]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-2]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in res[::-1]:",
      "mutated_line": "for v in res[::-0]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-0]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in res[::-1]:",
      "mutated_line": "for v in res[::-0]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-0]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for v in res[::-1]:",
      "mutated_line": "for v in res[::--1]:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::--1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a + 1].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a + 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a * 1].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a * 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b + 1].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b + 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b * 1].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b * 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 1 - i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 - i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if (j + 1) * i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if (j + 1) * i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 1, i)] += dp[v][i] / dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] / dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 1, i)] += dp[v][i] + dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] + dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 1, i)] += dp[v][i] ** dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] ** dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 2].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 2].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 0].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 0].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 0].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 0].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - -1].append(b - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - -1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 2].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 2].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 0].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 0].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 0].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 0].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - -1].append(a - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - -1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) - 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) - 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) * 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) * 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j - 1 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j - 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j * 1 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j * 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[1][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[1][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[-1][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[-1][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[1][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[1][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 2))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 2))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 0))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 0))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 0))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 0))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]",
      "mutated_line": "res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + -1))]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + -1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 2 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 2 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 0 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 0 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + 0 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 0 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if j + 1 + i <= k:",
      "mutated_line": "if j + -1 + i <= k:",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + -1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j - 1, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j - 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j * 1, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j * 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j - 1, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j - 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j * 1, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j * 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k - 1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k - 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k * 1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k * 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 2, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 2, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 0, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 0, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + 0, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 0, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]",
      "mutated_line": "res_dp[max(j + -1, i)] += dp[v][i] * dp[nv][j]",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + -1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j + 2, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 2, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j + 0, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 0, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j + 0, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 0, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res_dp[max(j + 1, i)] %= mod",
      "mutated_line": "res_dp[max(j + -1, i)] %= mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + -1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 2, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 2, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 0, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 0, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 0, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 0, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + -1, len(dp[0]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + -1, len(dp[0]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[1]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[1]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[-1]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[-1]))))) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[0]))))) % mod",
      "mutated_line": "return sum((dp[0][i] for i in range(min(k + 1, len(dp[1]))))) % mod",
      "code": "import sys\nfrom collections import deque\n\ndef count_valid_edge_sets(n, k, edges):\n    mod = 998244353\n    edge = [[] for _ in range(n)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    parent = [-1 for _ in range(n)]\n    deq = deque([0])\n    res = []\n    while deq:\n        v = deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv != parent[v]:\n                parent[nv] = v\n                deq.append(nv)\n    dp = [[1] for _ in range(n)]\n\n    def merge(v, nv):\n        res_dp = [0 for _ in range(max(len(dp[v]), len(dp[nv]) + 1))]\n        for i in range(len(dp[v])):\n            for j in range(len(dp[nv])):\n                if j + 1 + i <= k:\n                    res_dp[max(j + 1, i)] += dp[v][i] * dp[nv][j]\n                    res_dp[max(j + 1, i)] %= mod\n                res_dp[i] += dp[v][i] * dp[nv][j]\n                res_dp[i] %= mod\n        dp[v] = res_dp\n    for v in res[::-1]:\n        for nv in edge[v]:\n            if nv == parent[v]:\n                continue\n            merge(v, nv)\n    return sum((dp[0][i] for i in range(min(k + 1, len(dp[1]))))) % mod"
    }
  ]
}