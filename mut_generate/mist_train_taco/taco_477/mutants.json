{
  "task_id": "taco_477",
  "entry_point": "count_beautiful_segments",
  "mutant_count": 173,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "prev_under = True",
      "mutated_line": "prev_under = False",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = False\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "this_under = False",
      "mutated_line": "this_under = True",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = True\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ugly = 0",
      "mutated_line": "ugly = 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 1\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ugly = 0",
      "mutated_line": "ugly = -1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = -1\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ugly = 0",
      "mutated_line": "ugly = 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 1\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 1, r) < x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) < x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 1, r) > x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) > x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 1, r) == x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) == x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() + 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() + 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() * 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() * 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end - 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end - 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end * 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end * 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "this_under = A[i] <= x",
      "mutated_line": "this_under = A[i] < x",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] < x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "this_under = A[i] <= x",
      "mutated_line": "this_under = A[i] > x",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] > x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "this_under = A[i] <= x",
      "mutated_line": "this_under = A[i] == x",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] == x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if this_under != prev_under:",
      "mutated_line": "if this_under == prev_under:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under == prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) * 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) * 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) // 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) // 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l + 1, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l + 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l * 1, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l * 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r + 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r + 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r * 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r * 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if sl == sr:",
      "mutated_line": "if sl != sr:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl != sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "ugly += 1",
      "mutated_line": "ugly -= 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly -= 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(segcount - ugly)",
      "mutated_line": "results.append(segcount + ugly)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount + ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(segcount - ugly)",
      "mutated_line": "results.append(segcount * ugly)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount * ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i - 2 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i - 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i * 2 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i * 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if j < n:",
      "mutated_line": "if j <= n:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j <= n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if j < n:",
      "mutated_line": "if j >= n:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j >= n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if j < n:",
      "mutated_line": "if j != n:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j != n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() - 2",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 2\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() - 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 0\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() - 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 0\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop - start).bit_length() - -1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - -1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end + 2):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 2):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 0):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 0):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(start, end + 1):",
      "mutated_line": "for i in range(start, end + -1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + -1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) / (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) / (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1 + (r - l + 2)) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1 + (r - l + 2)) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) ** (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) ** (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) / 3)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 3)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) / 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 1)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) / 0)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 0)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) / 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 1)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 2) / -2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / -2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l + 1, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l + 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l * 1, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l * 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 2, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 2, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 0, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 0, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 0, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 0, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - -1, r - 1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - -1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r - 2, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 2, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r - 0, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 0, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r - 0, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 0, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "splits = split_segment(l - 1, r - 1, x)",
      "mutated_line": "splits = split_segment(l - 1, r - -1, x)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - -1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 2",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 2\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 0\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 0\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += -1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += -1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr - 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr - 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr * 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr * 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}",
      "mutated_line": "self._rq = rq = {(i, 1): item for (i, item) in enumerate(items)}",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 1): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}",
      "mutated_line": "self._rq = rq = {(i, -1): item for (i, item) in enumerate(items)}",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, -1): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}",
      "mutated_line": "self._rq = rq = {(i, 1): item for (i, item) in enumerate(items)}",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 1): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (step, i) in product(range(1, n.bit_length()), range(n)):",
      "mutated_line": "for (step, i) in product(range(2, n.bit_length()), range(n)):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(2, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (step, i) in product(range(1, n.bit_length()), range(n)):",
      "mutated_line": "for (step, i) in product(range(0, n.bit_length()), range(n)):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(0, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (step, i) in product(range(1, n.bit_length()), range(n)):",
      "mutated_line": "for (step, i) in product(range(0, n.bit_length()), range(n)):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(0, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (step, i) in product(range(1, n.bit_length()), range(n)):",
      "mutated_line": "for (step, i) in product(range(-1, n.bit_length()), range(n)):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(-1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 * (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 * (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + (2 + (step - 1))",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + (2 + (step - 1))\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop + 2 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop + 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop * 2 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop * 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "splits.append(i - int(this_under))",
      "mutated_line": "splits.append(i + int(this_under))",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i + int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "splits.append(i - int(this_under))",
      "mutated_line": "splits.append(i * int(this_under))",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i * int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i - 1]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i - 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i * 1]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i * 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(1, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(1, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(-1, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(-1, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(1, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(1, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) + 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) + 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) * 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) * 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 3)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 3)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 1)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 1)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 0)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 0)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 1)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 1)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, -2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, -2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l - 1) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l - 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l) * 1 * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l) * 1 * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l - 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l - 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * ((r - l) * 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * ((r - l) * 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 2, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 2, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 0, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 0, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - 0, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 0, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if rqmax.query(l - 1, r) <= x:",
      "mutated_line": "if rqmax.query(l - -1, r) <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - -1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr + 2):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 2):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 0):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 0):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "for li in range(sl, sr + 1):",
      "mutated_line": "for li in range(sl, sr + -1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + -1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr - 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr - 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr * 1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr * 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if result > x:",
      "mutated_line": "if result >= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result >= x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if result > x:",
      "mutated_line": "if result <= x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result <= x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if result > x:",
      "mutated_line": "if result != x:",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result != x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ugly += 1",
      "mutated_line": "ugly -= 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly -= 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 3 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 3 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 1 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 1 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 0 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 0 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 1 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 1 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + -2 ** (step - 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + -2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step + 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step + 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step * 1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step * 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop + start).bit_length() - 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop + start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "j = (stop - start).bit_length() - 1",
      "mutated_line": "j = (stop * start).bit_length() - 1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop * start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - 2 * j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 * j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - (2 + j), j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - (2 + j), j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 2]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 2]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 0]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 0]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 0]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 0]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + -1]] for i in range(0, len(splits) - 1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + -1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 2, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 2, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 0, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 0, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 0, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 0, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]",
      "mutated_line": "parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - -1, 2)]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - -1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r + l + 1) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r + l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r * l + 1) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r * l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 2) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 2) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 0) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 0) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 0) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 0) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + -1) * (r - l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + -1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r + l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r + l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r * l + 2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r * l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 3) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 3) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 1) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 1) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 0) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 0) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + 1) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 1) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "segcount = int((r - l + 1) * (r - l + 2) / 2)",
      "mutated_line": "segcount = int((r - l + 1) * (r - l + -2) / 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + -2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr + 2):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 2):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 0):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr + 0):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 0):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for ri in range(li, sr + 1):",
      "mutated_line": "for ri in range(li, sr + -1):",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + -1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 2",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 2\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 0\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += 0",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 0\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ugly += 1",
      "mutated_line": "ugly += -1",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += -1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step - 2)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 2)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step - 0)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 0)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step - 0)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 0)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "j = i + 2 ** (step - 1)",
      "mutated_line": "j = i + 2 ** (step - -1)",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - -1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step + 1]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step + 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step * 1]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step * 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - 3 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 3 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - 1 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 1 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - 0 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 0 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - 1 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 1 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "y = self._rq[stop - 2 ** j, j]",
      "mutated_line": "y = self._rq[stop - -2 ** j, j]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - -2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step + 1], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step + 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step * 1], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step * 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step + 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step + 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step * 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step * 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step - 2]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 2]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step - 0]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 0]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step - 0]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 0]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rq[i, step] = rq[i, step - 1]",
      "mutated_line": "rq[i, step] = rq[i, step - -1]",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - -1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 2], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 2], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 0], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 0], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 0], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 0], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - -1], rq[j, step - 1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - -1], rq[j, step - 1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 2])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 2])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 0])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 0])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 0])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - 0])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - 1])",
      "mutated_line": "rq[i, step] = fn(rq[i, step - 1], rq[j, step - -1])",
      "code": "def count_beautiful_segments(A, queries):\n    from itertools import product\n\n    class RangeQuery(object):\n\n        def __init__(self, items, fn):\n            self._rq = rq = {(i, 0): item for (i, item) in enumerate(items)}\n            self._fn = fn\n            n = len(items)\n            for (step, i) in product(range(1, n.bit_length()), range(n)):\n                j = i + 2 ** (step - 1)\n                if j < n:\n                    rq[i, step] = fn(rq[i, step - 1], rq[j, step - -1])\n                else:\n                    rq[i, step] = rq[i, step - 1]\n\n        def query(self, start, stop):\n            j = (stop - start).bit_length() - 1\n            x = self._rq[start, j]\n            y = self._rq[stop - 2 ** j, j]\n            return self._fn(x, y)\n\n    def split_segment(start, end, x):\n        prev_under = True\n        splits = []\n        this_under = False\n        for i in range(start, end + 1):\n            this_under = A[i] <= x\n            if this_under != prev_under:\n                splits.append(i - int(this_under))\n                prev_under = this_under\n        if not this_under:\n            splits.append(end)\n        parts = [[splits[i], splits[i + 1]] for i in range(0, len(splits) - 1, 2)]\n        return parts\n    rqmax = RangeQuery(A, max)\n    results = []\n    for (l, r, x) in queries:\n        ugly = 0\n        segcount = int((r - l + 1) * (r - l + 2) / 2)\n        if rqmax.query(l - 1, r) <= x:\n            results.append(segcount)\n            continue\n        splits = split_segment(l - 1, r - 1, x)\n        for (sl, sr) in splits:\n            if sl == sr:\n                ugly += 1\n                continue\n            for li in range(sl, sr + 1):\n                result = A[li]\n                for ri in range(li, sr + 1):\n                    result &= A[ri]\n                    if result > x:\n                        ugly += 1\n                    else:\n                        break\n        results.append(segcount - ugly)\n    return results"
    }
  ]
}