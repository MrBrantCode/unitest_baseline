{
  "task_id": "taco_17916",
  "entry_point": "solve_stone_game",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v or len(queue) > 0:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v or len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if end not in dist:",
      "mutated_line": "return (-1, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while end in path:",
      "mutated_line": "while end not in path:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end not in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (1, 1, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (1, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (-1, 1, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (-1, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (1, 1, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (1, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 2, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 2, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 0, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 0, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 0, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 0, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, -1, 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, -1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 1, 3)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 3)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 1, 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 1)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 1, 0)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 0)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 1, 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 1)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = (0, 1, 2)",
      "mutated_line": "st = (0, 1, -2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, -2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = {st: 0}",
      "mutated_line": "dist = {st: 1}",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 1}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = {st: 0}",
      "mutated_line": "dist = {st: -1}",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: -1}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = {st: 0}",
      "mutated_line": "dist = {st: 1}",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 1}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end in v and len(queue) > 0:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) >= 0:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) >= 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) <= 0:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) <= 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) != 0:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) != 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' - str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' - str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return (str((set(fr) - set(to)).pop() + 1) + ' ') * str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return (str((set(fr) - set(to)).pop() + 1) + ' ') * str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) > 1:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 1:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) > -1:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > -1:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while end not in v and len(queue) > 0:",
      "mutated_line": "while end not in v and len(queue) > 1:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 1:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(+2, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(+2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-2, 2):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 2):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-2, 0):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 0):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-2, 0):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 0):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-2, -1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, -1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) - ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) - ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) * ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) * ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1, []",
      "mutated_line": "return (+1, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (+1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x + 1 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x + 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x * 1 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x * 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-3, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-3, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-1, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-1, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-0, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-0, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(-1, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-1, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for x in range(-2, 1):",
      "mutated_line": "for x in range(--2, 1):",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(--2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:",
      "mutated_line": "if i not in (p1, p2, p3) or color_matrix[i][p3] == color_matrix[p1][p2]:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) or color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + '' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + '' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() - 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() - 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() * 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() * 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1, []",
      "mutated_line": "return (-2, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-2, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1, []",
      "mutated_line": "return (-0, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-0, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1, []",
      "mutated_line": "return (-0, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-0, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1, []",
      "mutated_line": "return (--1, [])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (--1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return min_moves, move_descriptions[::-1]",
      "mutated_line": "return (min_moves, move_descriptions[::+1])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::+1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x - 2 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 2 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x - 0 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 0 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x - 0 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 0 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end = tuple(sorted([x - 1 for x in initial_positions]))",
      "mutated_line": "end = tuple(sorted([x - -1 for x in initial_positions]))",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - -1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x - 1], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x - 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x * 1], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x * 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x - 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x - 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x * 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x * 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:",
      "mutated_line": "if i in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:",
      "mutated_line": "if i not in (p1, p2, p3) and color_matrix[i][p3] != color_matrix[p1][p2]:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] != color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if np not in v:",
      "mutated_line": "if np in v:",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() - 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() - 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() * 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() * 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 2)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 2)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 0)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 0)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 0)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 0)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + -1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + -1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return min_moves, move_descriptions[::-1]",
      "mutated_line": "return (min_moves, move_descriptions[::-2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-2])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return min_moves, move_descriptions[::-1]",
      "mutated_line": "return (min_moves, move_descriptions[::-0])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-0])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return min_moves, move_descriptions[::-1]",
      "mutated_line": "return (min_moves, move_descriptions[::-0])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-0])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return min_moves, move_descriptions[::-1]",
      "mutated_line": "return (min_moves, move_descriptions[::--1])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::--1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 2], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 2], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 0], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 0], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 0], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 0], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + -1], p[x + 2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + -1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 3])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 3])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 1])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 1])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 0])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 0])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 1])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 1])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + 2])",
      "mutated_line": "(p1, p2, p3) = (p[x], p[x + 1], p[x + -2])",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + -2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] - 1",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] - 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] * 1",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] * 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 2) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 2) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 0) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 0) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 0) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 0) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + -1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + -1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] + 2",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 2\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] + 0",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 0\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] + 0",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 0\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[np] = dist[p] + 1",
      "mutated_line": "dist[np] = dist[p] + -1",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + -1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) + set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) + set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) * set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) * set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) + set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) + set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "mutated_line": "return str((set(fr) * set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)",
      "code": "from collections import deque\n\ndef solve_stone_game(n, initial_positions, color_matrix):\n    end = tuple(sorted([x - 1 for x in initial_positions]))\n    st = (0, 1, 2)\n    v = set([st])\n    path = {}\n    dist = {st: 0}\n    queue = deque([st])\n    while end not in v and len(queue) > 0:\n        p = queue.popleft()\n        for x in range(-2, 1):\n            (p1, p2, p3) = (p[x], p[x + 1], p[x + 2])\n            for i in range(n):\n                if i not in (p1, p2, p3) and color_matrix[i][p3] == color_matrix[p1][p2]:\n                    np = tuple(sorted((p1, p2, i)))\n                    if np not in v:\n                        v.add(np)\n                        queue.append(np)\n                        path[np] = p\n                        dist[np] = dist[p] + 1\n\n    def pathinfo(fr, to):\n        return str((set(fr) * set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n    if end not in dist:\n        return (-1, [])\n    min_moves = dist[end]\n    move_descriptions = []\n    while end in path:\n        move_descriptions.append(pathinfo(end, path[end]))\n        end = path[end]\n    return (min_moves, move_descriptions[::-1])"
    }
  ]
}