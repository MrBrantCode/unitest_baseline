{
  "task_id": "taco_9181",
  "entry_point": "min_moves_to_balance_remainders",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 1\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = -1\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 1\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] / 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] + 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] + 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] ** 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] ** 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 3] -= 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] -= 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] != cnt[1] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] != cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] * 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 4\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] * 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 2\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] * 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 0\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] * 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 1\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [0] * -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * -3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 3] += 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 2\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 3] += 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 0\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 3] += 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 0\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 3] += -1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += -1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 1\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return -1\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 1\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(4):",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(4):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(2):",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(2):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(0):",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(0):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(1):",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(1):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(3):",
      "mutated_line": "for i in range(-3):",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(-3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 != n // 3:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 != n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j != 2:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j != 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] -= m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] -= m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count -= m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count -= m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] -= m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] -= m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count -= m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count -= m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [1] * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [1] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [-1] * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [-1] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cnt = [0] * 3",
      "mutated_line": "cnt = [1] * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [1] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] * 3] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] * 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] + 3] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] + 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[1] == cnt[1] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[1] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[-1] == cnt[1] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[-1] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[1] == cnt[1] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[1] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[2] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[2] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[0] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[0] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[0] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[0] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[-1] == cnt[2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[-1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[1] == cnt[3]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[3]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[1] == cnt[1]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[1]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[1] == cnt[0]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[0]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[1] == cnt[1]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[1]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if cnt[0] == cnt[1] == cnt[2]:",
      "mutated_line": "if cnt[0] == cnt[1] == cnt[-2]:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[-2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n / 3:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n / 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n * 3:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n * 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j == 3:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 3:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j == 1:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 1:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j == 0:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 0:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j == 1:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 1:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if j == 2:",
      "mutated_line": "if j == -2:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == -2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 + n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 + n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 * (n // 3)",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 * (n // 3)\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n / 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n * 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 + n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 + n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 * (n // 3)",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 * (n // 3)\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n / 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n * 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 + n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 + n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 * (n // 3)",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 * (n // 3)\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 + n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 + n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 * (n // 3)",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 * (n // 3)\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 4] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 4] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 2] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 2] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 0] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 0] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % 1] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 1] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt[a[i] % 3] += 1",
      "mutated_line": "cnt[a[i] % -3] += 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % -3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n // 4:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 4:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n // 2:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 2:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n // 0:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 0:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n // 1:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 1:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if m1 == n // 3:",
      "mutated_line": "if m1 == n // -3:",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // -3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[1] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[-1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[-1] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[1] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n / 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n * 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[3] = n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[3] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[1] = n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[1] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[0] = n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[0] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[1] = n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[1] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[-2] = n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[-2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 4\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 2\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 0\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 1\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt[2] = n // 3",
      "mutated_line": "cnt[2] = n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // -3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n / 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n * 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 4\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 2\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 0\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 1\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt[j] = n // 3",
      "mutated_line": "cnt[j] = n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // -3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j - 1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j - 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j * 1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j * 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n / 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n * 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n / 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n / 3\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n * 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n * 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 4\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 2\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 0\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 1\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cnt[0] += m1 - n // 3",
      "mutated_line": "cnt[0] += m1 - n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // -3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 4\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 2\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 0\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 1\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // -3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 2] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 2] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 0] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 0] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 0] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 0] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + -1] += m1 - n // 3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + -1] += m1 - n // 3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 4\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 2\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 0\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 1\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt[j + 1] += m1 - n // 3",
      "mutated_line": "cnt[j + 1] += m1 - n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // -3\n            count += m1 - n // 3\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 4",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 4\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 2",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 0",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // 1",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += m1 - n // 3",
      "mutated_line": "count += m1 - n // -3",
      "code": "def min_moves_to_balance_remainders(n, a):\n    \"\"\"\n    Calculate the minimum number of moves required to balance the remainders of the array elements when divided by 3.\n\n    Parameters:\n    n (int): The length of the array, which is divisible by 3.\n    a (list of int): The array of integers.\n\n    Returns:\n    int: The minimum number of moves required to balance the remainders.\n    \"\"\"\n    count = 0\n    cnt = [0] * 3\n    for i in range(n):\n        cnt[a[i] % 3] += 1\n    if cnt[0] == cnt[1] == cnt[2]:\n        return 0\n    for i in range(3):\n        m1 = max(cnt)\n        j = cnt.index(m1)\n        if m1 == n // 3:\n            break\n        if j == 2:\n            cnt[0] += m1 - n // 3\n            cnt[2] = n // 3\n            count += m1 - n // 3\n        else:\n            cnt[j] = n // 3\n            cnt[j + 1] += m1 - n // 3\n            count += m1 - n // -3\n    return count"
    }
  ]
}