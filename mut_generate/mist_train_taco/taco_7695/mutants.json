{
  "task_id": "taco_7695",
  "entry_point": "minimum_additional_marks",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for z in (x, y, y + x):",
      "mutated_line": "for z in (x, y, y - x):",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y - x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for z in (x, y, y + x):",
      "mutated_line": "for z in (x, y, y * x):",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y * x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "a += z",
      "mutated_line": "a -= z",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a -= z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) != 2:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) != 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if x in d and y in d:",
      "mutated_line": "if x in d or y in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d or y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "z = y - x",
      "mutated_line": "z = y + x",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y + x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "z = y - x",
      "mutated_line": "z = y * x",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y * x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "a += z",
      "mutated_line": "a -= z",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a -= z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a > l:",
      "mutated_line": "if a >= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a >= l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a > l:",
      "mutated_line": "if a <= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a <= l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a > l:",
      "mutated_line": "if a != l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a != l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b <= a:",
      "mutated_line": "if b < a:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b < a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b <= a:",
      "mutated_line": "if b > a:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b > a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b <= a:",
      "mutated_line": "if b == a:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) == 3:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 3:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 1:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) == 0:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 0:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) == 1:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 1:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(d) == 2:",
      "mutated_line": "if len(d) == -2:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == -2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if x in d and y in d:",
      "mutated_line": "if x not in d and y in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x not in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if x in d and y in d:",
      "mutated_line": "if x in d and y not in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y not in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif x in d:",
      "mutated_line": "elif x not in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x not in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if a > l:",
      "mutated_line": "if a >= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a >= l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if a > l:",
      "mutated_line": "if a <= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a <= l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if a > l:",
      "mutated_line": "if a != l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a != l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if b == a:",
      "mutated_line": "if b != a:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b != a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a > y:",
      "mutated_line": "if a >= y:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a >= y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a > y:",
      "mutated_line": "if a <= y:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a <= y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if a > y:",
      "mutated_line": "if a != y:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a != y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if b == a:",
      "mutated_line": "if b != a:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b != a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif y in d:",
      "mutated_line": "elif y not in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y not in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif a + x < l:",
      "mutated_line": "elif a + x <= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x <= l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif a + x < l:",
      "mutated_line": "elif a + x >= l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x >= l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif a + x < l:",
      "mutated_line": "elif a + x != l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x != l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif y + x in d:",
      "mutated_line": "elif y + x not in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x not in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = [a - y]",
      "mutated_line": "res = [a + y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a + y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = [a - y]",
      "mutated_line": "res = [a * y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a * y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "elif a + x < l:",
      "mutated_line": "elif a - x < l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a - x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "elif a + x < l:",
      "mutated_line": "elif a * x < l:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a * x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "elif y + x in d:",
      "mutated_line": "elif y - x in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y - x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "elif y + x in d:",
      "mutated_line": "elif y * x in d:",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y * x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = [a + x]",
      "mutated_line": "res = [a - x]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a - x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = [a + x]",
      "mutated_line": "res = [a * x]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a * x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = [d[y + x] - y]",
      "mutated_line": "res = [d[y + x] + y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] + y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = [d[y + x] - y]",
      "mutated_line": "res = [d[y + x] * y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y + x] * y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = [d[y + x] - y]",
      "mutated_line": "res = [d[y - x] - y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y - x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "res = [d[y + x] - y]",
      "mutated_line": "res = [d[y * x] - y]",
      "code": "from bisect import bisect_left\n\ndef minimum_additional_marks(n, l, x, y, marks):\n    d = {}\n    for z in (x, y, y + x):\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b <= a:\n                if b == a:\n                    d[z] = a\n                break\n        if len(d) == 2:\n            break\n    if d:\n        if x in d and y in d:\n            res = []\n        elif x in d:\n            res = [y]\n        elif y in d:\n            res = [x]\n        elif y + x in d:\n            res = [d[y * x] - y]\n    else:\n        z = y - x\n        tmp = []\n        for a in marks:\n            a += z\n            if a > l:\n                break\n            b = marks[bisect_left(marks, a)]\n            if b == a:\n                tmp.append(a)\n        for a in tmp:\n            if a > y:\n                res = [a - y]\n                break\n            elif a + x < l:\n                res = [a + x]\n                break\n        else:\n            res = [x, y]\n    num_additional_marks = len(res)\n    additional_marks = res\n    return (num_additional_marks, additional_marks)"
    }
  ]
}