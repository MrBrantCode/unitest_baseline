{
  "task_id": "taco_6808",
  "entry_point": "calculate_expected_attacks",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 0 or M == 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 or M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N != 0 and M == 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N != 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 0 and M != 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M != 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 1\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return -1\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 1\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if M >= Di:",
      "mutated_line": "if M > Di:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M > Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if M >= Di:",
      "mutated_line": "if M < Di:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M < Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if M >= Di:",
      "mutated_line": "if M == Di:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M == Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "total_expected_attacks -= Di * Pi",
      "mutated_line": "total_expected_attacks += Di * Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks += Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "M -= Di",
      "mutated_line": "M += Di",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M += Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if M == 0:",
      "mutated_line": "if M != 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M != 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 1 and M == 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 1 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == -1 and M == 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == -1 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 1 and M == 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 1 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 0 and M == 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 1:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 0 and M == -1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == -1:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 and M == 0:",
      "mutated_line": "if N == 0 and M == 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 1:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "total_expected_attacks = sum(Di * Pi for Di, Pi in intervals)",
      "mutated_line": "total_expected_attacks = sum((Di / Pi for (Di, Pi) in intervals))",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di / Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "total_expected_attacks = sum(Di * Pi for Di, Pi in intervals)",
      "mutated_line": "total_expected_attacks = sum((Di + Pi for (Di, Pi) in intervals))",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di + Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "total_expected_attacks = sum(Di * Pi for Di, Pi in intervals)",
      "mutated_line": "total_expected_attacks = sum((Di ** Pi for (Di, Pi) in intervals))",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di ** Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=False)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total_expected_attacks -= Di * Pi",
      "mutated_line": "total_expected_attacks -= Di / Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di / Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total_expected_attacks -= Di * Pi",
      "mutated_line": "total_expected_attacks -= Di + Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di + Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "total_expected_attacks -= Di * Pi",
      "mutated_line": "total_expected_attacks -= Di ** Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di ** Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M >= 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M >= 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M <= 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M <= 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M != 0:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M != 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "total_expected_attacks -= M * Pi",
      "mutated_line": "total_expected_attacks += M * Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks += M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if M == 0:",
      "mutated_line": "if M == 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 1:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if M == 0:",
      "mutated_line": "if M == -1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == -1:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if M == 0:",
      "mutated_line": "if M == 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 1:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] * x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] // x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M > 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 1:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M > -1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > -1:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif M > 0:",
      "mutated_line": "elif M > 1:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 1:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "total_expected_attacks -= M * Pi",
      "mutated_line": "total_expected_attacks -= M / Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M / Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "total_expected_attacks -= M * Pi",
      "mutated_line": "total_expected_attacks -= M + Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M + Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "total_expected_attacks -= M * Pi",
      "mutated_line": "total_expected_attacks -= M ** Pi",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M ** Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "M = 0",
      "mutated_line": "M = 1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 1\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "M = 0",
      "mutated_line": "M = -1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = -1\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "M = 0",
      "mutated_line": "M = 1",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 1\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[2] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[0] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[0] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[-1] / x[0], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[1], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[-1], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "intervals.sort(key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "for (Di, Pi) in intervals:",
      "code": "def calculate_expected_attacks(N, M, intervals):\n    if N == 0 and M == 0:\n        return 0\n    total_expected_attacks = sum((Di * Pi for (Di, Pi) in intervals))\n    intervals.sort(key=lambda x: x[1] / x[1], reverse=True)\n    for (Di, Pi) in intervals:\n        if M >= Di:\n            total_expected_attacks -= Di * Pi\n            M -= Di\n        elif M > 0:\n            total_expected_attacks -= M * Pi\n            M = 0\n        if M == 0:\n            break\n    return total_expected_attacks"
    }
  ]
}