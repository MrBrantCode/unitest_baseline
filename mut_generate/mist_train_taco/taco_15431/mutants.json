{
  "task_id": "taco_15431",
  "entry_point": "find_smallest_covering_set_size",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "answer = 1",
      "mutated_line": "answer = 2",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 2\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "answer = 1",
      "mutated_line": "answer = 0",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 0\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "answer = 1",
      "mutated_line": "answer = 0",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 0\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "answer = 1",
      "mutated_line": "answer = -1",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = -1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr = intervals[0]",
      "mutated_line": "curr = intervals[1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[1]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr = intervals[0]",
      "mutated_line": "curr = intervals[-1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[-1]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "curr = intervals[0]",
      "mutated_line": "curr = intervals[1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[1]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(2, len(intervals)):",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(2, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(0, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(0, len(intervals)):",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(0, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, len(intervals)):",
      "mutated_line": "for i in range(-1, len(intervals)):",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(-1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] <= intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] <= intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] >= intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] >= intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] != intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] != intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "answer += 1",
      "mutated_line": "answer -= 1",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer -= 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "answer += 1",
      "mutated_line": "answer += 2",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 2\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "answer += 1",
      "mutated_line": "answer += 0",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 0\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "answer += 1",
      "mutated_line": "answer += 0",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 0\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "answer += 1",
      "mutated_line": "answer += -1",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += -1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[2] < intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[2] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[0] < intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[0] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[0] < intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[0] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[-1] < intervals[i][0]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[-1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] < intervals[i][1]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][1]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] < intervals[i][-1]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][-1]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if curr[1] < intervals[i][0]:",
      "mutated_line": "if curr[1] < intervals[i][1]:",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][1]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[1] = intervals[i][0]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[1] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[-1] = intervals[i][0]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[-1] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[1] = intervals[i][0]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[1] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[0] = intervals[i][1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][1]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[0] = intervals[i][-1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][-1]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "curr[0] = intervals[i][0]",
      "mutated_line": "curr[0] = intervals[i][1]",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][1]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[2] = min(curr[1], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[2] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[0] = min(curr[1], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[0] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[0] = min(curr[1], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[0] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[-1] = min(curr[1], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[-1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[1])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[-1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[-1])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "intervals.sort(key=lambda x: x[0])",
      "mutated_line": "intervals.sort(key=lambda x: x[1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[1])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[2], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[2], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[0], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[0], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[0], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[0], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[-1], intervals[i][1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[-1], intervals[i][1])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[1], intervals[i][2])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][2])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[1], intervals[i][0])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][0])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[1], intervals[i][0])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][0])\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[1] = min(curr[1], intervals[i][1])",
      "mutated_line": "curr[1] = min(curr[1], intervals[i][-1])",
      "code": "def find_smallest_covering_set_size(intervals):\n    intervals.sort(key=lambda x: x[0])\n    curr = intervals[0]\n    answer = 1\n    for i in range(1, len(intervals)):\n        if curr[1] < intervals[i][0]:\n            answer += 1\n            curr = intervals[i]\n        else:\n            curr[0] = intervals[i][0]\n            curr[1] = min(curr[1], intervals[i][-1])\n    return answer"
    }
  ]
}