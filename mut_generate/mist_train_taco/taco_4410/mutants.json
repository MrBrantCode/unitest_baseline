{
  "task_id": "taco_4410",
  "entry_point": "determine_exit_node",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 1\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = -1\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 1\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 1\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = -1\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 1\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "s += x",
      "mutated_line": "s -= x",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s -= x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a != b or s == 0:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b or s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "l += b - a",
      "mutated_line": "l -= b - a",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l -= b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 * h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 * h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 + h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 + h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 1), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 1), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, -1), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, -1), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 1), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 1), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 * (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 * (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 + (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 + (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 1), 1)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 1)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 1), -1)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), -1)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 1), 1)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 1)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l / 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l / 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l + 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l + 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l ** 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l ** 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) / 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) / 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), r + 1 + 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), r + 1 + 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) ** 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) ** 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a == b and s == 0:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a == b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a != b and s != 0:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s != 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l += b - a",
      "mutated_line": "l += b + a",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b + a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l += b - a",
      "mutated_line": "l += b * a",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b * a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('', q, 'Data not sufficient!')[min(l, 2)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, '')[min(l, 2)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, '')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 3)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 3)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 1)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 0)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 1)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 1)]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]",
      "mutated_line": "return ('Game cheated!', q, 'Data not sufficient!')[min(l, -2)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, -2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(3 ** h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(3 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(1 ** h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(1 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(0 ** h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(0 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(1 ** h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(1 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(-2 ** h, 0), (2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(-2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (3 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (3 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (1 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (1 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (0 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (0 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (1 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (1 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (-2 ** (h - 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (-2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h + 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h + 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h * 1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h * 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * (2 * (h - i)), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * (2 * (h - i)), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * (2 + (h - i)), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * (2 + (h - i)), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r - 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r - 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), r * 1 * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), r * 1 * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * (2 * (h - i)))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * (2 * (h - i)))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * (2 + (h - i)))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * (2 + (h - i)))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for ((a, x), (b, _)) in zip(d, d[1:]):",
      "mutated_line": "for ((a, x), (b, _)) in zip(d, d[2:]):",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[2:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for ((a, x), (b, _)) in zip(d, d[1:]):",
      "mutated_line": "for ((a, x), (b, _)) in zip(d, d[0:]):",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[0:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for ((a, x), (b, _)) in zip(d, d[1:]):",
      "mutated_line": "for ((a, x), (b, _)) in zip(d, d[0:]):",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[0:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for ((a, x), (b, _)) in zip(d, d[1:]):",
      "mutated_line": "for ((a, x), (b, _)) in zip(d, d[-1:]):",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[-1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a != b and s == 1:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 1:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a != b and s == -1:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == -1:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a != b and s == 0:",
      "mutated_line": "if a != b and s == 1:",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 1:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 2), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 2), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 0), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 0), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - 0), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 0), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "d = [(2 ** h, 0), (2 ** (h - 1), 0)]",
      "mutated_line": "d = [(2 ** h, 0), (2 ** (h - -1), 0)]",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - -1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 3 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 3 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 1 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 1 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 0 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 0 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 1 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 1 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * -2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * -2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h + i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h + i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h * i), (r + 1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h * i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 2) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 2) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 0) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 0) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 0) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 0) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + -1) * 2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + -1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 3 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 3 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 1 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 1 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 0 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 0 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 1 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 1 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * -2 ** (h - i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * -2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h + i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h + i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))",
      "mutated_line": "(l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h * i))",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h * i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 2), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 2), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 0), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 0), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 0), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 0), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, -1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, -1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, +1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, +1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(1, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(1, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(-1, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(-1, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(1, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(1, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 2), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 2), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 0), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 0), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 0), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 0), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, -1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, -1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, +1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, +1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 2)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 2)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 0)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 0)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 0)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 0)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, -1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, -1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -2)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -2)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -0)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -0)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -0)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -0)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, --1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, --1)], [(0, 1), (l, -1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -2), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -2), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -0), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -0), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -0), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -0), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, -1), (r, 1)]][a])",
      "mutated_line": "d.extend([[(l, 1), (r, -1)], [(0, 1), (l, --1), (r, 1)]][a])",
      "code": "def determine_exit_node(h, q, questions):\n    d = [(2 ** h, 0), (2 ** (h - 1), 0)]\n    for (i, l, r, a) in questions:\n        (l, r) = (l * 2 ** (h - i), (r + 1) * 2 ** (h - i))\n        d.extend([[(l, 1), (r, -1)], [(0, 1), (l, --1), (r, 1)]][a])\n    d.sort()\n    s = 0\n    l = 0\n    q = None\n    for ((a, x), (b, _)) in zip(d, d[1:]):\n        s += x\n        if a != b and s == 0:\n            q = a\n            l += b - a\n    return ('Game cheated!', q, 'Data not sufficient!')[min(l, 2)]"
    }
  ]
}