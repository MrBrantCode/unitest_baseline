{
  "task_id": "taco_2573",
  "entry_point": "find_minimal_goodness_partition",
  "mutant_count": 152,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n != 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] + (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] + (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = (b[-1][0] + b[-2][0]) * (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = (b[-1][0] + b[-2][0]) * (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) + min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) + min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) * min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) * min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [1] / n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] / n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [1] + n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] + n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [1] ** n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] ** n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if min_2 < min_:",
      "mutated_line": "if min_2 <= min_:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 <= min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if min_2 < min_:",
      "mutated_line": "if min_2 >= min_:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 >= min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if min_2 < min_:",
      "mutated_line": "if min_2 != min_:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 != min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 3:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 1:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 0:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 1:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == -2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] - b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] - b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] * b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] * b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] - b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] - b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - b[0][0] * b[1][0]",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - b[0][0] * b[1][0]\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][1]] = 3",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 3\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][1]] = 1",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 1\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][1]] = 0",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 0\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][1]] = 1",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 1\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][1]] = -2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = -2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (1, [1, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (1, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (-1, [1, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (-1, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (1, [1, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (1, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] - b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] - b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] * b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] * b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] - h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] - h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], (b[-1][0] + b[0][0]) * h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], (b[-1][0] + b[0][0]) * h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] - h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] - h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min((b[0][0] + b[1][0]) * h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min((b[0][0] + b[1][0]) * h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] - b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] - b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] * b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] * b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [2] * n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [2] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [0] * n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [0] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [0] * n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [0] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = [1] * n",
      "mutated_line": "ans = [-1] * n",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [-1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [2, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [2, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [0, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [0, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [0, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [0, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [-1, 1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [-1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [1, 2])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 2])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [1, 0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 0])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [1, 0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 0])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return (0, [1, 1])",
      "mutated_line": "return (0, [1, -1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, -1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][1] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][1] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][-1] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][-1] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][1] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][1] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][1] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][1] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][-1] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][-1] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][1] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][1] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][1] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][1] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][-1] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][-1] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][1] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][1] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][1])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][-1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][-1])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][1])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] - b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] - b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] * b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] * b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] - b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] - b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] * b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] * b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][2]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][2]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][0]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][0]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][0]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][0]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[0][-1]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][-1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b = sorted(b, key=lambda x: x[0])",
      "mutated_line": "b = sorted(b, key=lambda x: x[1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[1])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b = sorted(b, key=lambda x: x[0])",
      "mutated_line": "b = sorted(b, key=lambda x: x[-1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[-1])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b = sorted(b, key=lambda x: x[0])",
      "mutated_line": "b = sorted(b, key=lambda x: x[1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[1])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[+1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[+1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[+2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[+2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[1][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[1][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[-1][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[-1][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[1][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[1][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[2][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[0][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[0][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[0][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[0][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[-1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[-1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][-1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][-1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][1] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][-1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][-1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][1], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][1] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][1] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][-1] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][-1] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][1] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][1] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][1])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][-1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][-1])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][1])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][1])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[1][1]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[1][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[-1][1]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[-1][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans[b[0][1]] = 2",
      "mutated_line": "ans[b[1][1]] = 2",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[1][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-2][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-2][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-0][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-0][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-0][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-0][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[--1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[--1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-3][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-3][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-1][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-1][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-0][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-0][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[-1][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-1][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])",
      "mutated_line": "min_ = b[-1][0] + b[--2][0] - (b[0][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[--2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[+1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[+1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[+2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[+2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][-1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][-1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][1] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][-1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][-1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][1] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][1] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][1] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][-1] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][-1] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][1] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][1] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][1] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][1] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][-1] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][-1] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][1] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][1] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[2][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[2][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[0][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[0][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[0][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[0][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[-1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[-1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[3][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[3][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[1][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[0][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[0][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[1][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[1][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[-2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[-2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-2][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-2][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-0][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-0][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-0][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-0][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[--1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[--1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-3][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-3][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-1][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-1][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-0][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-0][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-1][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-1][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[--2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[--2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[+1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[+1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[-1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[-1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[1][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[1][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[1][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[-1][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[-1][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[1][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[1][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[2][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[2][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[0][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[0][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[0][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[0][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[-1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[-1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-2][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-2][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-0][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-0][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[-0][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[-0][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_2 = max(b[-1][0] + b[-2][0], b[-1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "mutated_line": "min_2 = max(b[-1][0] + b[-2][0], b[--1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])",
      "code": "def find_minimal_goodness_partition(n, h, a):\n    \"\"\"\n    Finds the partition of the given sequence that has the minimal possible goodness.\n\n    Parameters:\n    n (int): The number of elements in the sequence.\n    h (int): The non-negative integer value.\n    a (list of int): The sequence of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum possible goodness (int).\n           - The optimal partition as a list of integers (1 or 2).\n    \"\"\"\n    b = [[x, i] for (i, x) in enumerate(a)]\n    b = sorted(b, key=lambda x: x[0])\n    if n == 2:\n        return (0, [1, 1])\n    min_ = b[-1][0] + b[-2][0] - (b[0][0] + b[1][0])\n    min_2 = max(b[-1][0] + b[-2][0], b[--1][0] + b[0][0] + h) - min(b[0][0] + b[1][0] + h, b[1][0] + b[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[b[0][1]] = 2\n    return (min_, ans)"
    }
  ]
}