{
  "task_id": "taco_1888",
  "entry_point": "maximize_university_strength",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "top_k += p",
      "mutated_line": "conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k -= p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) - [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) - [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) * [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) * [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted - [idx for (val, idx) in b_sorted[:p + s - top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted - [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted * [idx for (val, idx) in b_sorted[:p + s - top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted * [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "conversion_gain = [y - x for x, y in zip(a, b)]",
      "mutated_line": "conversion_gain = [y + x for (x, y) in zip(a, b)]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y + x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "conversion_gain = [y - x for x, y in zip(a, b)]",
      "mutated_line": "conversion_gain = [y * x for (x, y) in zip(a, b)]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y * x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "team_a = list(set((idx for val, idx in ordered_by_a[:top_k])) - set(converted))",
      "mutated_line": "team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) + set(converted))",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) + set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "team_a = list(set((idx for val, idx in ordered_by_a[:top_k])) - set(converted))",
      "mutated_line": "team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) * set(converted))",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) * set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res = [0 for i in range(len(ppl_indices))]",
      "mutated_line": "res = [1 for i in range(len(ppl_indices))]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [1 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res = [0 for i in range(len(ppl_indices))]",
      "mutated_line": "res = [-1 for i in range(len(ppl_indices))]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [-1 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res = [0 for i in range(len(ppl_indices))]",
      "mutated_line": "res = [1 for i in range(len(ppl_indices))]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [1 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k >= start:",
      "mutated_line": "if k > start:",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k > start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k >= start:",
      "mutated_line": "if k < start:",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k < start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k >= start:",
      "mutated_line": "if k == start:",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k == start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ordered_by_a = sorted(zip(a, range(n)), reverse=True)",
      "mutated_line": "prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=False)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [1]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [1]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [-1]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [-1]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [1]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [1]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)",
      "mutated_line": "conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=False)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=False)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)",
      "mutated_line": "b_sorted = sorted(b_ordered_by_a[top_k:], reverse=False)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=False)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx - 1 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx - 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx * 1 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx * 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx - 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx - 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx * 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx * 1 for idx in team_b])"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "heappush(Q, -vals[idx])",
      "mutated_line": "heappush(Q, +vals[idx])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, +vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - 1] + heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] + heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - 1] * heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] * heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sol, top_k = max([(prefix_a + convert + add_bs, idx)",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert - add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert - add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sol, top_k = max([(prefix_a + convert + add_bs, idx)",
      "mutated_line": "(sol, top_k) = max([((prefix_a + convert) * add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([((prefix_a + convert) * add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 2 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 2 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 0 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 0 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 0 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 0 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + -1 for idx in team_a], [idx + 1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + -1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx + 2 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 2 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx + 0 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 0 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx + 0 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 0 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b]",
      "mutated_line": "return (sol, [idx + 1 for idx in team_a], [idx + -1 for idx in team_b])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + -1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p + s))) + [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p + s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, (n - p) * s))) + [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, (n - p) * s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sol, top_k = max([(prefix_a + convert + add_bs, idx)",
      "mutated_line": "(sol, top_k) = max([(prefix_a - convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a - convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sol, top_k = max([(prefix_a + convert + add_bs, idx)",
      "mutated_line": "(sol, top_k) = max([(prefix_a * convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a * convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "converted = [idx for val, idx in conversion_sorted[:top_k - p]]",
      "mutated_line": "converted = [idx for (val, idx) in conversion_sorted[:top_k + p]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k + p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "converted = [idx for val, idx in conversion_sorted[:top_k - p]]",
      "mutated_line": "converted = [idx for (val, idx) in conversion_sorted[:top_k * p]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k * p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k + 1] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k + 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k * 1] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k * 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n + p - s))) + [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n + p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "rest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]",
      "mutated_line": "rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n * p - s))) + [0]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n * p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted + [idx for (val, idx) in b_sorted[:p + s + top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s + top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted + [idx for (val, idx) in b_sorted[:(p + s) * top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:(p + s) * top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - 2] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 2] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - 0] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 0] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - 0] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 0] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res[k] = res[k - 1] - heappop(Q)",
      "mutated_line": "res[k] = res[k - -1] - heappop(Q)",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - -1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted + [idx for (val, idx) in b_sorted[:p - s - top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p - s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "team_b = converted + [idx for val, idx in b_sorted[:p + s - top_k]]",
      "mutated_line": "team_b = converted + [idx for (val, idx) in b_sorted[:p * s - top_k]]",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p * s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p + 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p + 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p * 1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p * 1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p - s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p - s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p * s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p * s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p + 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p + 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p * 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p * 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p - s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p - s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p * s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 1:p * s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 2:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 2:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 0:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 0:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 0:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 0:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "in enumerate(zip(prefix_sums_a[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - -1:p + s], conversions[p - 1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - -1:p + s], conversions[p - 1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 2:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 2:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 0:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 0:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 0:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - 0:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "conversions[p - 1:p + s],",
      "mutated_line": "(sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - -1:p + s], rest_of_bs))])",
      "code": "from itertools import accumulate\nfrom heapq import heappop, heappush\n\ndef maximize_university_strength(n, p, s, a, b):\n\n    def top(ppl_indices, vals, start):\n        Q = []\n        res = [0 for i in range(len(ppl_indices))]\n        for (k, idx) in enumerate(ppl_indices):\n            heappush(Q, -vals[idx])\n            if k >= start:\n                res[k] = res[k - 1] - heappop(Q)\n        return res\n    conversion_gain = [y - x for (x, y) in zip(a, b)]\n    ordered_by_a = sorted(zip(a, range(n)), reverse=True)\n    prefix_sums_a = list(accumulate([x for (x, y) in ordered_by_a]))\n    conversions = top([idx for (val, idx) in ordered_by_a], conversion_gain, p)\n    rest_of_bs = list(reversed(top([idx for (val, idx) in reversed(ordered_by_a[p:])], b, n - p - s))) + [0]\n    (sol, top_k) = max([(prefix_a + convert + add_bs, idx) for (idx, (prefix_a, convert, add_bs)) in enumerate(zip(prefix_sums_a[p - 1:p + s], conversions[p - -1:p + s], rest_of_bs))])\n    top_k += p\n    conversion_ordered_by_a = [(conversion_gain[idx], idx) for (val, idx) in ordered_by_a]\n    conversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\n    converted = [idx for (val, idx) in conversion_sorted[:top_k - p]]\n    team_a = list(set((idx for (val, idx) in ordered_by_a[:top_k])) - set(converted))\n    b_ordered_by_a = [(b[idx], idx) for (val, idx) in ordered_by_a]\n    b_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\n    team_b = converted + [idx for (val, idx) in b_sorted[:p + s - top_k]]\n    return (sol, [idx + 1 for idx in team_a], [idx + 1 for idx in team_b])"
    }
  ]
}