{
  "task_id": "taco_12760",
  "entry_point": "arithmetic_progression_concat_remainder",
  "mutant_count": 182,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) * M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) * M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) + M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) + M\n    return X"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k >= 0:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k >= 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k <= 0:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k <= 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k != 0:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k != 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(2, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(2, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(0, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(0, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(0, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(0, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(-1, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(-1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 21):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 21):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 19):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 19):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 0):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 0):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 1):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 1):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, -20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, -20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [1, A, 1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [1, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [-1, A, 1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [-1, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [1, A, 1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [1, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [0, A, 2]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 2]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [0, A, 0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 0]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [0, A, 0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 0]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "R = [0, A, 1]",
      "mutated_line": "R = [0, A, -1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, -1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(2, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(2, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(0, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(0, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(0, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(0, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(-1, 20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(-1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 21):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 21):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 19):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 19):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 0):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 0):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, 1):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 1):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for d in range(1, 20):",
      "mutated_line": "for d in range(1, -20):",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, -20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][1] + D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] + D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][1] * D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] * D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 1:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k > -1:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > -1:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 1:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if k & 1:",
      "mutated_line": "if k | 1:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k | 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 2",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 2\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 0\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 0\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= -1",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= -1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(1, 0)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(1, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(-1, 0)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(-1, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(1, 0)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(1, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(0, 1)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 1)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(0, -1)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, -1)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "D = [(0, 0)]",
      "mutated_line": "D = [(0, 1)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 1)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-1][2]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][2]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-1][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][0]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-1][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][0]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-1][-1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][-1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(1, min((10 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(1, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(-1, min((10 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(-1, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(1, min((10 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(1, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[2, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[2, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[0, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[0, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[0, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[0, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[-1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[-1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 1, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 1, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, -1, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, -1, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 1, 0], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 1, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, -1], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, -1], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 1], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [1, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [1, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [-1, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [-1, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [1, 1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [1, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 2, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 2, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, -1, 0], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, -1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 1], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 1], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, -1], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, -1], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 1], [0, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 1], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [1, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [1, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [-1, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [-1, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [1, 0, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [1, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 1, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 1, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, -1, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, -1, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 1, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 1, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 2]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 2]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 0]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
      "mutated_line": "Mat = [[1, 0, 0], [0, 1, 0], [0, 0, -1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, -1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) * mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) * mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) + mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) + mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 2:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 2:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 0:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 0:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k & 1:",
      "mutated_line": "if k & 0:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 0:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if k & 1:",
      "mutated_line": "if k & -1:",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & -1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[+1][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[+1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B - 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B - 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B * 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B * 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][2] - D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][2] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][0] - D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][0] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][0] - D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][0] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][-1] - D[d][0]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][-1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][1] - D[d][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][1]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][1] - D[d][-1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][-1]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "num = D[d][1] - D[d][0]",
      "mutated_line": "num = D[d][1] - D[d][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][1]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 * d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 * d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 + d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 + d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 1, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 1, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, -1, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, -1, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 1, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 1, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 1], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 1], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, -1], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, -1], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 1], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 1], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [2, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [2, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [0, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [0, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [0, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [0, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [-1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [-1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 2, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 2, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 0, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 0, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 0, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 0, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, -1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, -1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 1], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 1], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, -1], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, -1], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 1], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 1], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [1, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [1, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [-1, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [-1, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [1, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [1, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 2]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 2]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 0]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 0]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 0]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 0]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, -1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, -1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] * M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] * M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] + M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] + M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[1 if i != j else 0 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i != j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[2 if i == j else 0 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[2 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[0 if i == j else 0 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[0 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[0 if i == j else 0 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[0 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[-1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[-1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[1 if i == j else 1 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 1 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[1 if i == j else -1 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else -1 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]",
      "mutated_line": "res = [[1 if i == j else 1 for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 1 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-2][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-2][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-0][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-0][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[-0][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-0][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "l = D[-1][1]",
      "mutated_line": "l = D[--1][1]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[--1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) / B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) / B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) * B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) * B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B + 2, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 2, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B + 0, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 0, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B + 0, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 0, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 - A) // B + -1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + -1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[11 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[11 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[9 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[9 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[0 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[0 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[1 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[1 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "mutated_line": "MM = [[-10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[-10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] / Mat[i][0] % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] / Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum(((R[i] + Mat[i][0]) % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum(((R[i] + Mat[i][0]) % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] ** Mat[i][0] % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] ** Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1 + A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 + A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 1) * A // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1) * A // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(4))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(4))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(2))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(2))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(0))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(0))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(1))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(1))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][0] % M for i in range(-3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(-3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] * Y[k][j] * mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] * mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] * Y[k][j] + mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] + mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d + 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d + 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d * 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d * 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][1] % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][1] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][-1] % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][-1] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M",
      "mutated_line": "X = sum((R[i] * Mat[i][1] % M for i in range(3))) % M",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][1] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] / Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] / Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum(((X[i][k] + Y[k][j]) % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum(((X[i][k] + Y[k][j]) % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "mutated_line": "return [[sum((X[i][k] ** Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] ** Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 * d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 * d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 + d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 + d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 2 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 2 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 0 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 0 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - 0 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 0 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((10 ** d - -1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - -1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((11 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((11 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((9 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((9 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((0 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((0 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((1 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((1 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = max(0, min((10 ** d - 1 - A) // B + 1, L))",
      "mutated_line": "r = max(0, min((-10 ** d - 1 - A) // B + 1, L))",
      "code": "def arithmetic_progression_concat_remainder(L, A, B, M):\n    \"\"\"\n    Calculate the remainder when the integer obtained by concatenating the terms of an arithmetic progression\n    is divided by M.\n\n    Parameters:\n    L (int): The number of terms in the arithmetic progression.\n    A (int): The initial term of the arithmetic progression.\n    B (int): The common difference of the arithmetic progression.\n    M (int): The modulus value to compute the remainder.\n\n    Returns:\n    int: The remainder when the concatenated integer is divided by M.\n    \"\"\"\n\n    def mat_mul(X, Y, mod):\n        m = len(X)\n        return [[sum((X[i][k] * Y[k][j] % mod for k in range(m))) % mod for j in range(m)] for i in range(m)]\n\n    def mat_pow(M, k, mod):\n        m = len(M)\n        res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n        while k > 0:\n            if k & 1:\n                res = mat_mul(M, res, mod)\n            M = mat_mul(M, M, mod)\n            k >>= 1\n        return res\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((-10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n    X = sum((R[i] * Mat[i][0] % M for i in range(3))) % M\n    return X"
    }
  ]
}