{
  "task_id": "taco_17777",
  "entry_point": "calculate_invention_day",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N % K != 0:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K != 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N * K == 0:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N * K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N + K == 0:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N + K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N % K == 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 1:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N % K == -1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == -1:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N % K == 0:",
      "mutated_line": "if N % K == 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 1:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = p % K",
      "mutated_line": "x = p * K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p * K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = p % K",
      "mutated_line": "x = p + K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p + K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = N // K",
      "mutated_line": "y = N / K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N / K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "y = N // K",
      "mutated_line": "y = N * K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N * K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y - math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y - math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y * math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y * math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K > p % K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K > p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K < p % K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K < p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K == p % K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K == p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x / y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x / y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x + y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x + y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x ** y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x ** y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N * K >= p % K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N * K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N + K >= p % K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N + K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K - 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K - 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K * 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K * 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = p % K",
      "mutated_line": "x = p * K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p * K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = p % K",
      "mutated_line": "x = p + K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p + K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y - math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y - math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y * math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y * math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = p % K",
      "mutated_line": "x = p * K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p * K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = p % K",
      "mutated_line": "x = p + K",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p + K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) + 1",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) + 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) * 1",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) * 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K - math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K - math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return (x * y + N % K) * math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return (x * y + N % K) * math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 1) * K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) * K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 1) // K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) // K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p * K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p * K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p + K + 1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p + K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K + 2:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 2:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K + 0:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 0:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K + 0:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 0:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif N % K >= p % K + 1:",
      "mutated_line": "elif N % K >= p % K + -1:",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + -1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = math.ceil(N / K)",
      "mutated_line": "y = math.ceil(N * K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N * K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = math.ceil(N / K)",
      "mutated_line": "y = math.ceil(N // K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N // K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x / y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x / y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x + y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x + y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x ** y + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x ** y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) - 2",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 2\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) - 0",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 0\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) - 0",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 0\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N / K) - -1",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - -1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y - N % K + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y - N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y * (N % K) + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y * (N % K) + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p - 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p - 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil(p * 1 / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil(p * 1 / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 1) * K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) * K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 1) // K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) // K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N * K) - 1",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N * K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = math.ceil(N / K) - 1",
      "mutated_line": "y = math.ceil(N // K) - 1",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N // K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x / y + N % K + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x / y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x + y + N % K + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x + y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x ** y + N % K + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x ** y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N * K + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N * K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + (N + K) + math.ceil((p + 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + (N + K) + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + 1) * K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) * K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + 1) // K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) // K)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 2) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 2) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 0) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 0) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + -1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + -1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p - 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p - 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil(p * 1 / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil(p * 1 / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p - 1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p - 1) / K)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil(p * 1 / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil(p * 1 / K)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 2) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 2) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 0) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 0) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return x * y + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + math.ceil((p + -1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + -1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 1) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + 2) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 2) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 0) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + 0) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + 0) / K)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return x * y + N % K + math.ceil((p + 1) / K)",
      "mutated_line": "return x * y + N % K + math.ceil((p + -1) / K)",
      "code": "import math\n\ndef calculate_invention_day(N, p, K):\n    if N % K == 0:\n        x = p % K\n        y = N // K\n        return x * y + math.ceil((p + 1) / K)\n    elif N % K >= p % K + 1:\n        x = p % K\n        y = math.ceil(N / K)\n        return x * y + math.ceil((p + 1) / K)\n    else:\n        x = p % K\n        y = math.ceil(N / K) - 1\n        return x * y + N % K + math.ceil((p + -1) / K)"
    }
  ]
}