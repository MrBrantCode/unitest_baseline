{
  "task_id": "taco_19382",
  "entry_point": "find_dice_probability_distributions",
  "mutant_count": 240,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s1 = 0",
      "mutated_line": "s1 = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 1\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s1 = 0",
      "mutated_line": "s1 = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = -1\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s1 = 0",
      "mutated_line": "s1 = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 1\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s2 = 0",
      "mutated_line": "s2 = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 1\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s2 = 0",
      "mutated_line": "s2 = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = -1\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "s2 = 0",
      "mutated_line": "s2 = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 1\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 -= avals[-1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 -= avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 -= bvals[-1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 -= bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 + 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 + 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 * (4 * a * c)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 * (4 * a * c)\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc <= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc <= 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc >= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc >= 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc != 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc != 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc * 0.5",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc * 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc + 0.5",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc + 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [1, max_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [1, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [-1, max_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [-1, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [1, max_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [1, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(2, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(0, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(0, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(-1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [1, min_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [1, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [-1, min_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [-1, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [1, min_probabilities[0]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [1, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(2, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(0, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(0, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(-1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(1, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(-1, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(1, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n - 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n * 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n * 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0]",
      "mutated_line": "l = [1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [1]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0]",
      "mutated_line": "l = [-1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [-1]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0]",
      "mutated_line": "l = [1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [1]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(2, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(0, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(0, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(-1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n - 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n * 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 and l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 and l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 or b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 or b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) < 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) < 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) > 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) > 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) == 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) == 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) < 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) < 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) > 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) > 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) == 10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) == 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b * 2 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b * 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b + 2 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b + 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 4 * a / c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a / c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - (4 * a + c)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - (4 * a + c)\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - (4 * a) ** c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - (4 * a) ** c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 1:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc < -1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < -1:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if disc < 0:",
      "mutated_line": "if disc < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 1:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "disc = 0",
      "mutated_line": "disc = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 1\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "disc = 0",
      "mutated_line": "disc = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = -1\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "disc = 0",
      "mutated_line": "disc = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 1\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc ** 1.5",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 1.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc ** -0.5",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** -0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc ** 0",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc ** 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 1\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "disc = disc ** 0.5",
      "mutated_line": "disc = disc ** -0.5",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** -0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 * a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 * a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 // a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 // a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 * a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 * a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 // a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 // a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [0, max_probabilities[1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[1]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [0, max_probabilities[-1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[-1]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "py = [0, max_probabilities[0]]",
      "mutated_line": "py = [0, max_probabilities[1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[1]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[-1] - max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] - max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[-1] * max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] * max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [0, min_probabilities[1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[1]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [0, min_probabilities[-1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[-1]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pz = [0, min_probabilities[0]]",
      "mutated_line": "pz = [0, min_probabilities[1]]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[1]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[-1] - min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] - min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[-1] * min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] * min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 2):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 2):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 0):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + 0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 0):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(0, n + 1):",
      "mutated_line": "for i in range(0, n + -1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + -1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] + 1 + pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 + pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append((py[i] + 1) * pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append((py[i] + 1) * pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + 1] + k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] + k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + 1] * k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] * k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 2):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 0):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 0):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + -1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(+1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(+1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] + s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] + s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, (s1 + l[i]) * s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, (s1 + l[i]) * s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 + py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 + py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 * py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 * py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b <= 0 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b <= 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b >= 0 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b >= 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b != 0 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b != 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b <= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b <= 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b >= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b >= 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b != 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b != 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a <= 0 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a <= 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a >= 0 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a >= 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a != 0 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a != 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b <= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b <= 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b >= 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b >= 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b != 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b != 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 1\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = -1\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 1\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 1\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "b = 0",
      "mutated_line": "b = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = -1\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 1\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "avals.append(l[i] - b)",
      "mutated_line": "avals.append(l[i] + b)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] + b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "avals.append(l[i] - b)",
      "mutated_line": "avals.append(l[i] * b)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] * b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 += avals[+1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[+1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 += bvals[+1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[+1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 * -10:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 * -10:\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 + -10:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 + -10:\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "avals[i] = 0",
      "mutated_line": "avals[i] = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 1\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "avals[i] = 0",
      "mutated_line": "avals[i] = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = -1\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "avals[i] = 0",
      "mutated_line": "avals[i] = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 1\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 * -10:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 * -10:\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 + -10:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 + -10:\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bvals[i] = 0",
      "mutated_line": "bvals[i] = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 1\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bvals[i] = 0",
      "mutated_line": "bvals[i] = -1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = -1\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bvals[i] = 0",
      "mutated_line": "bvals[i] = 1",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 1\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 3 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 3 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 1 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 1 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 0 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 0 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 1 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 1 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** -2 - 4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** -2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 4 / a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 / a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - (4 + a) * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - (4 + a) * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 4 ** a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 ** a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) * 2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) * 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) // 2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) // 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) * 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) * 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) // 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) // 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] - 1 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] - 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] * 1 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] * 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-2, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-2, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-0, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-0, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-0, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-0, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(--1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(--1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 - l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 - l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 * l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 * l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) / s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) / s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, s1 + l[i] + s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, s1 + l[i] + s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) ** s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) ** s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 1 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 1 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < -1 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < -1 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 1 or l[i] - b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 1 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] + b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] + b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] * b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] * b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 1:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b < -1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < -1:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if b < 0 or l[i] - b < 0:",
      "mutated_line": "if b < 0 or l[i] - b < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 1:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 1 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 1 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < -1 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < -1 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 1 and b < 0:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 1 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 1:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b < -1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < -1:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if a < 0 and b < 0:",
      "mutated_line": "if a < 0 and b < 1:",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 1:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 += avals[-2]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-2]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 += avals[-0]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-0]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 += avals[-0]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-0]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "s1 += avals[-1]",
      "mutated_line": "s1 += avals[--1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[--1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 += bvals[-2]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-2]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 += bvals[-0]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-0]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 += bvals[-0]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-0]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "s2 += bvals[-1]",
      "mutated_line": "s2 += bvals[--1]",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[--1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 11 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 11 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 9 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 9 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 0 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 0 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 1 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 1 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= -10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= -10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (+10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (+10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 11 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 11 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 9 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 9 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 0 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 0 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 1 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 1 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= -10 ** (-10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= -10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (+10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (+10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 5 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 5 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 3 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 3 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 0 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 0 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - 1 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 1 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "disc = b ** 2 - 4 * a * c",
      "mutated_line": "disc = b ** 2 - -4 * a * c",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - -4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b - disc) / 2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b - disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return (-b * disc / 2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return (-b * disc / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 3 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 3 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 1 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 1 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 0 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 0 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 1 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 1 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / -2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / -2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b + disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b + disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, -b * disc / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, -b * disc / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 3 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 3 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 1 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 1 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 0 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 0 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / 1 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 1 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (-b - disc) / -2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / -2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[+1] + max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[+1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[+1] + min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[+1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] + 2 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 2 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] + 0 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 0 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] + 0 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 0 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k.append(py[i] + 1 - pz[i])",
      "mutated_line": "k.append(py[i] + -1 - pz[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + -1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i - 1] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i - 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i * 1] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i * 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 - l[i]) * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 - l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])",
      "mutated_line": "(a, b) = quad(-1, s1 + l[i] - s2, s1 * l[i] * s2 - py[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, s1 * l[i] * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (-11):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-11):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (-9):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-9):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (-0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-0):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (-1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-1):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if abs(avals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(avals[i]) <= 10 ** (--10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (--10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (-11):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-11):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (-9):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-9):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (-0):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-0):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (-1):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-1):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if abs(bvals[i]) <= 10 ** (-10):",
      "mutated_line": "if abs(bvals[i]) <= 10 ** (--10):",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (--10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((+b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((+b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)",
      "mutated_line": "return ((-b + disc) / 2 / a, (+b - disc) / 2 / a)",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (+b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[-2] + max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-2] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[-0] + max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-0] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[-0] + max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-0] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "py.append(py[-1] + max_probabilities[i])",
      "mutated_line": "py.append(py[--1] + max_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[--1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[-2] + min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-2] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[-0] + min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-0] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[-0] + min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-0] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "pz.append(pz[-1] + min_probabilities[i])",
      "mutated_line": "pz.append(pz[--1] + min_probabilities[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[--1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + 2] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 2] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + 0] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 0] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + 0] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + 0] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l.append(k[i + 1] - k[i])",
      "mutated_line": "l.append(k[i + -1] - k[i])",
      "code": "def find_dice_probability_distributions(n, max_probabilities, min_probabilities):\n\n    def quad(a, b, c):\n        disc = b ** 2 - 4 * a * c\n        if disc < 0:\n            disc = 0\n        disc = disc ** 0.5\n        return ((-b + disc) / 2 / a, (-b - disc) / 2 / a)\n    py = [0, max_probabilities[0]]\n    for i in range(1, n):\n        py.append(py[-1] + max_probabilities[i])\n    min_probabilities.reverse()\n    pz = [0, min_probabilities[0]]\n    for i in range(1, n):\n        pz.append(pz[-1] + min_probabilities[i])\n    pz.reverse()\n    k = []\n    for i in range(0, n + 1):\n        k.append(py[i] + 1 - pz[i])\n    l = [0]\n    for i in range(n):\n        l.append(k[i + -1] - k[i])\n    s1 = 0\n    s2 = 0\n    avals = []\n    bvals = []\n    for i in range(1, n + 1):\n        (a, b) = quad(-1, s1 + l[i] - s2, (s1 + l[i]) * s2 - py[i])\n        if b < 0 or l[i] - b < 0:\n            (a, b) = (b, a)\n        if a < 0 and b < 0:\n            a = 0\n            b = 0\n        bvals.append(b)\n        avals.append(l[i] - b)\n        s1 += avals[-1]\n        s2 += bvals[-1]\n    for i in range(len(avals)):\n        if abs(avals[i]) <= 10 ** (-10):\n            avals[i] = 0\n        if abs(bvals[i]) <= 10 ** (-10):\n            bvals[i] = 0\n    return (avals, bvals)"
    }
  ]
}