{
  "task_id": "taco_15468",
  "entry_point": "construct_multiset_for_cost",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k += tt * (tt - 1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k += tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(27):",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(27):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(25):",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(25):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(0):",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(0):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(1):",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(1):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(26):",
      "mutated_line": "for i in range(-26):",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(-26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tt = 1",
      "mutated_line": "tt = 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 2\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tt = 1",
      "mutated_line": "tt = 0",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 0\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tt = 1",
      "mutated_line": "tt = 0",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 0\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "tt = 1",
      "mutated_line": "tt = -1",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = -1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 2 < k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 < k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 2 > k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 > k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 2 == k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 == k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "tt += 1",
      "mutated_line": "tt -= 1",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt -= 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) / 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) / 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) * 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) * 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) / 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) / 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) * 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) * 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tt += 1",
      "mutated_line": "tt += 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 2\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tt += 1",
      "mutated_line": "tt += 0",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 0\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tt += 1",
      "mutated_line": "tt += 0",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 0\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tt += 1",
      "mutated_line": "tt += -1",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += -1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt / (tt - 1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt / (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= (tt + (tt - 1)) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= (tt + (tt - 1)) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt ** (tt - 1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt ** (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) // 3",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 3\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) // 1",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 1\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) // 0",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 0\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) // 1",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 1\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 1) // -2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // -2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(97 + i) / tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) / tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(97 + i) + tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) + tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(97 + i) ** tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) ** tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return ''.join(result)",
      "mutated_line": "return 'MUTATED'.join(result)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return 'MUTATED'.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt / (tt + 1) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt / (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while (tt + (tt + 1)) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while (tt + (tt + 1)) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt ** (tt + 1) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt ** (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 3 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 3 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 1 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 1 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 0 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 0 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // 1 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 1 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 1) // -2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // -2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt + 1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt + 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt * 1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt * 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt - 1) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt - 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt * 1) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt * 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 2) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 2) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 0) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 0) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - 0) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 0) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k -= tt * (tt - 1) // 2",
      "mutated_line": "k -= tt * (tt - -1) // 2",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - -1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(97 - i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 - i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(97 * i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 * i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 2) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 2) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 0) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 0) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + 0) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 0) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while tt * (tt + 1) // 2 <= k:",
      "mutated_line": "while tt * (tt + -1) // 2 <= k:",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + -1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(97 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(98 + i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(98 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(96 + i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(96 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(0 + i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(0 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(1 + i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(1 + i) * tt)\n    return ''.join(result)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "result.append(chr(97 + i) * tt)",
      "mutated_line": "result.append(chr(-97 + i) * tt)",
      "code": "def construct_multiset_for_cost(k: int) -> str:\n    \"\"\"\n    Constructs a non-empty string of no more than 100,000 lowercase English letters\n    such that the minimum accumulative cost of the whole process is exactly k.\n\n    Parameters:\n    k (int): The required minimum cost (0 ≤ k ≤ 100,000).\n\n    Returns:\n    str: A string representing the multiset of letters.\n    \"\"\"\n    result = []\n    for i in range(26):\n        tt = 1\n        while tt * (tt + 1) // 2 <= k:\n            tt += 1\n        k -= tt * (tt - 1) // 2\n        result.append(chr(-97 + i) * tt)\n    return ''.join(result)"
    }
  ]
}