{
  "task_id": "taco_5676",
  "entry_point": "can_obtain_permutation",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] / (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] / (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] + (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] + (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] ** (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] ** (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c_c = 1",
      "mutated_line": "c_c = 2",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 2\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c_c = 1",
      "mutated_line": "c_c = 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 0\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c_c = 1",
      "mutated_line": "c_c = 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 0\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c_c = 1",
      "mutated_line": "c_c = -1",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = -1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N - 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N - 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N * 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N * 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(2, N + 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(2, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(0, N + 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(0, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(0, N + 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(0, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(-1, N + 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(-1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N - 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N - 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N * 1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N * 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "c_c += 1",
      "mutated_line": "c_c -= 1",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c -= 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if P[i] != Q[i]:",
      "mutated_line": "if P[i] == Q[i]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] == Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [+1] * (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [+1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N + 2)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 2)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N + 0)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 0)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N + 0)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 0)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-1] * (N + -1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + -1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N + 2):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 2):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N + 0):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 0):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N + 0):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 0):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for v in range(1, N + 1):",
      "mutated_line": "for v in range(1, N + -1):",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + -1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] != -1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] != -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "c_c += 1",
      "mutated_line": "c_c -= 1",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c -= 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 2",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 2\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 0\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 0\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += -1",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += -1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] == mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] == mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] != -1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] != -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N - 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N * 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-2] * (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-2] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-0] * (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-0] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [-0] * (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-0] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "mark = [-1] * (N + 1)",
      "mutated_line": "mark = [--1] * (N + 1)",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [--1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] == +1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == +1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 2",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 2\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 0\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += 0",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 0\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c_c += 1",
      "mutated_line": "c_c += -1",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += -1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return True\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] == +1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == +1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 2)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 0)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 0)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "for (x, y) in good_pairs:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + -1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] == -2:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -2:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] == -0:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -0:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] == -0:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -0:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mark[v] == -1:",
      "mutated_line": "if mark[v] == --1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == --1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] - 1] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] - 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] * 1] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] * 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] - 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] - 1]:\n                return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] * 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] * 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] == -2:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -2:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] == -0:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -0:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] == -0:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -0:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if mark[j] == -1:",
      "mutated_line": "if mark[j] == --1:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == --1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 2] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 2] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 0] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 0] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 0] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 0] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + -1] != mark[t_p[Q[i]] + 1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + -1] != mark[t_p[Q[i]] + 1]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 2]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 2]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 0]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 0]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 0]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 0]:\n                return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + 1]:",
      "mutated_line": "if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + -1]:",
      "code": "def can_obtain_permutation(N, M, P, Q, good_pairs):\n\n    def dfs(v):\n        nonlocal mark, c_c\n        q = []\n        q.append(v)\n        while q:\n            top = q.pop()\n            mark[top] = c_c\n            for j in G[top]:\n                if mark[j] == -1:\n                    q.append(j)\n                    mark[j] = mark[top]\n    G = [[] for _ in range(N + 1)]\n    for (x, y) in good_pairs:\n        G[x].append(y)\n        G[y].append(x)\n    mark = [-1] * (N + 1)\n    c_c = 1\n    t_p = {P[i]: i for i in range(N)}\n    for v in range(1, N + 1):\n        if G[v]:\n            if mark[v] == -1:\n                dfs(v)\n                c_c += 1\n        else:\n            mark[v] = c_c\n            c_c += 1\n    for i in range(N):\n        if P[i] != Q[i]:\n            if mark[t_p[P[i]] + 1] != mark[t_p[Q[i]] + -1]:\n                return False\n    return True"
    }
  ]
}