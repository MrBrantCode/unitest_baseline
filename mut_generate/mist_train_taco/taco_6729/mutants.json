{
  "task_id": "taco_6729",
  "entry_point": "optimal_skyscraper_floors",
  "mutant_count": 182,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = [-inf] + m - [-inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m - [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = ([-inf] + m) * [-inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = ([-inf] + m) * [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] / (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] / (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] + (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] + (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] ** (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] ** (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] / (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] / (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] + (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] + (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] ** (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] ** (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "inf = float('inf')",
      "mutated_line": "inf = float('')",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = [-inf] - m + [-inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] - m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = [-inf] * m + [-inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] * m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n - 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n - 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n * 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n * 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n - 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n - 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n * 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n * 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (1, 1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (1, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (-1, 1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (-1, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (1, 1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (1, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (0, 2):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 2):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (0, 0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 0):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (0, 0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 0):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for x in (0, 1):",
      "mutated_line": "for x in (0, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, -1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] / (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] / (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] + (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] + (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] ** (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] ** (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] / (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] / (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] + (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] + (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] ** (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] ** (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "su = [i + j - k for (i, j, k) in zip(left, right, a)]",
      "mutated_line": "su = [i + j + k for (i, j, k) in zip(left, right, a)]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j + k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "su = [i + j - k for (i, j, k) in zip(left, right, a)]",
      "mutated_line": "su = [(i + j) * k for (i, j, k) in zip(left, right, a)]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [(i + j) * k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma - 1, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma - 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma * 1, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma * 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma + 1, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma + 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma * 1, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma * 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, +1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, +1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -1, +1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, +1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = [-inf] + m + [+inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [+inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [1] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [-1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [-1] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [1] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n + 3)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 3)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 1)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n + 0)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 0)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 1)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "left = [0] * (n + 2)",
      "mutated_line": "left = [0] * (n + -2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + -2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [1] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [-1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [-1] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [1] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n + 3)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 3)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 1)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n + 0)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 0)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 1)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "right = [0] * (n + 2)",
      "mutated_line": "right = [0] * (n + -2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + -2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [0]",
      "mutated_line": "stack = [1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [1]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [0]",
      "mutated_line": "stack = [-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [-1]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "stack = [0]",
      "mutated_line": "stack = [1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [1]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n - 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n - 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n * 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n * 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, +1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, +1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, +1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, +1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] <= a[stack[-1]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] <= a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] >= a[stack[-1]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] >= a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] != a[stack[-1]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] != a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n - 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n - 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n * 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n * 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(2, len(a)):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(2, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(0, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(0, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(-1, len(a)):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(-1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if ns[i] == 0:",
      "mutated_line": "if ns[i] != 0:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] != 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[2:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[2:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[0:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[0:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[-1:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[-1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[1:+1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:+1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[2:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[2:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[0:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[0:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[-1:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[-1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[1:+1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:+1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[2:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[2:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[0:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[0:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[0:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[-1:-1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[-1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[1:+1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:+1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "su = [i + j - k for (i, j, k) in zip(left, right, a)]",
      "mutated_line": "su = [i - j - k for (i, j, k) in zip(left, right, a)]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i - j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "su = [i + j - k for (i, j, k) in zip(left, right, a)]",
      "mutated_line": "su = [i * j - k for (i, j, k) in zip(left, right, a)]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i * j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma + 2, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 2, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma + 0, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 0, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma + 0, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 0, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(ma + 1, n):",
      "mutated_line": "for i in range(ma + -1, n):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + -1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 2, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 2, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 0, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 0, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 0, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 0, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - -1, -1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - -1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -2, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -2, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -0, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -0, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -0, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -0, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, --1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, --1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -1, -2):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -2):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -1, -0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -0):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -1, -0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -0):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(ma - 1, -1, -1):",
      "mutated_line": "for i in range(ma - 1, -1, --1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, --1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "a = [-inf] + m + [-inf]",
      "mutated_line": "a = [+inf] + m + [-inf]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [+inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [+1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [+1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n + 3)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 3)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 1)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n + 0)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 0)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 1)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-1] * (n + -2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + -2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -2, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -2, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -0, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -0, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -0, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -0, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, --1, -1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, --1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -2):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -2):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -0):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, -0):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -0):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(n, -1, -1):",
      "mutated_line": "for i in range(n, -1, --1):",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, --1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [1] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [-1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [-1] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [1] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n + 3)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 3)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 1)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n + 0)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 0)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n + 1)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 1)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "res = [0] * (n + 2)",
      "mutated_line": "res = [0] * (n + -2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + -2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ns[i] == 0:",
      "mutated_line": "if ns[i] == 1:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 1:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ns[i] == 0:",
      "mutated_line": "if ns[i] == -1:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == -1:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ns[i] == 0:",
      "mutated_line": "if ns[i] == 1:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 1:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res[i] = i * a[i]",
      "mutated_line": "res[i] = i / a[i]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i / a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res[i] = i * a[i]",
      "mutated_line": "res[i] = i + a[i]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i + a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "res[i] = i * a[i]",
      "mutated_line": "res[i] = i ** a[i]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i ** a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] - a[i] * (i - ns[i])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] - a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] * (a[i] * (i - ns[i]))",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] * (a[i] * (i - ns[i]))\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "a = a[::-1]",
      "mutated_line": "a = a[::+1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::+1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[1:-2]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-2]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-0]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-0]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = a[1:-1]",
      "mutated_line": "a = a[1:--1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:--1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[1:-2]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-2]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-0]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-0]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "left = left[1:-1]",
      "mutated_line": "left = left[1:--1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:--1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[1:-2]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-2]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-0]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[1:-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-0]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "right = right[1:-1]",
      "mutated_line": "right = right[1:--1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:--1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i + 1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i + 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i * 1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i * 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i - 1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i - 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i * 1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i * 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-2] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-2] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-0] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-0] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [-0] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-0] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ns = [-1] * (n + 2)",
      "mutated_line": "ns = [--1] * (n + 2)",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [--1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] + a[i] / (i - ns[i])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] / (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] + (a[i] + (i - ns[i]))",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + (a[i] + (i - ns[i]))\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] + a[i] ** (i - ns[i])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] ** (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "a = a[::-1]",
      "mutated_line": "a = a[::-2]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-2]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "a = a[::-1]",
      "mutated_line": "a = a[::-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-0]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "a = a[::-1]",
      "mutated_line": "a = a[::-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-0]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "a = a[::-1]",
      "mutated_line": "a = a[::--1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::--1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "right = res[:][::-1]",
      "mutated_line": "right = res[:][::+1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::+1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i - 2])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 2])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i - 0])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 0])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i - 0])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 0])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a[i] = min(a[i], a[i - 1])",
      "mutated_line": "a[i] = min(a[i], a[i - -1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - -1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i + 2])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 2])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i + 0])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 0])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i + 0])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 0])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a[i] = min(a[i], a[i + 1])",
      "mutated_line": "a[i] = min(a[i], a[i + -1])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + -1])\n    return a"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] < a[stack[+1]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[+1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] + a[i] * (i + ns[i])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i + ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res[i] = res[ns[i]] + a[i] * (i - ns[i])",
      "mutated_line": "res[i] = res[ns[i]] + a[i] * (i * ns[i])",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i * ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = res[:][::-1]",
      "mutated_line": "right = res[:][::-2]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-2]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = res[:][::-1]",
      "mutated_line": "right = res[:][::-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-0]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = res[:][::-1]",
      "mutated_line": "right = res[:][::-0]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-0]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = res[:][::-1]",
      "mutated_line": "right = res[:][::--1]",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::--1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] < a[stack[-2]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-2]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] < a[stack[-0]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-0]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] < a[stack[-0]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[-0]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while a[i] < a[stack[-1]]:",
      "mutated_line": "while a[i] < a[stack[--1]]:",
      "code": "def optimal_skyscraper_floors(n, m):\n    inf = float('inf')\n    a = [-inf] + m + [-inf]\n    left = [0] * (n + 2)\n    right = [0] * (n + 2)\n    for x in (0, 1):\n        stack = [0]\n        ns = [-1] * (n + 2)\n        for i in range(n, -1, -1):\n            while a[i] < a[stack[--1]]:\n                ns[stack.pop()] = i\n            stack.append(i)\n        res = [0] * (n + 2)\n        for i in range(1, len(a)):\n            if ns[i] == 0:\n                res[i] = i * a[i]\n            else:\n                res[i] = res[ns[i]] + a[i] * (i - ns[i])\n        a = a[::-1]\n        if x:\n            right = res[:][::-1]\n        else:\n            left = res[:]\n    a = a[1:-1]\n    left = left[1:-1]\n    right = right[1:-1]\n    su = [i + j - k for (i, j, k) in zip(left, right, a)]\n    ma = su.index(max(su))\n    for i in range(ma + 1, n):\n        a[i] = min(a[i], a[i - 1])\n    for i in range(ma - 1, -1, -1):\n        a[i] = min(a[i], a[i + 1])\n    return a"
    }
  ]
}