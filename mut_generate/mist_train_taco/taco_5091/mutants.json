{
  "task_id": "taco_5091",
  "entry_point": "max_well_bracketed_sum",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "B[i] -= 1",
      "mutated_line": "B[i] += 1",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] += 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i] -= 1",
      "mutated_line": "B[i] -= 2",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 2\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i] -= 1",
      "mutated_line": "B[i] -= 0",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 0\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i] -= 1",
      "mutated_line": "B[i] -= 0",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 0\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B[i] -= 1",
      "mutated_line": "B[i] -= -1",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= -1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for k_range in range(1, n):",
      "mutated_line": "for k_range in range(2, n):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(2, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for k_range in range(1, n):",
      "mutated_line": "for k_range in range(0, n):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(0, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for k_range in range(1, n):",
      "mutated_line": "for k_range in range(0, n):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(0, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for k_range in range(1, n):",
      "mutated_line": "for k_range in range(-1, n):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(-1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[0][+1]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][+1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[1 for _ in range(n)] for _ in range(n)]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[1 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[-1 for _ in range(n)] for _ in range(n)]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[-1 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dp = [[1 for _ in range(n)] for _ in range(n)]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[1 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n + 2, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n + 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n * 2, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n * 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, +1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, +1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, +1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, +1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j + k_range >= n:",
      "mutated_line": "if j + k_range > n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range > n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j + k_range >= n:",
      "mutated_line": "if j + k_range < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range < n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j + k_range >= n:",
      "mutated_line": "if j + k_range == n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range == n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] > k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] > k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] < k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] < k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] == k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] == k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if B[j + k_range] - k == B[j]:",
      "mutated_line": "if B[j + k_range] - k != B[j]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k != B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[1][-1]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[1][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[-1][-1]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[-1][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[1][-1]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[1][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[0][-2]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-2]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[0][-0]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[0][-0]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][-1]",
      "mutated_line": "return dp[0][--1]",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][--1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(2 / k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 / k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(2 + k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 + k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(2 ** k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 ** k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 3, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 3, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 1, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 0, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 1, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - -2, -1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - -2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -2, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -2, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -0, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -0, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -0, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -0, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, --1, -1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, --1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -2):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -2):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -0):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -0):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -0):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -0):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, --1):",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, --1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if j + k_range >= n:",
      "mutated_line": "if j - k_range >= n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j - k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if j + k_range >= n:",
      "mutated_line": "if j * k_range >= n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j * k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j - k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j - k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j * k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j * k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] > k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] > k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] < k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] < k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j + k_range] == k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] == k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if B[j + k_range] - k == B[j]:",
      "mutated_line": "if B[j + k_range] + k == B[j]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] + k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if B[j + k_range] - k == B[j]:",
      "mutated_line": "if B[j + k_range] * k == B[j]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] * k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 1 <= n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 <= n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 1 >= n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 >= n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 1 != n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 != n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(3 * k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(3 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(1 * k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(1 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(0 * k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(0 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(1 * k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(1 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b_inv = {key: [] for key in range(2 * k)}",
      "mutated_line": "b_inv = {key: [] for key in range(-2 * k)}",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(-2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j - k_range], dp[j][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j - k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j * k_range], dp[j][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j * k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range + 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range + 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][(j + k_range) * 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][(j + k_range) * 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j - k_range] >= k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j - k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j * k_range] >= k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j * k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range + 1 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range + 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if (j + k_range) * 1 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if (j + k_range) * 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j - k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j - k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j * k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j * k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 2])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 2])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 0])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 0])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 0])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 0])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - -1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - -1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)",
      "mutated_line": "left = bisect.bisect_right(b_inv[B[j + k_range] + k], j)",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] + k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)",
      "mutated_line": "left = bisect.bisect_right(b_inv[B[j + k_range] * k], j)",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] * k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j - k_range] >= k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j - k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if B[j + k_range] >= k:",
      "mutated_line": "if B[j * k_range] >= k:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j * k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i > j + k_range:",
      "mutated_line": "if i >= j + k_range:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i >= j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i > j + k_range:",
      "mutated_line": "if i <= j + k_range:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i <= j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i > j + k_range:",
      "mutated_line": "if i != j + k_range:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i != j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i > j:",
      "mutated_line": "if i >= j:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i >= j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i > j:",
      "mutated_line": "if i <= j:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i <= j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i > j:",
      "mutated_line": "if i != j:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i != j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if B[j + k_range] - k == B[j]:",
      "mutated_line": "if B[j - k_range] - k == B[j]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j - k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if B[j + k_range] - k == B[j]:",
      "mutated_line": "if B[j * k_range] - k == B[j]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j * k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j - k_range - 1 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j - k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j * k_range - 1 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j * k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 2 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 2 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 0 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 0 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - 0 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 0 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j + k_range - 1 < n:",
      "mutated_line": "if j + k_range - -1 < n:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - -1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j - k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j - k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j * k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j * k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] - dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] - dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], (V[j + k_range] + V[j]) * dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], (V[j + k_range] + V[j]) * dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j - k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j - k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j * k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j * k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] - V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] - V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] * V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] * V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in b_inv[B[j + k_range] - k][left:]:",
      "mutated_line": "for i in b_inv[B[j + k_range] + k][left:]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] + k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in b_inv[B[j + k_range] - k][left:]:",
      "mutated_line": "for i in b_inv[B[j + k_range] * k][left:]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] * k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i > j + k_range:",
      "mutated_line": "if i > j - k_range:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j - k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if i > j + k_range:",
      "mutated_line": "if i > j * k_range:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j * k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j - k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j - k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j * k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j * k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] - V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] - V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] * V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] * V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j - k_range], V[j + k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j - k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j * k_range], V[j + k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j * k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)",
      "mutated_line": "left = bisect.bisect_right(b_inv[B[j - k_range] - k], j)",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j - k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)",
      "mutated_line": "left = bisect.bisect_right(b_inv[B[j * k_range] - k], j)",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j * k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j - k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j - k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j * k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j * k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] - dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] - dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] * dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] * dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range + 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range + 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][(j + k_range) * 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][(j + k_range) * 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j - k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j - k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j * k_range] + V[j])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j * k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in b_inv[B[j + k_range] - k][left:]:",
      "mutated_line": "for i in b_inv[B[j - k_range] - k][left:]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j - k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in b_inv[B[j + k_range] - k][left:]:",
      "mutated_line": "for i in b_inv[B[j * k_range] - k][left:]:",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j * k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j - k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j - k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j * k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j * k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j - k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j - k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j * k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j * k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j - 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j - 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j * 1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j * 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j - k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j - k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j * k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j * k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 2])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 2])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 0])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 0])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 0])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 0])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - -1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - -1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i + 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i + 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i * 1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i * 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j - k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j - k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j * k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j * k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 2][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 2][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 0][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 0][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 0][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 0][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + -1][j + k_range - 1])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + -1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 2] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 2] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 0] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 0] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 0] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 0] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - 1] + dp[i][j + k_range])",
      "mutated_line": "dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - -1] + dp[i][j + k_range])",
      "code": "import bisect\n\ndef max_well_bracketed_sum(n, k, V, B):\n    b_inv = {key: [] for key in range(2 * k)}\n    for i in range(n):\n        B[i] -= 1\n        b_inv[B[i]].append(i)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for k_range in range(1, n):\n        for j in range(n - 2, -1, -1):\n            if j + k_range >= n:\n                continue\n            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][j + k_range - 1])\n            if B[j + k_range] >= k:\n                left = bisect.bisect_right(b_inv[B[j + k_range] - k], j)\n                if B[j + k_range] >= k:\n                    for i in b_inv[B[j + k_range] - k][left:]:\n                        if i > j + k_range:\n                            break\n                        if i > j:\n                            dp[j][j + k_range] = max(dp[j][j + k_range], dp[j][i - -1] + dp[i][j + k_range])\n            if B[j + k_range] - k == B[j]:\n                if j + k_range - 1 < n:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j] + dp[j + 1][j + k_range - 1])\n                else:\n                    dp[j][j + k_range] = max(dp[j][j + k_range], V[j + k_range] + V[j])\n    return dp[0][-1]"
    }
  ]
}