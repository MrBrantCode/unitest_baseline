{
  "task_id": "taco_8733",
  "entry_point": "calculate_max_score",
  "mutant_count": 243,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if s.count('W') == 0:",
      "mutated_line": "if s.count('W') != 0:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') != 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[0] != 'W':",
      "mutated_line": "if s[0] == 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] == 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[-1] == 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] == 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 1\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "f = 0",
      "mutated_line": "f = -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = -1\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 1\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 1\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = -1\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 1\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if s.count('W') == 0:",
      "mutated_line": "if s.count('W') == 1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 1:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if s.count('W') == 0:",
      "mutated_line": "if s.count('W') == -1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == -1:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if s.count('W') == 0:",
      "mutated_line": "if s.count('W') == 1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 1:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if s[i] == 'W':",
      "mutated_line": "if s[i] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] != 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) + 1):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) + 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) * 1):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) * 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] - 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] * 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] * 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[1] or k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] or k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "now += 1",
      "mutated_line": "now -= 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now -= 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k += 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[0] != 'W':",
      "mutated_line": "if s[0] != '':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != '':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[-1] != '':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != '':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] != -1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] != -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 51,
      "original_line": "if not f and s[i] == 'W':",
      "mutated_line": "if not f or s[i] == 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f or s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans -= 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if s.count('W') == 0:",
      "mutated_line": "if s.count('') == 0:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(1, 1 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(1, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(-1, 1 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(-1, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(1, 1 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(1, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 - 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 - 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 * (2 * (now - 1)))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 * (2 * (now - 1)))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if s[i] == 'W':",
      "mutated_line": "if s[i] == '':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == '':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) - 2):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 2):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) - 0):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 0):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) - 0):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 0):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(len(gap) - 1):",
      "mutated_line": "for i in range(len(gap) - -1):",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - -1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 2\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 0\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 0\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + -1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now <= i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now <= i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now >= i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now >= i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now != i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now != i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "s[now] = 'W'",
      "mutated_line": "s[now] = ''",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = ''\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "now += 1",
      "mutated_line": "now += 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 2\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 0\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 0\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "now += 1",
      "mutated_line": "now += -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += -1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 2\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 0\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 0\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= -1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[0] != 'W':",
      "mutated_line": "if s[1] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[1] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[0] != 'W':",
      "mutated_line": "if s[-1] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[-1] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[0] != 'W':",
      "mutated_line": "if s[1] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[1] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[+1] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[+1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] == +1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == +1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] + 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] * 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] * 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now >= 0 or k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 or k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k += 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "now -= 1",
      "mutated_line": "now += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now += 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] - 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] * 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] * 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[1] or k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] or k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k += 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "now += 1",
      "mutated_line": "now -= 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now -= 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if not f and s[i] == 'W':",
      "mutated_line": "if not f and s[i] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] != 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "f = 1",
      "mutated_line": "f = 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 2\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 0\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 0\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "f = 1",
      "mutated_line": "f = -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = -1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 2\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 0\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 0\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += -1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 54,
      "original_line": "elif f and s[i] == 'W':",
      "mutated_line": "elif f or s[i] == 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f or s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans -= 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans -= 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 2 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 2 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 0 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 0 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 0 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 0 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, -1 + 2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, -1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 / (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 / (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + (2 + (now - 1)))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + (2 + (now - 1)))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 ** (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 ** (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] + 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] + 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], (gap[i + 1] - gap[i]) * 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], (gap[i + 1] - gap[i]) * 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[1] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[-1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[-1] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[1] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([+1, gap[0], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([+1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -1 + 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 + 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], (gap[0] - -1) * 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], (gap[0] - -1) * 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[-2] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-2] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[-0] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-0] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[-0] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-0] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if s[-1] != 'W':",
      "mutated_line": "if s[--1] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[--1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-1] + 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] + 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, (n - gap[-1]) * 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, (n - gap[-1]) * 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[1] == -1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[1] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[-1] == -1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[-1] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[1] == -1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[1] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] == -2:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -2:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] == -0:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -0:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] == -0:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -0:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] == -1:",
      "mutated_line": "if i[0] == --1:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == --1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] - 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 2\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] - 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 0\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] - 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 0\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[1] - -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - -1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now > 0 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now > 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now < 0 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now < 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now == 0 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now == 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 2\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 0\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 0\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= -1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "s[now] = 'W'",
      "mutated_line": "s[now] = ''",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = ''\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "now -= 1",
      "mutated_line": "now -= 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 2\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "now -= 1",
      "mutated_line": "now -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 0\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "now -= 1",
      "mutated_line": "now -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 0\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "now -= 1",
      "mutated_line": "now -= -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= -1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 2\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 0\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 0\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[0] + -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + -1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now <= i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now <= i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now >= i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now >= i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now != i[1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now != i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "s[now] = 'W'",
      "mutated_line": "s[now] = ''",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = ''\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 2\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 0\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 0\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= -1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "now += 1",
      "mutated_line": "now += 2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 2\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 0\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 0\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "now += 1",
      "mutated_line": "now += -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += -1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if not f and s[i] == 'W':",
      "mutated_line": "if not f and s[i] == '':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == '':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "elif f and s[i] == 'W':",
      "mutated_line": "elif f and s[i] != 'W':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] != 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans += 3",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 3\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 1\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans += 0",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 0\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 1\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans += 2",
      "mutated_line": "ans += -2",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += -2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "f = 0",
      "mutated_line": "f = -1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "f = 0",
      "mutated_line": "f = 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 3 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 3 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 1 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 1 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 0 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 0 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 1 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 1 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + -2 * (now - 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + -2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now + 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now + 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now * 1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now * 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i - 1], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i - 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i * 1], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i * 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] + gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] + gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] * gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] * gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 2])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 2])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 0])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 0])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - -1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - -1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ne.sort(key=lambda x: x[2])",
      "mutated_line": "ne.sort(key=lambda x: x[3])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[3])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ne.sort(key=lambda x: x[2])",
      "mutated_line": "ne.sort(key=lambda x: x[1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[1])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ne.sort(key=lambda x: x[2])",
      "mutated_line": "ne.sort(key=lambda x: x[0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[0])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ne.sort(key=lambda x: x[2])",
      "mutated_line": "ne.sort(key=lambda x: x[1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[1])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ne.sort(key=lambda x: x[2])",
      "mutated_line": "ne.sort(key=lambda x: x[-2])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[-2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[2] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[2] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[0] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[0] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[0] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[0] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[-1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[-1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-2, gap[0], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-2, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-0, gap[0], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-0, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-0, gap[0], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-0, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([--1, gap[0], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([--1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[1], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[1], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[-1], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[-1], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[1], gap[0] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[1], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] + -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] + -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] * -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] * -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -1 - 2])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 2])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -1 - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 0])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -1 - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 0])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -1 - -1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - -1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[+1], n, n - gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[+1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n + gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n + gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n * gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n * gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-1] - 2])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 2])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-1] - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 0])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-1] - 0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 0])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-1] - -1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - -1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp.sort(key=lambda x: x[2])",
      "mutated_line": "temp.sort(key=lambda x: x[3])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[3])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp.sort(key=lambda x: x[2])",
      "mutated_line": "temp.sort(key=lambda x: x[1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[1])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp.sort(key=lambda x: x[2])",
      "mutated_line": "temp.sort(key=lambda x: x[0])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[0])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp.sort(key=lambda x: x[2])",
      "mutated_line": "temp.sort(key=lambda x: x[1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[1])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "temp.sort(key=lambda x: x[2])",
      "mutated_line": "temp.sort(key=lambda x: x[-2])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[-2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[2] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[2] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[0] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[0] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[0] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[0] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "now = i[1] - 1",
      "mutated_line": "now = i[-1] - 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[-1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now >= 1 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 1 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now >= -1 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= -1 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "while now >= 0 and k:",
      "mutated_line": "while now >= 1 and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 1 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[1] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[-1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[-1] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "now = i[0] + 1",
      "mutated_line": "now = i[1] + 1",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[1] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "elif f and s[i] == 'W':",
      "mutated_line": "elif f and s[i] == '':",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == '':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now - 2))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 2))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now - 0))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 0))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now - 0))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 0))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return max(0, 1 + 2 * (now - 1))",
      "mutated_line": "return max(0, 1 + 2 * (now - -1))",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - -1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 2], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 2], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 0], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 0], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 0], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 0], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + -1], gap[i + 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + -1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - +1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - +1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-2], n, n - gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-2], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-0], n, n - gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-0], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-0], n, n - gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-0], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[--1], n, n - gap[-1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[--1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[2] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[2] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[0] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[0] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[0] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[0] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while now < i[1] and k:",
      "mutated_line": "while now < i[-1] and k:",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[-1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i - 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i - 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i * 1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i * 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[1] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[1] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[-1] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[-1] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[1] - -1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[1] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -2 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -2 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -0 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -0 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - -0 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -0 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "temp.append([-1, gap[0], gap[0] - -1 - 1])",
      "mutated_line": "temp.append([-1, gap[0], gap[0] - --1 - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - --1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[+1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[+1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 2] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 2] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 0] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 0] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + 0] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 0] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])",
      "mutated_line": "ne.append([gap[i], gap[i + 1], gap[i + -1] - gap[i] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + -1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-2] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-2] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-0] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-0] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[-0] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[-0] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp.append([gap[-1], n, n - gap[-1] - 1])",
      "mutated_line": "temp.append([gap[-1], n, n - gap[--1] - 1])",
      "code": "def calculate_max_score(n, k, s):\n    if s.count('W') == 0:\n        now = min(k, n)\n        return max(0, 1 + 2 * (now - 1))\n    gap = []\n    for i in range(n):\n        if s[i] == 'W':\n            gap.append(i)\n    ne = []\n    for i in range(len(gap) - 1):\n        ne.append([gap[i], gap[i + 1], gap[i + 1] - gap[i] - 1])\n    ne.sort(key=lambda x: x[2])\n    for i in ne:\n        now = i[0] + 1\n        while now < i[1] and k:\n            s[now] = 'W'\n            now += 1\n            k -= 1\n        if not k:\n            break\n    temp = []\n    if s[0] != 'W':\n        temp.append([-1, gap[0], gap[0] - -1 - 1])\n    if s[-1] != 'W':\n        temp.append([gap[-1], n, n - gap[--1] - 1])\n    temp.sort(key=lambda x: x[2])\n    for i in temp:\n        if i[0] == -1:\n            now = i[1] - 1\n            while now >= 0 and k:\n                k -= 1\n                s[now] = 'W'\n                now -= 1\n        else:\n            now = i[0] + 1\n            while now < i[1] and k:\n                s[now] = 'W'\n                k -= 1\n                now += 1\n        if not k:\n            break\n    f = 0\n    ans = 0\n    for i in range(n):\n        if not f and s[i] == 'W':\n            f = 1\n            ans += 1\n        elif f and s[i] == 'W':\n            ans += 2\n        else:\n            f = 0\n    return ans"
    }
  ]
}