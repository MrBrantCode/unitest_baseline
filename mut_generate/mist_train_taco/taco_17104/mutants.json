{
  "task_id": "taco_17104",
  "entry_point": "count_valid_switch_combinations",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 1\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = -1\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 1\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(2 * N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 * N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(2 + N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 + N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [0] / M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] / M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [0] + M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] + M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [0] ** M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] ** M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if temp == P:",
      "mutated_line": "if temp != P:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp != P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(3 ** N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(3 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(1 ** N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(1 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(0 ** N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(0 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(1 ** N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(1 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(2 ** N):",
      "mutated_line": "for i in range(-2 ** N):",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(-2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if i >> h & 1:",
      "mutated_line": "if i >> h | 1:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h | 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] * 2",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] * 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] + 2",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] + 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [1] * M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [1] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [-1] * M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [-1] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "temp = [0] * M",
      "mutated_line": "temp = [1] * M",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [1] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i >> h & 1:",
      "mutated_line": "if i >> h & 2:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 2:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i >> h & 1:",
      "mutated_line": "if i >> h & 0:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 0:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i >> h & 1:",
      "mutated_line": "if i >> h & 0:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 0:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if i >> h & 1:",
      "mutated_line": "if i >> h & -1:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & -1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] % 3",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 3\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] % 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 1\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] % 0",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 0\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] % 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 1\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "temp[k] = temp[k] % 2",
      "mutated_line": "temp[k] = temp[k] % -2",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % -2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h + 1 not in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 not in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "temp[g] += 1",
      "mutated_line": "temp[g] -= 1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] -= 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h - 1 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h - 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h * 1 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h * 1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "temp[g] += 1",
      "mutated_line": "temp[g] += 2",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 2\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "temp[g] += 1",
      "mutated_line": "temp[g] += 0",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 0\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "temp[g] += 1",
      "mutated_line": "temp[g] += 0",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += 0\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "temp[g] += 1",
      "mutated_line": "temp[g] += -1",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 1 in ks[g]:\n                        temp[g] += -1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h + 2 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 2 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h + 0 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 0 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h + 0 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + 0 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if h + 1 in ks[g]:",
      "mutated_line": "if h + -1 in ks[g]:",
      "code": "def count_valid_switch_combinations(N, M, ks, P):\n    ans = 0\n    for i in range(2 ** N):\n        temp = [0] * M\n        for h in range(N):\n            if i >> h & 1:\n                for g in range(M):\n                    if h + -1 in ks[g]:\n                        temp[g] += 1\n        for k in range(M):\n            temp[k] = temp[k] % 2\n        if temp == P:\n            ans += 1\n    return ans"
    }
  ]
}