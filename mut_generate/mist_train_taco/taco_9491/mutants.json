{
  "task_id": "taco_9491",
  "entry_point": "find_safe_moves",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 / 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 + 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 ** 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [0] / n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] / n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [0] + n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] + n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [0] ** n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] ** n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ox += c * x",
      "mutated_line": "ox -= c * x",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox -= c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "oy += c * y",
      "mutated_line": "oy -= c * y",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy -= c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist(ox, oy) <= threshold:",
      "mutated_line": "if dist(ox, oy) < threshold:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) < threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist(ox, oy) <= threshold:",
      "mutated_line": "if dist(ox, oy) > threshold:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) > threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist(ox, oy) <= threshold:",
      "mutated_line": "if dist(ox, oy) == threshold:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) == threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 2.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 0.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 0 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = -1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * (10 * 6)\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * (10 + 6)\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (1, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (-1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (-1, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (1, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (1, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (0, 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 1)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (0, -1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, -1)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ox, oy = 0, 0",
      "mutated_line": "(ox, oy) = (0, 1)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 1)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dis = [abs(x) + abs(y) for x, y in vectors]",
      "mutated_line": "sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) - abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dis = [abs(x) + abs(y) for x, y in vectors]",
      "mutated_line": "sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) * abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n + 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n * 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, +1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, +1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 1\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = -1\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 1\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d1 <= d2:",
      "mutated_line": "if d1 < d2:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 < d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d1 <= d2:",
      "mutated_line": "if d1 > d2:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 > d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d1 <= d2:",
      "mutated_line": "if d1 == d2:",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 == d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ox += c * x",
      "mutated_line": "ox += c / x",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c / x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ox += c * x",
      "mutated_line": "ox += c + x",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c + x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ox += c * x",
      "mutated_line": "ox += c ** x",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c ** x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "oy += c * y",
      "mutated_line": "oy += c / y",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c / y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "oy += c * y",
      "mutated_line": "oy += c + y",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c + y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "oy += c * y",
      "mutated_line": "oy += c ** y",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c ** y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x * x - y * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x - y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x * x * (y * y))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x * (y * y))\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 11 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 9 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 0 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 1 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * -10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 7\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 5\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 0\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 1\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "threshold = 1.5 * 10 ** 6",
      "mutated_line": "(ox, oy) = (0, 0)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** -6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [1] * n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [1] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [-1] * n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [-1] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "choices = [0] * n",
      "mutated_line": "choices = [1] * n",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [1] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 2, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 0, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 0, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - -1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -2, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -0, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -0, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, --1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -2):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -0):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -0):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, --1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ox1, oy1 = ox + x, oy + y",
      "mutated_line": "(ox1, oy1) = (ox - x, oy + y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox - x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ox1, oy1 = ox + x, oy + y",
      "mutated_line": "(ox1, oy1) = (ox * x, oy + y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox * x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ox1, oy1 = ox + x, oy + y",
      "mutated_line": "(ox1, oy1) = (ox + x, oy - y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy - y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ox1, oy1 = ox + x, oy + y",
      "mutated_line": "(ox1, oy1) = (ox + x, oy * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy * y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ox2, oy2 = ox - x, oy - y",
      "mutated_line": "(ox2, oy2) = (ox + x, oy - y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox + x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ox2, oy2 = ox - x, oy - y",
      "mutated_line": "(ox2, oy2) = (ox * x, oy - y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox * x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ox2, oy2 = ox - x, oy - y",
      "mutated_line": "(ox2, oy2) = (ox - x, oy + y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy + y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ox2, oy2 = ox - x, oy - y",
      "mutated_line": "(ox2, oy2) = (ox - x, oy * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy * y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = 1",
      "mutated_line": "c = 2",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 2\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = 1",
      "mutated_line": "c = 0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 0\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = 1",
      "mutated_line": "c = 0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 0\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "c = 1",
      "mutated_line": "c = -1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = -1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "c = -1",
      "mutated_line": "c = +1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = +1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [-1 / choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 / choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [-1 + choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 + choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [(-1) ** choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [(-1) ** choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x / x + y * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x / x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x + x + y * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x + x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x ** x + y * y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x ** x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x * x + y / y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y / y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x * x + (y + y))",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + (y + y))\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(x * x + y * y)",
      "mutated_line": "return math.sqrt(x * x + y ** y)",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y ** y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c = -1",
      "mutated_line": "c = -2",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -2\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c = -1",
      "mutated_line": "c = -0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -0\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c = -1",
      "mutated_line": "c = -0",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -0\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "c = -1",
      "mutated_line": "c = --1",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = --1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-1 * choice for choice in choices]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [+1 * choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [+1 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [-2 * choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-2 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [-0 * choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-0 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [-0 * choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [-0 * choice for choice in choices]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return [-1 * choice for choice in choices]",
      "mutated_line": "return [--1 * choice for choice in choices]",
      "code": "import math\n\ndef find_safe_moves(n, vectors):\n\n    def dist(x, y):\n        return math.sqrt(x * x + y * y)\n    threshold = 1.5 * 10 ** 6\n    (ox, oy) = (0, 0)\n    choices = [0] * n\n    dis = [abs(x) + abs(y) for (x, y) in vectors]\n    sorted_vectors = [vec for (_, vec) in sorted(zip(dis, vectors))]\n    for i in range(n - 1, -1, -1):\n        c = 0\n        (x, y) = sorted_vectors[i]\n        (ox1, oy1) = (ox + x, oy + y)\n        (ox2, oy2) = (ox - x, oy - y)\n        d1 = dist(ox1, oy1)\n        d2 = dist(ox2, oy2)\n        if d1 <= d2:\n            c = 1\n        else:\n            c = -1\n        choices[vectors.index((x, y))] = c\n        ox += c * x\n        oy += c * y\n    if dist(ox, oy) <= threshold:\n        return choices\n    else:\n        return [--1 * choice for choice in choices]"
    }
  ]
}