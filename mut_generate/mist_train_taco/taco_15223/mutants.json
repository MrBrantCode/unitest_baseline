{
  "task_id": "taco_15223",
  "entry_point": "find_max_area",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = 1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = -1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = -1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_area = 0",
      "mutated_line": "max_area = 1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 1\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = -1\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 1\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count -= 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "visited = [[False] * m for _ in range(n)]",
      "mutated_line": "visited = [[False] / m for _ in range(n)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] / m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "visited = [[False] * m for _ in range(n)]",
      "mutated_line": "visited = [[False] + m for _ in range(n)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] + m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "visited = [[False] * m for _ in range(n)]",
      "mutated_line": "visited = [[False] ** m for _ in range(n)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] ** m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited[cx][cy] = True",
      "mutated_line": "visited[cx][cy] = False",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = False\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 2\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 0\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 0\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += -1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[1])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[-1])",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[-1])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[1])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] == 1 or not visited[i][j]:",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 or not visited[i][j]:\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(+1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(+1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, +1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, +1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (-1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (-1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (1, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, +1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, +1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (2, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (2, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (0, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (-1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, +1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, +1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (+1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (+1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, -1), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, -1), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (-1, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (-1, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 2), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 2), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 0), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 0), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 0), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 0), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, -1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, -1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (+1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (+1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 2), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 2), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 0), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 0), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 0), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 0), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, -1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, -1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (2, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (2, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (0, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (0, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (0, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (0, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (-1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (-1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 1), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 1), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, -1), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 1), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 1), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (2, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (2, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (0, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (0, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (0, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (0, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (-1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (-1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 2)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 2)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 0)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 0)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 0)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 0)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, -1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, -1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n or 0 <= ny < m or (not visited[nx][ny]) or (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n or 0 <= ny < m or (not visited[nx][ny]) or (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited = [[False] * m for _ in range(n)]",
      "mutated_line": "visited = [[True] * m for _ in range(n)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[True] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] != 1 and (not visited[i][j]):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if region_area > max_area:",
      "mutated_line": "if region_area >= max_area:",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area >= max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if region_area > max_area:",
      "mutated_line": "if region_area <= max_area:",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area <= max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if region_area > max_area:",
      "mutated_line": "if region_area != max_area:",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area != max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-2, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-2, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-0, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-0, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-0, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-0, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(--1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(--1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -2), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -2), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -0), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -0), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -0), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -0), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, --1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, --1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -2), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -2), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -0), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -0), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -0), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -0), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, --1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, --1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -2), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -2), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -0), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -0), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -0), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -0), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, --1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, --1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-2, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-2, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-0, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-0, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-0, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-0, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (--1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (--1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-2, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-2, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-0, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-0, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-0, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-0, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]",
      "mutated_line": "moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (--1, 1), (1, 0), (1, 1)]",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (--1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx - dx, cy + dy)",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx - dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx * dx, cy + dy)",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx * dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx + dx, cy - dy)",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy - dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx + dx, cy * dy)",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy * dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 < nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 < nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 > nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 > nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 == nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 == nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 < ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 < ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 > ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 > ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 == ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 == ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] != 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] != 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] == 2 and (not visited[i][j]):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 2 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] == 0 and (not visited[i][j]):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] == 0 and (not visited[i][j]):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if grid[i][j] == 1 and not visited[i][j]:",
      "mutated_line": "if grid[i][j] == -1 and (not visited[i][j]):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == -1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if -1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if -1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 1 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and -1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and -1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 1 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 2):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 2):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == 1:",
      "mutated_line": "if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == -1):",
      "code": "def find_max_area(grid):\n\n    def dfs(x, y):\n        moves = [(-1, -1), (0, -1), (1, -1), (-1, 0), (0, 1), (-1, 1), (1, 0), (1, 1)]\n        stack = [(x, y)]\n        count = 0\n        while stack:\n            (cx, cy) = stack.pop()\n            if visited[cx][cy]:\n                continue\n            visited[cx][cy] = True\n            count += 1\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]) and (grid[nx][ny] == -1):\n                    stack.append((nx, ny))\n        return count\n    n = len(grid)\n    m = len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1 and (not visited[i][j]):\n                region_area = dfs(i, j)\n                if region_area > max_area:\n                    max_area = region_area\n    return max_area"
    }
  ]
}