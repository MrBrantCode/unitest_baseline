{
  "task_id": "taco_15902",
  "entry_point": "calculate_max_beauty",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) * 2",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) * 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) + 2",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) + 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p + (min(q_p[0], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p + (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = (sum_A + sum_q_p) * (min(q_p[0], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = (sum_A + sum_q_p) * (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "p -= 1  # Convert to 0-based index",
      "mutated_line": "p += 1",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p += 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "sum_A += x - A[p]",
      "mutated_line": "sum_A -= x - A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A -= x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ls = [b - a for a, b in zip(A, B)]",
      "mutated_line": "ls = [b + a for (a, b) in zip(A, B)]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b + a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ls = [b - a for a, b in zip(A, B)]",
      "mutated_line": "ls = [b * a for (a, b) in zip(A, B)]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b * a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [+v for v in ls[1:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [+v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) % 3",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 3\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) % 1",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 1\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) % 0",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 0\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) % 1",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 1\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "odd = len(q_p) % 2",
      "mutated_line": "odd = len(q_p) % -2",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % -2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A - sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A - sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A * sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A * sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p -= 1  # Convert to 0-based index",
      "mutated_line": "p -= 2",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 2\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p -= 1  # Convert to 0-based index",
      "mutated_line": "p -= 0",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 0\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p -= 1  # Convert to 0-based index",
      "mutated_line": "p -= 0",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 0\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "p -= 1  # Convert to 0-based index",
      "mutated_line": "p -= -1",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= -1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "v = y - x",
      "mutated_line": "v = y + x",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y + x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "v = y - x",
      "mutated_line": "v = y * x",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y * x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sum_A += x - A[p]",
      "mutated_line": "sum_A += x + A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x + A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sum_A += x - A[p]",
      "mutated_line": "sum_A += x * A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x * A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 and p == 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 and p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ans += x - A[p]",
      "mutated_line": "ans -= x - A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans -= x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) | (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) | (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v > 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v > 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v < 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v < 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v == 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v == 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "sum_q_p += v",
      "mutated_line": "sum_q_p -= v",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p -= v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] > 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] > 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] < 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] < 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] == 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] == 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "sum_q_p -= ls[p]",
      "mutated_line": "sum_q_p += ls[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p += ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v > 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v > 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v < 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v < 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v == 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v == 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = sum_q_p + sum_A",
      "mutated_line": "ans = sum_q_p - sum_A",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p - sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = sum_q_p + sum_A",
      "mutated_line": "ans = sum_q_p * sum_A",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p * sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans += min(q_p[0], q_m[0])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans += min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v <= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v <= 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v >= 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v != 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v != 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v > 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v > 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v < 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v == 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v == 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 1)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else -1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else -1)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 1)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p != 0 or p == 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p != 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p != 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p != 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans += x - A[p]",
      "mutated_line": "ans += x + A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x + A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans += x - A[p]",
      "mutated_line": "ans += x * A[p]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x * A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] > 0) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] > 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] < 0) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] < 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] == 0) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] == 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v > 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v > 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v < 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v < 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v == 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v == 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 1:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= -1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= -1:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 1:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 1:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] >= -1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= -1:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ls[p] >= 0:",
      "mutated_line": "if ls[p] >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 1:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 1:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= -1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= -1:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if v >= 0:",
      "mutated_line": "if v >= 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 1:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "while q_p[0] in to_remove:",
      "mutated_line": "while q_p[0] not in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] not in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while -q_m[0] in to_remove:",
      "mutated_line": "while -q_m[0] not in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] not in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v < 1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 1]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v < -1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < -1]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-1] if v < 1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 1]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v >= 1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 1]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v >= -1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= -1]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-1] if v >= 1]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 1]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 1 or p == 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 1 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == -1 or p == 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == -1 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 1 or p == 2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 1 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N + 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N + 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N * 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N * 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 1) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 1) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= -1) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= -1) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 1) ^ (v >= 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 1) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v >= 1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 1)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v >= -1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= -1)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "odd ^= (ls[p] >= 0) ^ (v >= 0)",
      "mutated_line": "odd ^= (ls[p] >= 0) ^ (v >= 1)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 1)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "heapq.heappush(q_m, -v)",
      "mutated_line": "heapq.heappush(q_m, +v)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, +v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "while -q_m[0] in to_remove:",
      "mutated_line": "while +q_m[0] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while +q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[2:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[2:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[0:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[0:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[0:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[0:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[-1:-1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[-1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:+1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:+1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[2:-1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[2:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[0:-1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[0:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[0:-1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[0:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[-1:-1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[-1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:+1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:+1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[1], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[1], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[-1], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[-1], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[1], q_m[0]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[1], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[1]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[1]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[-1]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[-1]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)",
      "mutated_line": "ans = sum_A + sum_q_p - (min(q_p[0], q_m[1]) if odd else 0)",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[1]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 / N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 / N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 + N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 + N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 ** N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 ** N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N - 2:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 2:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N - 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 0:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N - 0:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 0:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 2 * N - -1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - -1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "while q_p[0] in to_remove:",
      "mutated_line": "while q_p[1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[1] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "while q_p[0] in to_remove:",
      "mutated_line": "while q_p[-1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[-1] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "while q_p[0] in to_remove:",
      "mutated_line": "while q_p[1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[1] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 53,
      "original_line": "to_remove.remove(-heapq.heappop(q_m))",
      "mutated_line": "to_remove.remove(+heapq.heappop(q_m))",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(+heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[1], q_m[0])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[1], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[-1], q_m[0])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[-1], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[1], q_m[0])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[1], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[0], q_m[1])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[1])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[0], q_m[-1])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[-1])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans -= min(q_p[0], q_m[0])",
      "mutated_line": "ans -= min(q_p[0], q_m[1])",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[1])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-2] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-2] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-0] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-0] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:-0] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-0] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q_m = [-v for v in ls[1:-1] if v < 0]",
      "mutated_line": "q_m = [-v for v in ls[1:--1] if v < 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:--1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-2] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-2] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-0] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-0] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:-0] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-0] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q_p = [v for v in ls[1:-1] if v >= 0]",
      "mutated_line": "q_p = [v for v in ls[1:--1] if v >= 0]",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:--1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 3 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 3 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 1 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 1 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 0 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 0 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == 1 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 1 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0 or p == 2 * N - 1:",
      "mutated_line": "if p == 0 or p == -2 * N - 1:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == -2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while -q_m[0] in to_remove:",
      "mutated_line": "while -q_m[1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[1] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while -q_m[0] in to_remove:",
      "mutated_line": "while -q_m[-1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[-1] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "while -q_m[0] in to_remove:",
      "mutated_line": "while -q_m[1] in to_remove:",
      "code": "import heapq\n\ndef calculate_max_beauty(N, Q, A, B, queries):\n    ls = [b - a for (a, b) in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapq.heapify(q_m)\n    heapq.heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    Ans = []\n    for (p, x, y) in queries:\n        p -= 1\n        v = y - x\n        sum_A += x - A[p]\n        if p == 0 or p == 2 * N - 1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heapq.heappush(q_p, v)\n        else:\n            heapq.heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heapq.heappop(q_p))\n            while -q_m[1] in to_remove:\n                to_remove.remove(-heapq.heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    return Ans"
    }
  ]
}