{
  "task_id": "taco_5956",
  "entry_point": "find_top_block",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "a = [0] + a  # Adjust the list to start from index 1",
      "mutated_line": "a = [0] - a",
      "code": "def find_top_block(N, a):\n    a = [0] - a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "a = [0] + a  # Adjust the list to start from index 1",
      "mutated_line": "a = [0] * a",
      "code": "def find_top_block(N, a):\n    a = [0] * a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [False] * len(a)",
      "mutated_line": "b = [False] / len(a)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] / len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [False] * len(a)",
      "mutated_line": "b = [False] + len(a)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] + len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [False] * len(a)",
      "mutated_line": "b = [False] ** len(a)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] ** len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) or l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) or l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) / 2",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) / 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) * 2",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) * 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small < 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small < 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small > 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small > 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small == 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(3, 2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(3, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(1, 2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(1, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(0, 2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(0, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(1, 2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(1, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(-2, 2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(-2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N + 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N + 2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N * 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N * 2)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [0] + a  # Adjust the list to start from index 1",
      "mutated_line": "a = [1] + a",
      "code": "def find_top_block(N, a):\n    a = [1] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [0] + a  # Adjust the list to start from index 1",
      "mutated_line": "a = [-1] + a",
      "code": "def find_top_block(N, a):\n    a = [-1] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "a = [0] + a  # Adjust the list to start from index 1",
      "mutated_line": "a = [1] + a",
      "code": "def find_top_block(N, a):\n    a = [1] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(2, len(a)):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(2, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(0, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(0, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(-1, len(a)):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(-1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if a[i] >= n:",
      "mutated_line": "if a[i] > n:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] > n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if a[i] >= n:",
      "mutated_line": "if a[i] < n:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] < n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if a[i] >= n:",
      "mutated_line": "if a[i] == n:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] == n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = int(1000000000.0)",
      "mutated_line": "r = int(1000000001.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000001.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = int(1000000000.0)",
      "mutated_line": "r = int(999999999.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(999999999.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = int(1000000000.0)",
      "mutated_line": "r = int(0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = int(1000000000.0)",
      "mutated_line": "r = int(1)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = int(1000000000.0)",
      "mutated_line": "r = int(-1000000000.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(-1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l = int(1000000000.0)",
      "mutated_line": "l = int(1000000001.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000001.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l = int(1000000000.0)",
      "mutated_line": "l = int(999999999.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(999999999.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l = int(1000000000.0)",
      "mutated_line": "l = int(0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l = int(1000000000.0)",
      "mutated_line": "l = int(1)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l = int(1000000000.0)",
      "mutated_line": "l = int(-1000000000.0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(-1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(2, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(0, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(0, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(-1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if lb == b[N - i]:",
      "mutated_line": "if lb != b[N - i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb != b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(2, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(0, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(0, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(-1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if rb == b[N + i]:",
      "mutated_line": "if rb != b[N + i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb != b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r != int(1000000000.0) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r != int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l != int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l != int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 != 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 != 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif r < l:",
      "mutated_line": "elif r <= l:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r <= l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif r < l:",
      "mutated_line": "elif r >= l:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r >= l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif r < l:",
      "mutated_line": "elif r != l:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r != l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big - small) // 2",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big - small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = big * small // 2",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = big * small // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) // 3",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 3\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) // 1",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 1\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) // 0",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 0\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) // 1",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 1\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "mid = (big + small) // 2",
      "mutated_line": "mid = (big + small) // -2",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // -2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big + small <= 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big + small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big * small <= 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big * small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small <= 2:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 2:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small <= 0:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 0:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small <= 0:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 0:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if big - small <= 1:",
      "mutated_line": "if big - small <= -1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= -1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 / N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 / N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 + N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 + N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 ** N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 ** N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N - 3)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 3)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N - 1)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N - 0)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N - 1)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 2 * N - -2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - -2)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = [False] * len(a)",
      "mutated_line": "b = [True] * len(a)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [True] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b[i] = True",
      "mutated_line": "b[i] = False",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = False\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b[i] = False",
      "mutated_line": "b[i] = True",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = True\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N * 2 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N * 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N + 2 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N + 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 2:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 2:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 0:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 0:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == 0:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 0:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 2 == -1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == -1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 3 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 3 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 1 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 1 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 0 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 0 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, 1 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 1 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return binarySearch(2, 2 * N - 2)",
      "mutated_line": "return binarySearch(2, -2 * N - 2)",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, -2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if lb == b[N - i]:",
      "mutated_line": "if lb == b[N + i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N + i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if lb == b[N - i]:",
      "mutated_line": "if lb == b[N * i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N * i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lb = b[N - i]",
      "mutated_line": "lb = b[N + i]",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N + i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "lb = b[N - i]",
      "mutated_line": "lb = b[N * i]",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N * i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if rb == b[N + i]:",
      "mutated_line": "if rb == b[N - i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N - i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if rb == b[N + i]:",
      "mutated_line": "if rb == b[N * i]:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N * i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "rb = b[N + i]",
      "mutated_line": "rb = b[N - i]",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N - i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "rb = b[N + i]",
      "mutated_line": "rb = b[N * i]",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N * i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000001.0) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000001.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(999999999.0) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(999999999.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(0) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(-1000000000.0) and l == int(1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(-1000000000.0) and l == int(1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l == int(1000000001.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000001.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l == int(999999999.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(999999999.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l == int(0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l == int(1):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if r == int(1000000000.0) and l == int(1000000000.0):",
      "mutated_line": "if r == int(1000000000.0) and l == int(-1000000000.0):",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(-1000000000.0):\n            if N % 2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 3 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 3 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 1 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 1 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 0 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 0 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % 1 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % 1 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if N % 2 == 1:",
      "mutated_line": "if N % -2 == 1:",
      "code": "def find_top_block(N, a):\n    a = [0] + a\n\n    def check(n):\n        b = [False] * len(a)\n        for i in range(1, len(a)):\n            if a[i] >= n:\n                b[i] = True\n            else:\n                b[i] = False\n        r = int(1000000000.0)\n        l = int(1000000000.0)\n        rb = b[N]\n        lb = b[N]\n        for i in range(1, N):\n            if lb == b[N - i]:\n                l = i\n                break\n            else:\n                lb = b[N - i]\n        for i in range(1, N):\n            if rb == b[N + i]:\n                r = i\n                break\n            else:\n                rb = b[N + i]\n        if r == int(1000000000.0) and l == int(1000000000.0):\n            if N % -2 == 1:\n                return b[N]\n            else:\n                return not b[N]\n        elif r < l:\n            return rb\n        else:\n            return lb\n\n    def binarySearch(small, big):\n        mid = (big + small) // 2\n        if big - small <= 1:\n            if check(small):\n                return small\n            else:\n                return big\n        elif not check(mid):\n            return binarySearch(small, mid)\n        else:\n            return binarySearch(mid, big)\n    return binarySearch(2, 2 * N - 2)"
    }
  ]
}