{
  "task_id": "taco_14319",
  "entry_point": "calculate_min_coins",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) + 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) + 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) * 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) * 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if 0 < index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 < index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if 0 > index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 > index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if 0 == index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 == index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if index2 < len(hero_strengths):",
      "mutated_line": "if index2 <= len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 <= len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if index2 < len(hero_strengths):",
      "mutated_line": "if index2 >= len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 >= len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if index2 < len(hero_strengths):",
      "mutated_line": "if index2 != len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 != len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) - 2",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 2\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) - 0",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 0\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) - 0",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 0\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 1) - -1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - -1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if 1 <= index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 1 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if -1 <= index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if -1 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= index1 < len(hero_strengths):",
      "mutated_line": "if 1 <= index1 < len(hero_strengths):",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 1 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "tot1 = total_strength - hero_strengths[index1]",
      "mutated_line": "tot1 = total_strength + hero_strengths[index1]",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength + hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "tot1 = total_strength - hero_strengths[index1]",
      "mutated_line": "tot1 = total_strength * hero_strengths[index1]",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength * hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "tot1 = total_strength - hero_strengths[index2]",
      "mutated_line": "tot1 = total_strength + hero_strengths[index2]",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength + hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "tot1 = total_strength - hero_strengths[index2]",
      "mutated_line": "tot1 = total_strength * hero_strengths[index2]",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength * hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x - 1) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x - 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x * 1) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x * 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "req1 = max(0, x - hero_strengths[index1])",
      "mutated_line": "req1 = max(1, x - hero_strengths[index1])",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(1, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "req1 = max(0, x - hero_strengths[index1])",
      "mutated_line": "req1 = max(-1, x - hero_strengths[index1])",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(-1, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "req1 = max(0, x - hero_strengths[index1])",
      "mutated_line": "req1 = max(1, x - hero_strengths[index1])",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(1, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "req1 = max(0, x - hero_strengths[index1])",
      "mutated_line": "req1 = max(0, x + hero_strengths[index1])",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x + hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "req1 = max(0, x - hero_strengths[index1])",
      "mutated_line": "req1 = max(0, x * hero_strengths[index1])",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x * hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "req2 = max(0, y - tot1)",
      "mutated_line": "req2 = max(1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(1, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "req2 = max(0, y - tot1)",
      "mutated_line": "req2 = max(-1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(-1, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "req2 = max(0, y - tot1)",
      "mutated_line": "req2 = max(1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(1, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "req2 = max(0, y - tot1)",
      "mutated_line": "req2 = max(0, y + tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y + tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "req2 = max(0, y - tot1)",
      "mutated_line": "req2 = max(0, y * tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y * tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "mini = min(mini, req1 + req2)",
      "mutated_line": "mini = min(mini, req1 - req2)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 - req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "mini = min(mini, req1 + req2)",
      "mutated_line": "mini = min(mini, req1 * req2)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 * req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "req = max(0, y - tot1)",
      "mutated_line": "req = max(1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(1, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "req = max(0, y - tot1)",
      "mutated_line": "req = max(-1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(-1, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "req = max(0, y - tot1)",
      "mutated_line": "req = max(1, y - tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(1, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "req = max(0, y - tot1)",
      "mutated_line": "req = max(0, y + tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y + tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "req = max(0, y - tot1)",
      "mutated_line": "req = max(0, y * tot1)",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y * tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 2) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 2) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 0) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 0) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + 0) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + 0) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "index1 = bisect_left(hero_strengths, x + 1) - 1",
      "mutated_line": "index1 = bisect_left(hero_strengths, x + -1) - 1",
      "code": "from bisect import bisect_left, bisect_right\nfrom math import inf\n\ndef calculate_min_coins(hero_strengths, dragon_defenses, dragon_attacks):\n    hero_strengths.sort()\n    total_strength = sum(hero_strengths)\n    min_coins_needed = []\n    for (x, y) in zip(dragon_defenses, dragon_attacks):\n        index1 = bisect_left(hero_strengths, x + -1) - 1\n        index2 = bisect_right(hero_strengths, x)\n        mini = inf\n        if 0 <= index1 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index1]\n            req1 = max(0, x - hero_strengths[index1])\n            req2 = max(0, y - tot1)\n            mini = min(mini, req1 + req2)\n        if index2 < len(hero_strengths):\n            tot1 = total_strength - hero_strengths[index2]\n            req = max(0, y - tot1)\n            mini = min(mini, req)\n        min_coins_needed.append(mini)\n    return min_coins_needed"
    }
  ]
}