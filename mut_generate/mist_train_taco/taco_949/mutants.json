{
  "task_id": "taco_949",
  "entry_point": "diff",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[1:] - [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] - [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[1:] * [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] * [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return [i for i in li1 if i not in li2]",
      "mutated_line": "return [i for i in li1 if i in li2]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(2, len(b)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(2, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(0, len(b)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(0, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(0, len(b)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(0, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, len(b)):",
      "mutated_line": "for i in range(-1, len(b)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(-1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if av(i) >= perimeter(diff(b, i)):",
      "mutated_line": "if av(i) > perimeter(diff(b, i)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) > perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if av(i) >= perimeter(diff(b, i)):",
      "mutated_line": "if av(i) < perimeter(diff(b, i)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) < perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if av(i) >= perimeter(diff(b, i)):",
      "mutated_line": "if av(i) == perimeter(diff(b, i)):",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) == perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) - 1 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) - 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) * 1 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) * 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) + perimeter(diff(b, yes[0])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) + perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) * perimeter(diff(b, yes[0])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) * perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 3)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 3)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 1)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 1)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 0)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 0)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 1)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 1)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), -2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), -2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[1], i[1]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[1], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[-1], i[1]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[-1], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[1], i[1]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[1], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[0], i[2]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[2]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[0], i[0]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[0]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[0], i[0]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[0]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "poly = [(i[0], i[1]) for i in b]",
      "mutated_line": "poly = [(i[0], i[-1]) for i in b]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[-1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return sum([i[3] for i in b])",
      "mutated_line": "return sum([i[4] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[4] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return sum([i[3] for i in b])",
      "mutated_line": "return sum([i[2] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[2] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return sum([i[3] for i in b])",
      "mutated_line": "return sum([i[0] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[0] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return sum([i[3] for i in b])",
      "mutated_line": "return sum([i[1] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[1] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return sum([i[3] for i in b])",
      "mutated_line": "return sum([i[-3] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[-3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([i[2] for i in b])",
      "mutated_line": "return sum([i[3] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[3] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([i[2] for i in b])",
      "mutated_line": "return sum([i[1] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[1] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([i[2] for i in b])",
      "mutated_line": "return sum([i[0] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[0] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([i[2] for i in b])",
      "mutated_line": "return sum([i[1] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[1] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum([i[2] for i in b])",
      "mutated_line": "return sum([i[-2] for i in b])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[-2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 2 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 2 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 0 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 0 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 0 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 0 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + -1 for i in yes[0]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + -1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[2:] + [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[2:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[0:] + [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[0:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[0:] + [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[0:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[-1:] + [poly[0]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[-1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[1:] + [poly[1]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[1]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[1:] + [poly[-1]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[-1]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return zip(poly, poly[1:] + [poly[0]])",
      "mutated_line": "return zip(poly, poly[1:] + [poly[1]])",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[1]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "mutated_line": "return abs(sum((math.hypot(x0 + x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 + x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "mutated_line": "return abs(sum((math.hypot(x0 * x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 * x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "mutated_line": "return abs(sum((math.hypot(x0 - x1, y0 + y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 + y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "mutated_line": "return abs(sum((math.hypot(x0 - x1, y0 * y1) for ((x0, y0), (x1, y1)) in segments(poly))))",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 * y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 1 for i in yes[1]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[1]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 1 for i in yes[-1]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[-1]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "demolished_indices = [b.index(i) + 1 for i in yes[0]]",
      "mutated_line": "demolished_indices = [b.index(i) + 1 for i in yes[1]]",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[1]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[1]) - perimeter(diff(b, yes[0])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[1]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[-1]) - perimeter(diff(b, yes[0])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[-1]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[1]) - perimeter(diff(b, yes[0])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[1]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[1])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[1])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[-1])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[-1])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)",
      "mutated_line": "excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[1])), 2)",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[1])), 2)\n        results.append((demolished_indices, f'{excess_boundary:.2f}'))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append((demolished_indices, f'{excess_boundary:.2f}'))",
      "mutated_line": "results.append((demolished_indices, f'{excess_boundary:}'))",
      "code": "import math\nfrom itertools import permutations\n\ndef diff(li1, li2):\n    return [i for i in li1 if i not in li2]\n\ndef segments(b):\n    poly = [(i[0], i[1]) for i in b]\n    return zip(poly, poly[1:] + [poly[0]])\n\ndef perimeter(poly):\n    return abs(sum((math.hypot(x0 - x1, y0 - y1) for ((x0, y0), (x1, y1)) in segments(poly))))\n\ndef av(b):\n    return sum([i[3] for i in b])\n\ndef val(b):\n    return sum([i[2] for i in b])\n\ndef find_optimal_demolition(test_cases):\n    results = []\n    for b in test_cases:\n        perm = []\n        for i in range(1, len(b)):\n            for e in permutations(b, i):\n                perm.append(e)\n        perm.sort(key=lambda x: val(x))\n        yes = []\n        for i in perm:\n            if av(i) >= perimeter(diff(b, i)):\n                good = val(i)\n                yes.append(i)\n                break\n        demolished_indices = [b.index(i) + 1 for i in yes[0]]\n        excess_boundary = round(av(yes[0]) - perimeter(diff(b, yes[0])), 2)\n        results.append((demolished_indices, f'{excess_boundary:}'))\n    return results"
    }
  ]
}