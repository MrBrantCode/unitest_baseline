{
  "task_id": "taco_6105",
  "entry_point": "count_equal_beauty_partitions",
  "mutant_count": 172,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 - 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 * 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] / N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] / N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] + N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] + N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [0] ** N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] ** N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] / (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] / (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] + (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] + (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] ** (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] ** (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] / (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] / (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] + (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] + (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] ** (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] ** (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "z = 0",
      "mutated_line": "z = 1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 1\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "z = 0",
      "mutated_line": "z = -1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = -1\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "z = 0",
      "mutated_line": "z = 1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 1\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] -= dp[1][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] -= dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[1][b[i]] -= dp[0][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] -= dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 1] == 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] == 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 * 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 + 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 8\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 6\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 0\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 1\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + -7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[1] = A[0]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[1] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[-1] = A[0]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[-1] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[1] = A[0]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[1] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[0] = A[1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[1]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[0] = A[-1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[-1]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b[0] = A[0]",
      "mutated_line": "b[0] = A[1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[1]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(1, N):",
      "mutated_line": "for n in range(2, N):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(2, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(1, N):",
      "mutated_line": "for n in range(0, N):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(0, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(1, N):",
      "mutated_line": "for n in range(0, N):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(0, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(1, N):",
      "mutated_line": "for n in range(-1, N):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(-1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] | b[n - 1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] | b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] / (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] / (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] + (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] + (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] ** (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] ** (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[1] = [1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[1] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[-1] = [1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[-1] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[1] = [1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[1] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m - 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m - 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m * 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m * 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m - 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m - 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m * 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m * 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if b[i] == 0:",
      "mutated_line": "if b[i] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] != 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "z += 1",
      "mutated_line": "z -= 1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z -= 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[1][b[i]] / (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] / (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[1][b[i]] + (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] + (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[1][b[i]] ** (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] ** (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 1] != 1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 1:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 1] != -1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != -1:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 1] != 1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 1:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ans += dp[1][i]",
      "mutated_line": "ans -= dp[1][i]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans -= dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 11 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 9 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 0 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 1 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = -10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 10 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 8 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 0 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 1 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** -9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [1] * N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [1] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [-1] * N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [-1] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b = [0] * N",
      "mutated_line": "b = [1] * N",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [1] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m - 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m - 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m * 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m * 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [2] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [2] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [0] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [0] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [0] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [0] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [-1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [-1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m + 2)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 2)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m + 0)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 0)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m + 0)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 0)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = [1] * (m + 1)",
      "mutated_line": "dp[0] = [1] * (m + -1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + -1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [1] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [-1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [-1] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [1] * (m + 1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [1] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m + 2)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 2)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m + 0)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 0)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m + 0)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 0)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = [0] * (m + 1)",
      "mutated_line": "cnt = [0] * (m + -1)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + -1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if b[i] == 0:",
      "mutated_line": "if b[i] == 1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 1:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if b[i] == 0:",
      "mutated_line": "if b[i] == -1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == -1:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if b[i] == 0:",
      "mutated_line": "if b[i] == 1:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 1:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z += 1",
      "mutated_line": "z += 2",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 2\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 0\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 0\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z += 1",
      "mutated_line": "z += -1",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += -1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[1][b[i]] * (z + cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z + cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[1][b[i]] * (z * cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z * cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N + 1] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N + 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N * 1] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N * 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(3, z - 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(3, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(1, z - 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(1, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(0, z - 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(0, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(1, z - 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(1, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(-2, z - 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(-2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z + 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z + 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z * 1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z * 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(2, m + 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(2, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(0, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(0, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(-1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m - 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m - 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m * 1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m * 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n + 1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n + 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n * 1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n * 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[1] * (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[1] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[-1] * (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[-1] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[1] * (m + 1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[1] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 2) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 2) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 0) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 0) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 0) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 0) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + -1) for _ in range(2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + -1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 1) for _ in range(3)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(3)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 1) for _ in range(1)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(1)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 1) for _ in range(0)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(0)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 1) for _ in range(1)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(1)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [[0] * (m + 1) for _ in range(2)]",
      "mutated_line": "dp = [[0] * (m + 1) for _ in range(-2)]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(-2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[-1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[-1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[1][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[0][b[i]] %= mod",
      "mutated_line": "dp[1][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[1][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[0][b[i]] %= mod",
      "mutated_line": "dp[-1][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[-1][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[0][b[i]] %= mod",
      "mutated_line": "dp[1][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[1][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[2][b[i]] += dp[0][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[2][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[0][b[i]] += dp[0][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[0][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[0][b[i]] += dp[0][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[0][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[-1][b[i]] += dp[0][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[-1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[1][b[i]] += dp[1][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[1][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[1][b[i]] += dp[-1][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[-1][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[1][b[i]] += dp[0][b[i]]",
      "mutated_line": "dp[1][b[i]] += dp[1][b[i]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[1][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[1][b[i]] %= mod",
      "mutated_line": "dp[2][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[2][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[1][b[i]] %= mod",
      "mutated_line": "dp[0][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[0][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[1][b[i]] %= mod",
      "mutated_line": "dp[0][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[0][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[1][b[i]] %= mod",
      "mutated_line": "dp[-1][b[i]] %= mod",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[-1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 2] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 2] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 0] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 0] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - 0] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 0] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if b[N - 1] != 0:",
      "mutated_line": "if b[N - -1] != 0:",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - -1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[1][b[N - 1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[1][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[-1][b[N - 1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[-1][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[1][b[N - 1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[1][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N + 1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N + 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N * 1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N * 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z - 2, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 2, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z - 0, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 0, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z - 0, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 0, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = pow(2, z - 1, mod)",
      "mutated_line": "ans = pow(2, z - -1, mod)",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - -1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 2):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 2):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 0):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 0):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + -1):",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + -1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n - 2]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 2]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n - 0]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 0]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n - 0]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 0]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b[n] = A[n] ^ b[n - 1]",
      "mutated_line": "b[n] = A[n] ^ b[n - -1]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - -1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[2][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[2][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[0][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[0][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[0][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[0][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])",
      "mutated_line": "dp[0][b[i]] += dp[-1][b[i]] * (z - cnt[b[i]])",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[-1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N - 2]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 2]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N - 0]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 0]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N - 0]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 0]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return dp[0][b[N - 1]]",
      "mutated_line": "return dp[0][b[N - -1]]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - -1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[1][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += dp[1][i]",
      "mutated_line": "ans += dp[2][i]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[2][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += dp[1][i]",
      "mutated_line": "ans += dp[0][i]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[0][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += dp[1][i]",
      "mutated_line": "ans += dp[0][i]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[0][i]\n            ans %= mod\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += dp[1][i]",
      "mutated_line": "ans += dp[-1][i]",
      "code": "def count_equal_beauty_partitions(N, A):\n    mod = 10 ** 9 + 7\n    b = [0] * N\n    b[0] = A[0]\n    for n in range(1, N):\n        b[n] = A[n] ^ b[n - 1]\n    m = max(b)\n    dp = [[0] * (m + 1) for _ in range(2)]\n    dp[0] = [1] * (m + 1)\n    cnt = [0] * (m + 1)\n    z = 0\n    for i in range(N):\n        if b[i] == 0:\n            z += 1\n        dp[0][b[i]] += dp[1][b[i]] * (z - cnt[b[i]])\n        dp[0][b[i]] %= mod\n        dp[1][b[i]] += dp[0][b[i]]\n        dp[1][b[i]] %= mod\n        cnt[b[i]] = z\n    if b[N - 1] != 0:\n        return dp[0][b[N - 1]]\n    else:\n        ans = pow(2, z - 1, mod)\n        for i in range(1, m + 1):\n            ans += dp[-1][i]\n            ans %= mod\n        return ans"
    }
  ]
}