{
  "task_id": "taco_16973",
  "entry_point": "can_lock_return_to_zero",
  "mutant_count": 75,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(1, 2 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(1, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(-1, 2 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(-1, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(1, 2 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(1, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 2 * n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 * n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 2 + n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 + n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(binary1) < q:",
      "mutated_line": "if len(binary1) <= q:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) <= q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(binary1) < q:",
      "mutated_line": "if len(binary1) >= q:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) >= q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(binary1) < q:",
      "mutated_line": "if len(binary1) != q:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) != q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 1\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = -1\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 1\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l -= 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 and sum(a) % 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 and sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 3 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 3 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 1 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 1 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 0 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 0 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, 1 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 1 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(0, 2 ** n):",
      "mutated_line": "for i in range(0, -2 ** n):",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, -2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] * (q - len(binary1)) - binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) - binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] * (q - len(binary1)) * binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) * binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if j == '1':",
      "mutated_line": "if j != '1':",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j != '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 2\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 0\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 0\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += -1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) != 0 or sum(a) % 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) != 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 360 != 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 != 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return ''\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] / (q - len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] / (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] + (q - len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] + (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] ** (q - len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] ** (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if j == '1':",
      "mutated_line": "if j == '':",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = -1 / a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 / a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = -1 + a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 + a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = (-1) ** a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = (-1) ** a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 1 or sum(a) % 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 1 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == -1 or sum(a) % 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == -1 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 1 or sum(a) % 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 1 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) * 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) * 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) + 360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) + 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 360 == 1:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 1:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 360 == -1:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == -1:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 360 == 1:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 1:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "binary1 = list(bin(i)[2:])",
      "mutated_line": "binary1 = list(bin(i)[3:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[3:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "binary1 = list(bin(i)[2:])",
      "mutated_line": "binary1 = list(bin(i)[1:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[1:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "binary1 = list(bin(i)[2:])",
      "mutated_line": "binary1 = list(bin(i)[0:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[0:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "binary1 = list(bin(i)[2:])",
      "mutated_line": "binary1 = list(bin(i)[1:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[1:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "binary1 = list(bin(i)[2:])",
      "mutated_line": "binary1 = list(bin(i)[-2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[-2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 * n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 * n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 + n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 + n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 ** n)[3:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[3:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 ** n)[1:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[1:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 ** n)[0:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[0:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 ** n)[1:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[1:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(2 ** n)[-2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[-2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] * (q + len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q + len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = ['0'] * (q * len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q * len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = +1 * a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = +1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 361 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 361 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 359 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 359 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 0 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 0 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % 1 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 1 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if sum(a) == 0 or sum(a) % 360 == 0:",
      "mutated_line": "if sum(a) == 0 or sum(a) % -360 == 0:",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % -360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(3 ** n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(3 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(1 ** n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(1 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(0 ** n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(0 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(1 ** n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(1 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = len(bin(2 ** n)[2:])",
      "mutated_line": "q = len(bin(-2 ** n)[2:])",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(-2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary1 = ['0'] * (q - len(binary1)) + binary1",
      "mutated_line": "binary1 = [''] * (q - len(binary1)) + binary1",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = [''] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = -2 * a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -2 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = -0 * a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -0 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = -0 * a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = -0 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "a[l] = -1 * a[l]",
      "mutated_line": "a[l] = --1 * a[l]",
      "code": "def can_lock_return_to_zero(n, angles):\n    \"\"\"\n    Determines if it is possible to perform n rotations with the given angles\n    such that the pointer on the lock returns to zero.\n\n    Parameters:\n    n (int): The number of rotations.\n    angles (list of int): A list of integers where each integer represents the angle of the i-th rotation in degrees.\n\n    Returns:\n    str: \"YES\" if it is possible to perform the rotations such that the pointer will point at zero, otherwise \"NO\".\n    \"\"\"\n    for i in range(0, 2 ** n):\n        a = angles[:]\n        binary1 = list(bin(i)[2:])\n        q = len(bin(2 ** n)[2:])\n        if len(binary1) < q:\n            binary1 = ['0'] * (q - len(binary1)) + binary1\n        l = 0\n        for (k, j) in zip(a, binary1):\n            if j == '1':\n                a[l] = --1 * a[l]\n            l += 1\n        if sum(a) == 0 or sum(a) % 360 == 0:\n            return 'YES'\n    return 'NO'"
    }
  ]
}