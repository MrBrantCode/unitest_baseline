{
  "task_id": "taco_6111",
  "entry_point": "max_intersections",
  "mutant_count": 134,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 1\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = -1\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 1\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if n == k:",
      "mutated_line": "if n != k:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n != k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [+1 for _ in range(2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [+1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 1] = 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 2\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 1] = 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 0\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 1] = 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 0\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 1] = -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = -1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(2 / n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 / n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(2 + n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 + n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(2 ** n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 ** n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] > 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] > 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] < 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] < 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] == 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] == 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while group_num < n:",
      "mutated_line": "while group_num <= n:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num <= n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while group_num < n:",
      "mutated_line": "while group_num >= n:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num >= n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while group_num < n:",
      "mutated_line": "while group_num != n:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num != n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "group_num += 1",
      "mutated_line": "group_num -= 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num -= 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "index += 1",
      "mutated_line": "index -= 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index -= 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 1\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = -1\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "temp = 0",
      "mutated_line": "temp = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 1\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-2 for _ in range(2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-2 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-0 for _ in range(2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-0 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-0 for _ in range(2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-0 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [--1 for _ in range(2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [--1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u + 1] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u + 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u * 1] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u * 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v + 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v + 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v * 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v * 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(3 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(3 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(1 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(0 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(0 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(1 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for start in range(2 * n):",
      "mutated_line": "for start in range(-2 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(-2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] >= 1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 1:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] >= -1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= -1:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if group[start] >= 0:",
      "mutated_line": "if group[start] >= 1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 1:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] > 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] > 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] < 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] < 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] == 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] == 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "index += 1",
      "mutated_line": "index -= 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index -= 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "group_num += 1",
      "mutated_line": "group_num += 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 2\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "group_num += 1",
      "mutated_line": "group_num += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 0\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "group_num += 1",
      "mutated_line": "group_num += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 0\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "group_num += 1",
      "mutated_line": "group_num += -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += -1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "index += 1",
      "mutated_line": "index += 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 2\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 0\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 0\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "index += 1",
      "mutated_line": "index += -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += -1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 / n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 / n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 + n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 + n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 ** n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 ** n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = False\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 / n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 / n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 + n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 + n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 ** n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 ** n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = False\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(2 / n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 / n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(2 + n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 + n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(2 ** n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 ** n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 2] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 2] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 0] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 0] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 0] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 0] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - -1] = group[v - 1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - -1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 2] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 2] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 0] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 0] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - 0] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 0] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "group[u - 1] = group[v - 1] = 1  # Mark initial chords",
      "mutated_line": "group[u - 1] = group[v - -1] = 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - -1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] >= 1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 1:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] >= -1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= -1:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 * n)] >= 1:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 1:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index += 1",
      "mutated_line": "index += 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 2\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 0\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index += 1",
      "mutated_line": "index += 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 0\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "index += 1",
      "mutated_line": "index += -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += -1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index * (2 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index * (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index + 2 * n] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index + 2 * n] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(3 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(3 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(1 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(0 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(0 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(1 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(-2 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(-2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if nums[j] == copy_group[i]:",
      "mutated_line": "if nums[j] != copy_group[i]:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] != copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp -= len(nums) - j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp -= len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(3 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(3 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(1 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(0 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(0 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(1 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(-2 * n):",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(-2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if nums[j] == group[i]:",
      "mutated_line": "if nums[j] != group[i]:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] != group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans -= len(nums) - j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans -= len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(3 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(3 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(1 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(1 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(0 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(0 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(1 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(1 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "group = [-1 for _ in range(2 * n)]",
      "mutated_line": "group = [-1 for _ in range(-2 * n)]",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(-2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index * (2 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index * (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index + 2 * n] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index + 2 * n] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (2 / n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 / n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (2 + n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 + n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % 2 ** n] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % 2 ** n] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) - j + 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j + 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += (len(nums) - j) * 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += (len(nums) - j) * 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = True\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) - j + 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j + 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += (len(nums) - j) * 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += (len(nums) - j) * 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = True\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 / n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 / n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (2 + n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 + n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % 2 ** n] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % 2 ** n] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (3 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (3 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (1 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (1 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (0 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (0 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (1 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (1 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "copy_group[index % (2 * n)] = group_num",
      "mutated_line": "copy_group[index % (-2 * n)] = group_num",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (-2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) + j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) + j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) * j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) * j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) - j - 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 2\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) - j - 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 0\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) - j - 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 0\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "temp += len(nums) - j - 1",
      "mutated_line": "temp += len(nums) - j - -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - -1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) + j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) + j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) * j - 1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) * j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) - j - 2",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 2\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) - j - 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 0\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) - j - 0",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 0\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans += len(nums) - j - 1",
      "mutated_line": "ans += len(nums) - j - -1",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - -1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (3 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (3 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (1 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (1 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (0 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (0 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (1 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (1 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if copy_group[index % (2 * n)] >= 0:",
      "mutated_line": "if copy_group[index % (-2 * n)] >= 0:",
      "code": "def max_intersections(n, k, initial_chords):\n    group = [-1 for _ in range(2 * n)]\n    for (u, v) in initial_chords:\n        group[u - 1] = group[v - 1] = 1\n    ans = 0\n    for start in range(2 * n):\n        if group[start] >= 0:\n            continue\n        copy_group = group[:]\n        group_num = k\n        index = start\n        while group_num < n:\n            if copy_group[index % (-2 * n)] >= 0:\n                index += 1\n                continue\n            copy_group[index % (2 * n)] = group_num\n            group_num += 1\n            index += 1\n        temp = 0\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == copy_group[i]:\n                    temp += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(copy_group[i])\n        ans = max(ans, temp)\n    if n == k:\n        nums = []\n        for i in range(2 * n):\n            flag = True\n            for j in range(len(nums)):\n                if nums[j] == group[i]:\n                    ans += len(nums) - j - 1\n                    nums.pop(j)\n                    flag = False\n                    break\n            if flag:\n                nums.append(group[i])\n    return ans"
    }
  ]
}