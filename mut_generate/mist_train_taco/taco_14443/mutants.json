{
  "task_id": "taco_14443",
  "entry_point": "find_food_arrangement",
  "mutant_count": 66,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] / (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] / (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] + 2 * n",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] + 2 * n\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] ** (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] ** (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] / (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] / (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] + 2 * n",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] + 2 * n\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] ** (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] ** (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (2 / n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 / n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (2 + n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 + n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * 2 ** n",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * 2 ** n\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (2 / n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 / n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (2 + n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 + n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * 2 ** n",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * 2 ** n\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 / n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 / n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 + n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 + n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(2 ** n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 ** n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while khavka[i] is None:",
      "mutated_line": "while khavka[i] is not None:",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is not None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [1] * (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [1] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [-1] * (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [-1] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [1] * (2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [1] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (3 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (3 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (1 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (1 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (0 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (0 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (1 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (1 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "partner = [0] * (2 * n)",
      "mutated_line": "partner = [0] * (-2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (-2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a + 1, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a + 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a * 1, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a * 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b + 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b + 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b * 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b * 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (3 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (3 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (1 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (1 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (0 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (0 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (1 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (1 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "khavka = [None] * (2 * n)",
      "mutated_line": "khavka = [None] * (-2 * n)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (-2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(3 * n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(3 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(1 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(0 * n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(0 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(1 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2 * n):",
      "mutated_line": "for i in range(-2 * n):",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(-2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "khavka[i] = 1",
      "mutated_line": "khavka[i] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 2\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "khavka[i] = 1",
      "mutated_line": "khavka[i] = 0",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 0\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "khavka[i] = 1",
      "mutated_line": "khavka[i] = 0",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 0\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "khavka[i] = 1",
      "mutated_line": "khavka[i] = -1",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = -1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 1] = 3",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 3\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 1] = 1",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 1\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 1] = 0",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 0\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 1] = 1",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 1\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 1] = -2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = -2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 2, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 2, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 0, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 0, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 0, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 0, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - -1, b - 1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - -1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b - 2)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 2)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b - 0)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 0)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b - 0)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 0)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pacan, telka = a - 1, b - 1",
      "mutated_line": "(pacan, telka) = (a - 1, b - -1)",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - -1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i | 1] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i | 1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "i = partner[i ^ 1]",
      "mutated_line": "i = partner[i | 1]",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i | 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 2] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 2] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 0] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 0] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ 0] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 0] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "khavka[i ^ 1] = 2",
      "mutated_line": "khavka[i ^ -1] = 2",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ -1] = 2\n            i = partner[i ^ 1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i = partner[i ^ 1]",
      "mutated_line": "i = partner[i ^ 2]",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 2]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i = partner[i ^ 1]",
      "mutated_line": "i = partner[i ^ 0]",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 0]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i = partner[i ^ 1]",
      "mutated_line": "i = partner[i ^ 0]",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ 0]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "i = partner[i ^ 1]",
      "mutated_line": "i = partner[i ^ -1]",
      "code": "def find_food_arrangement(n, pairs):\n    \"\"\"\n    Determines if it's possible to serve food to guests such that:\n    - Each person has exactly one type of food.\n    - No boy has the same type of food as his girlfriend.\n    - Among any three consecutive guests, there are two with different types of food.\n\n    Parameters:\n    n (int): The number of pairs of guests.\n    pairs (list of tuples): A list of tuples where each tuple contains two integers representing the chair numbers of the boy and his girlfriend.\n\n    Returns:\n    list of tuples: A list of tuples where each tuple contains two integers representing the food types for a pair of guests. If no solution is possible, returns -1.\n    \"\"\"\n    partner = [0] * (2 * n)\n    pacani = []\n    for (a, b) in pairs:\n        (pacan, telka) = (a - 1, b - 1)\n        partner[pacan] = telka\n        partner[telka] = pacan\n        pacani.append(pacan)\n    khavka = [None] * (2 * n)\n    for i in range(2 * n):\n        while khavka[i] is None:\n            khavka[i] = 1\n            khavka[i ^ 1] = 2\n            i = partner[i ^ -1]\n    result = []\n    for pacan in pacani:\n        result.append((khavka[pacan], khavka[partner[pacan]]))\n    return result"
    }
  ]
}