{
  "task_id": "taco_7868",
  "entry_point": "find_card_arrangement",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 and N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 and N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [0] / N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] / N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [0] + N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] + N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [0] ** N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] ** N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N <= 1 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N <= 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N >= 1 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N >= 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N != 1 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N != 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N >= 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N >= 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N <= 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N <= 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N != 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N != 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return +1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(2, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(0, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(0, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(-1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (i, v) in enumerate(p, 1):",
      "mutated_line": "for (i, v) in enumerate(p, 2):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 2):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (i, v) in enumerate(p, 1):",
      "mutated_line": "for (i, v) in enumerate(p, 0):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 0):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (i, v) in enumerate(p, 1):",
      "mutated_line": "for (i, v) in enumerate(p, 0):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 0):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for (i, v) in enumerate(p, 1):",
      "mutated_line": "for (i, v) in enumerate(p, -1):",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, -1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 2 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 2 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 0 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 0 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 0 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 0 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < -1 or N > 1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < -1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N > 1001:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1001:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N > 999:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 999:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N > 0:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 0:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N > 1:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if N < 1 or N > 1000:",
      "mutated_line": "if N < 1 or N > -1000:",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > -1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -2\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -0\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -0\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return --1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(2, N + 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(2, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(0, N + 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(0, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(0, N + 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(0, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(-1, N + 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(-1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N - 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N - 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N * 1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N * 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [1] * N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [1] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [-1] * N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [-1] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = [0] * N",
      "mutated_line": "ans = [1] * N",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [1] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "D.rotate(-i)",
      "mutated_line": "D.rotate(+i)",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(+i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v + 1] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v + 1] = i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v * 1] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v * 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N + 2))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 2))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N + 0))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 0))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N + 0))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 0))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = deque(range(1, N + 1))",
      "mutated_line": "D = deque(range(1, N + -1))",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + -1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 1] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v - 2] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 2] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v - 0] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 0] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v - 0] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - 0] = i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[v - 1] = i",
      "mutated_line": "ans[v - -1] = i",
      "code": "def find_card_arrangement(N):\n    from collections import deque\n    if N < 1 or N > 1000:\n        return -1\n    D = deque(range(1, N + 1))\n    ans = [0] * N\n    p = []\n    for i in range(1, N):\n        D.rotate(-i)\n        p.append(D.popleft())\n    p.append(D.pop())\n    for (i, v) in enumerate(p, 1):\n        ans[v - -1] = i\n    return ans"
    }
  ]
}